{"version":3,"sources":["../src/index.ts","../src/types.ts","../src/utils.ts","../src/tools/semver.ts","../src/decoding/tokenDecoding.ts","../src/tools/old_to_intermediate/intermediate_types.ts","../src/tools/old_to_intermediate/v0_to_intermediate.ts","../src/tools/old_to_intermediate/v1_to_intermediate.ts","../src/tools/old_to_intermediate/index.ts","../src/decoding/collectionDecoding.ts","../src/constants.ts","../src/schema.zod.ts","../src/encoding.ts"],"sourcesContent":["import {decodeCollectionToV2} from './decoding/collectionDecoding'\nimport {decodeTokenToV2} from './decoding/tokenDecoding'\nimport {encodeCollection, encodeToken} from './encoding'\nimport * as schemas from './schema.zod'\nimport {\n  decodeV0OrV1CollectionSchemaToIntermediate,\n  decodeV0OrV1TokenToIntermediate,\n  parseImageLinkOptions\n} from './tools/old_to_intermediate'\nimport {DEFAULT_PERMISSION, PERMISSION, SCHEMA_NAME, SCHEMA_VERSION} from './constants'\n\nexport const SchemaTools = {\n  decode: {\n    collection: decodeCollectionToV2,\n    token: decodeTokenToV2,\n  },\n  encode: {\n    collection: encodeCollection,\n    token: encodeToken,\n  },\n  tools: {\n    schemas,\n    decodeOld: {\n      collection: decodeV0OrV1CollectionSchemaToIntermediate,\n      token: decodeV0OrV1TokenToIntermediate,\n      utils: {\n        parseImageLinkOptions\n      },\n    },\n    constants: {\n      DEFAULT_SCHEMA_NAME: SCHEMA_NAME,\n      DEFAULT_SCHEMA_VERSION: SCHEMA_VERSION,\n      DEFAULT_PERMISSION: DEFAULT_PERMISSION,\n      PERMISSIONS: PERMISSION,\n    }\n  },\n}\n\nexport * from './types'\nexport type * from './schema.zod'\n","import {\n  DecodingImageLinkOptions,\n  UniqueCollectionSchemaIntermediate\n} from './tools/old_to_intermediate/intermediate_types'\n\nexport type ProbablyDecodedProperty = {\n  key: string\n  valueHex: string\n  value?: string | null\n}\n\nexport type PropertyForEncoding =\n  { key: string, valueHex?: undefined, value: string }\n  |\n  { key: string, valueHex: string, value?: undefined }\n\nexport type PropertyWithHex = { key: string, valueHex: string, value?: string }\n\nexport type ProbablyDecodedPropsDict = Record<string, { value: string | null, valueHex: string }>\n\nexport type DecodeCollectionOptions = {\n  tryRequestForMediaDetails?: boolean\n\n  decodingImageLinkOptions?: DecodingImageLinkOptions\n}\n\nexport type DecodeTokenOptions = {\n  // collectionId: string | number\n\n  tokenId?: number\n  collectionProperties?: ProbablyDecodedProperty[]\n  tokenOwner?: string\n\n  collectionDecodedSchemaV1?: UniqueCollectionSchemaIntermediate\n\n  tryRequestForTokenURI?: boolean\n  tryRequestForMediaDetails?: boolean\n\n  decodingImageLinkOptions?: DecodingImageLinkOptions\n}\n\nexport type CrossAccountId = { Substrate: string } & { Ethereum?: never } | { Ethereum: string } & { Substrate?: never }\n\n\nexport interface TokenPropertyPermission {\n  mutable: boolean\n  collectionAdmin: boolean\n  tokenOwner: boolean\n}\n\nexport interface TokenPropertyPermissionObject {\n  key: string\n  permission: TokenPropertyPermission\n}\n\n\nexport type CollectionTokenPropertyPermissions = Array<TokenPropertyPermissionObject>\n\n/////////////////////////////////////////////////////\n// encoding params and results\n/////////////////////////////////////////////////////\n\nexport type EncodeCollectionOptions = {\n  defaultPermission?: TokenPropertyPermission\n\n  overwriteTPPs?: CollectionTokenPropertyPermissions\n  overwriteProperties?: PropertyForEncoding[]\n}\n\nexport type EncodeCollectionResult = {\n  collectionProperties: PropertyWithHex[]\n  tokenPropertyPermissions: CollectionTokenPropertyPermissions\n  flags: number\n}\n\nexport type EncodeTokenOptions = {\n  URI?: string\n  overwriteProperties?: PropertyForEncoding[]\n}\n\nexport enum COLLECTION_SCHEMA_FAMILY {\n  V0 = 'V0',\n  V1 = 'V1',\n  V2 = 'V2',\n  OTHER_ERC721 = 'ERC721',\n  UNKNOWN = 'UNKNOWN'\n}\n","import {ProbablyDecodedProperty, ProbablyDecodedPropsDict, PropertyForEncoding, PropertyWithHex} from './types'\nimport {Utf8} from '@unique-nft/utils/string'\nimport {StringUtils} from '@unique-nft/utils'\nimport {IV2Royalty} from '@unique-nft/utils/royalties'\n\nexport const safeJSONParseWithPossibleEmptyInput = <T>(str?: string | null | undefined): T | string | null => {\n  if (typeof str !== 'string') return null\n\n  try {\n    return JSON.parse(str) as T\n  } catch (e) {\n    return str\n  }\n}\n\n\nexport const safelyDecodeUTF8String = (hex: string): string | null => {\n  try {\n    return Utf8.hexStringToString(hex)\n  } catch (e) {\n    return null\n  }\n}\n\n\nexport const decodeHexAndParseJSONOrReturnNull = <T = any>(hexString: string): T | null => {\n  try {\n    return JSON.parse(StringUtils.Utf8.hexStringToString(hexString)) as T\n  } catch {\n    return null\n  }\n}\n\nexport const safeJSONParse = <T>(str: string): T | string => {\n  try {\n    return JSON.parse(str) as T\n  } catch {\n    return str\n  }\n}\n\n\n\n\nexport const buildDictionaryFromPropertiesArray = (\n  properties?: ProbablyDecodedProperty[]\n): ProbablyDecodedPropsDict => {\n  if (!properties) return {}\n\n  return properties.reduce((acc, property) => {\n    acc[property.key] = {\n      valueHex: property.valueHex,\n      value: property.value || safelyDecodeUTF8String(property.valueHex),\n    }\n    return acc\n  }, {} as ProbablyDecodedPropsDict)\n}\n\n\nexport const getTokenURI = (tokenProperties: ProbablyDecodedPropsDict, collectionProperties?: ProbablyDecodedPropsDict): string | null => {\n  const tokenURI = tokenProperties.URI?.value ||\n    (\n      (collectionProperties?.baseURI?.value || '') +\n      (tokenProperties.URISuffix?.value || '')\n    )\n\n  return tokenURI || null\n}\n\nexport const zipTwoArraysByKey = <T extends { key: string }>(src1: T[], src2: T[]): T[] => {\n  if (src2.length === 0) return src1\n\n  const result: T[] = [...src1]\n  for (const property of src2) {\n    const index = result.findIndex(p => p.key === property.key)\n    if (index === -1) {\n      result.push(property)\n    } else {\n      result[index] = property\n    }\n  }\n  return result\n}\n\nexport const hexifyProperties = (properties: PropertyForEncoding[]): PropertyWithHex[] => {\n  return properties.map(p => ({\n    key: p.key,\n    valueHex: p.valueHex ?? Utf8.stringToHexString(p.value),\n  }))\n}\n\nexport const mergeRoyalties = (a: IV2Royalty[], b: IV2Royalty[]): IV2Royalty[] => {\n  // royalty is {address: string, percent: number}\n  // need to zip them, when a and b have same address, use b value\n\n  const result: IV2Royalty[] = [...a.map(r => ({...r}))]\n  for (const royalty of b) {\n    const index = result.findIndex(r => r.address === royalty.address)\n    if (index === -1) {\n      result.push(royalty)\n    } else {\n      result[index] = royalty\n    }\n  }\n\n  return result\n}\n","export class Semver {\n  protected _major: number\n  protected _minor: number\n  protected _patch: number\n\n  constructor(semver: [number, number, number]) {\n    this._major = semver[0]\n    this._minor = semver[1]\n    this._patch = semver[2]\n  }\n\n  get major() {\n    return this._major\n  }\n\n  get minor() {\n    return this._minor\n  }\n\n  get patch() {\n    return this._patch\n  }\n\n  toString() {\n    return `${this.major}.${this.minor}.${this.patch}`\n  }\n\n  private static parseToArray(version: string): null | [number, number, number] {\n    if (typeof version !== \"string\") return null\n\n    const [main] = version.split('+')[0].split('-').map(i => i.split('.'))\n\n    const major = parseInt(main[0])\n\n    if (isNaN(major)) return null\n\n    const minor = parseInt(main[1])\n    const patch = parseInt(main[2])\n    return [major, isNaN(minor) ? 0 : minor, isNaN(patch) ? 0 : patch]\n  }\n\n  static fromString(version: string): Semver {\n    const parsed = Semver.parseToArray(version)\n    if (!parsed) throw new Error(`Semver.fromString: wrong version string value: \"${version}\"`)\n    return new Semver(parsed)\n  }\n\n  static isValid(version: string): boolean {\n    return typeof version === 'string' && Semver.parseToArray(version) !== null\n  }\n\n  isGteThan(version: string) {\n    const parsed = Semver.parseToArray(version)\n    if (!parsed) return false\n\n    if (this._major > parsed[0]) return true\n    if (this._major < parsed[0]) return false\n\n    if (this._minor > parsed[1]) return true\n    if (this._minor < parsed[1]) return false\n\n    return this._patch >= parsed[2]\n  }\n\n  isLessThan(version: string) {\n    const parsed = Semver.parseToArray(version)\n    if (!parsed) return false\n\n    if (this._major < parsed[0]) return true\n    if (this._major > parsed[0]) return false\n\n    if (this._minor < parsed[1]) return true\n    if (this._minor > parsed[1]) return false\n\n    return this._patch < parsed[2]\n  }\n\n  isEqual(version: string) {\n    const parsed = Semver.parseToArray(version)\n    if (!parsed) return false\n\n    return this._major === parsed[0] && this._minor === parsed[1] && this._patch === parsed[2]\n  }\n}\n","import {IV2Media, IV2Royalty, IV2Token} from '../schema.zod'\nimport {Semver} from '../tools/semver'\nimport {COLLECTION_SCHEMA_FAMILY, DecodeTokenOptions, ProbablyDecodedProperty, ProbablyDecodedPropsDict} from '../types'\nimport {\n  buildDictionaryFromPropertiesArray,\n  getTokenURI,\n  mergeRoyalties,\n  safeJSONParseWithPossibleEmptyInput\n} from '../utils'\nimport {Royalties} from '@unique-nft/utils/royalties'\nimport {\n  decodeV0OrV1CollectionSchemaToIntermediate,\n  decodeV0OrV1TokenToIntermediate\n} from '../tools/old_to_intermediate'\nimport {UniqueCollectionSchemaIntermediate} from '../tools/old_to_intermediate/intermediate_types'\n\nexport const detectCollectionSchemaFamily = (\n  tokenPropsDict: ProbablyDecodedPropsDict,\n  collectionPropsDict: ProbablyDecodedPropsDict,\n  schemaV1?: UniqueCollectionSchemaIntermediate\n): {schemaFamily: COLLECTION_SCHEMA_FAMILY, tokenURI: string | null} => {\n  if (\n    schemaV1?.schemaFamily &&\n    [COLLECTION_SCHEMA_FAMILY.V0, COLLECTION_SCHEMA_FAMILY.V1].includes(schemaV1?.schemaFamily as COLLECTION_SCHEMA_FAMILY)\n  ) {\n    return {schemaFamily: schemaV1.schemaFamily as COLLECTION_SCHEMA_FAMILY, tokenURI: null}\n  }\n\n  const isUniqueSchema = tokenPropsDict.schemaName?.value === 'unique' ||\n    collectionPropsDict.schemaName?.value === 'unique' ||\n    collectionPropsDict.schemaName?.value === '\"unique\"'\n\n  let uniqueVersionString = isUniqueSchema\n    ? (tokenPropsDict.schemaVersion?.value || collectionPropsDict.schemaVersion?.value)\n    : null\n\n  if (uniqueVersionString && uniqueVersionString.startsWith('\"')) {\n    uniqueVersionString = uniqueVersionString.slice(1, -1)\n  }\n  const uniqueVersion = Semver.fromString(uniqueVersionString || '0.0.0')\n\n  const tokenURI = getTokenURI(tokenPropsDict, collectionPropsDict)\n\n  const isUniqueV2 = uniqueVersion.major === 2\n\n  const isOtherErc721 = !!tokenURI && !isUniqueV2\n\n  const schemaFamily = isUniqueV2\n    ? COLLECTION_SCHEMA_FAMILY.V2\n    : uniqueVersion.major === 1\n      ? COLLECTION_SCHEMA_FAMILY.V1\n      : '_old_schemaVersion' in collectionPropsDict\n        ? COLLECTION_SCHEMA_FAMILY.V0\n        : isOtherErc721\n          ? COLLECTION_SCHEMA_FAMILY.OTHER_ERC721\n          : COLLECTION_SCHEMA_FAMILY.UNKNOWN\n\n  return {\n    schemaFamily,\n    tokenURI\n  }\n}\n\nexport const decodeTokenToV2 = async (\n  tokenProperties: ProbablyDecodedProperty[],\n  options?: DecodeTokenOptions\n): Promise<IV2Token> => {\n  const tokenPropsDict = buildDictionaryFromPropertiesArray(tokenProperties)\n  const collectionPropsDict = buildDictionaryFromPropertiesArray(options?.collectionProperties)\n\n  const {\n    schemaFamily,\n    tokenURI\n  } = detectCollectionSchemaFamily(tokenPropsDict, collectionPropsDict, options?.collectionDecodedSchemaV1)\n\n\n  if ([COLLECTION_SCHEMA_FAMILY.V2, COLLECTION_SCHEMA_FAMILY.OTHER_ERC721].includes(schemaFamily)) {\n    return await decodeTokenUniqueV2(tokenPropsDict, collectionPropsDict, tokenURI, options)\n  }\n\n  if ([COLLECTION_SCHEMA_FAMILY.V0, COLLECTION_SCHEMA_FAMILY.V1].includes(schemaFamily)) {\n    return await decodeTokenUniqueV0OrV1(\n      tokenProperties,\n      schemaFamily,\n      options,\n    )\n  }\n\n  throw new Error('Unknown token schema version - not Unique v2, v1 or v0 and not ERC721Metadata-compatible')\n}\n\n\nconst decodeTokenUniqueV0OrV1 = async (\n  tokenProperties: ProbablyDecodedProperty[],\n  schemaFamily: COLLECTION_SCHEMA_FAMILY,\n  options?: DecodeTokenOptions,\n) => {\n  const collectionProperties = options?.collectionProperties\n\n  let collectionSchema = options?.collectionDecodedSchemaV1\n  if (!collectionSchema) {\n    if (!Array.isArray(collectionProperties)) {\n      throw new Error('Collection properties are required for decoding tokens in Unique schema for versions less than v2 and no pre-decoded schema have been provided')\n    }\n\n    const collectionDecodedSchemaV1 = options?.collectionDecodedSchemaV1\n\n    collectionSchema = collectionDecodedSchemaV1\n      ? collectionDecodedSchemaV1\n      : decodeV0OrV1CollectionSchemaToIntermediate(\n        collectionProperties,\n        schemaFamily\n      )\n  }\n\n  const tokenIntermediateRepresentation = decodeV0OrV1TokenToIntermediate(\n    tokenProperties,\n    collectionSchema,\n    options,\n  )\n\n  const attributesArray = Object.values(tokenIntermediateRepresentation.attributes)\n  const tokenName = tokenIntermediateRepresentation.name?._ ??\n    (attributesArray.find(attribute => attribute.name._ === 'name')?.value as any)?._ as string ?? null\n  const tokenDescription = tokenIntermediateRepresentation.description?._ ??\n    (attributesArray.find(attribute => attribute.name._ === 'description')?.value as any)?._ as string ?? null\n\n  // fill attributes in v2 style (erc721)\n  const attributesInV2Style: Array<{ trait_type: string, value: string | number }> = []\n  attributesArray.forEach(attribute => {\n    const trait_type = attribute.name._\n    if (attribute.isArray && Array.isArray(attribute.value)) {\n      attribute.value.forEach(value => {\n        attributesInV2Style.push({trait_type, value: value._,})\n      })\n    } else {\n      const value = (attribute.value as any)?._\n      if (['string', 'number'].includes(typeof value)) {\n        attributesInV2Style.push({trait_type: attribute.name._, value,})\n      }\n    }\n  })\n\n  //todo: retrieve media details if requested in options.tryRequestForMediaDetails\n  const media: Record<string, IV2Media> = {}\n  if (tokenIntermediateRepresentation.video && tokenIntermediateRepresentation.video.fullUrl)\n    media.video = {type: 'video', url: tokenIntermediateRepresentation.video.fullUrl}\n  if (tokenIntermediateRepresentation.audio && tokenIntermediateRepresentation.audio.fullUrl)\n    media.audio = {type: 'audio', url: tokenIntermediateRepresentation.audio.fullUrl}\n  if (tokenIntermediateRepresentation.spatialObject && tokenIntermediateRepresentation.spatialObject.fullUrl)\n    media.spatial = {type: 'spatial', url: tokenIntermediateRepresentation.spatialObject.fullUrl}\n  if (tokenIntermediateRepresentation.file && tokenIntermediateRepresentation.file.fullUrl)\n    media.file = {type: 'document', url: tokenIntermediateRepresentation.file.fullUrl}\n\n  const tokenRoyaltyEncoded = tokenProperties.find(prop => prop.key === 'royalties')?.valueHex\n  const tokenRoyalties: IV2Royalty[] = tokenRoyaltyEncoded ? Royalties.uniqueV2.decode(tokenRoyaltyEncoded) : []\n\n  const collectionRoyaltiesEncoded = collectionProperties?.find(prop => prop.key === 'royalties')?.valueHex\n  const collectionRoyalties =\n  collectionSchema.royalties\n    ? collectionSchema.royalties\n    : collectionRoyaltiesEncoded\n      ? Royalties.uniqueV2.decode(collectionRoyaltiesEncoded)\n      : []\n\n  const royalties = mergeRoyalties(collectionRoyalties, tokenRoyalties)\n\n  const isUniqueV0 = schemaFamily === COLLECTION_SCHEMA_FAMILY.V0\n\n  // convert token from intermediate representation to v2 one\n  const tokenV2: IV2Token = {\n    schemaName: 'unique',\n    schemaVersion: '2.0.0',\n    originalSchemaVersion: isUniqueV0 ? '0.0.1' : (collectionSchema.schemaVersion || '1.0.0'),\n  }\n  if (tokenIntermediateRepresentation.image && tokenIntermediateRepresentation.image.fullUrl) {\n    //todo: retrieve media details if requested in options.tryRequestForMediaDetails\n    tokenV2.image = tokenIntermediateRepresentation.image.fullUrl\n  }\n\n  if (tokenName) tokenV2.name = tokenName\n  if (tokenDescription) tokenV2.description = tokenDescription\n  if (attributesInV2Style.length > 0) tokenV2.attributes = attributesInV2Style\n  if (Object.keys(media).length > 0) tokenV2.media = media\n  if (royalties.length > 0) tokenV2.royalties = royalties\n\n  return tokenV2\n}\n\nconst decodeTokenUniqueV2 = async (tokenProperties: ProbablyDecodedPropsDict, collectionProps: ProbablyDecodedPropsDict | null, tokenURI: string | null, options?: DecodeTokenOptions): Promise<IV2Token> => {\n  // for not UniqueV2 will be probably empty\n  // if somebody will use this property for not UniqueV2 data - ¯\\_(ツ)_/¯\n  let tokenDataString = tokenProperties.tokenData?.value || null\n\n  if (!tokenDataString && options?.tryRequestForTokenURI && tokenURI) {\n    tokenDataString = await fetch(tokenURI).then(r => r.text())\n  }\n\n  const tokenData = safeJSONParseWithPossibleEmptyInput(tokenDataString)\n\n  if (typeof tokenData === 'string' || tokenData === null) {\n    throw new Error('Unable to parse tokenData JSON')\n  }\n\n  //todo: parse royalties and patch tokenData\n  const tokenRoyaltiesHexString = tokenProperties.royalties?.valueHex\n  const collectionRoyaltiesHexString = collectionProps?.royalties?.valueHex\n\n  //todo: parse overrides and patch tokenData\n  //todo: parse customizing_overrides and patch tokenData\n  return tokenData as IV2Token\n}\n","import {COLLECTION_SCHEMA_FAMILY} from '../../types'\nimport {IV2Royalty} from '@unique-nft/utils/royalties'\n\nexport class ValidationError extends TypeError {\n  constructor(message: string) {\n    super(message)\n    this.name = 'ValidationError'\n  }\n}\n\nexport type InfixOrUrlOrCidAndHash = {\n  url?: string | undefined,\n  urlInfix?: string | undefined,\n  ipfsCid?: string | undefined,\n  hash?: string | undefined\n}\nexport const URL_TEMPLATE_INFIX = <const>'{infix}'\n\n\nexport enum AttributeType {\n  integer = \"integer\",        // number\n  float = \"float\",            // number\n  boolean = \"boolean\",        // number\n  timestamp = \"timestamp\",    // number // js, milliseconds from epoch\n  string = \"string\",          // string\n  url = \"url\",                // string\n  isoDate = \"isoDate\",        // string // ISO Date: YYYY-MM-DD\n  time = \"time\",              // string // 24h time: HH:mm:ss\n  colorRgba = \"colorRgba\",    // string // 'rrggbbaa'\n}\n\nexport type BoxedNumberWithDefault = {\n  _: number\n}\nexport type LocalizedStringWithDefault = {\n  _: string\n  [K: string]: string\n}\nexport type LocalizedStringOrBoxedNumberWithDefault = BoxedNumberWithDefault | LocalizedStringWithDefault\n\nexport interface AttributeSchema {\n  name: LocalizedStringWithDefault\n  optional?: boolean\n  isArray?: boolean\n  type: AttributeType\n  enumValues?: { [K: number]: LocalizedStringOrBoxedNumberWithDefault }\n}\n\nexport type EncodedTokenAttributeValue =\n  number |\n  Array<number> |\n  LocalizedStringOrBoxedNumberWithDefault\n  | LocalizedStringOrBoxedNumberWithDefault[]\n\nexport interface EncodedTokenAttributes {\n  [K: number]: EncodedTokenAttributeValue\n}\n\nexport type CollectionAttributesSchema = {\n  [K: number]: AttributeSchema\n}\n\nexport type UniqueCollectionSchemaIntermediate = {\n  schemaName: string\n  schemaVersion: string // semver\n  schemaFamily: COLLECTION_SCHEMA_FAMILY | `${COLLECTION_SCHEMA_FAMILY}`,\n\n  attributesSchemaVersion?: string\n  attributesSchema?: CollectionAttributesSchema\n\n  image: {\n    urlTemplate: string\n  }\n\n  imagePreview?: {\n    urlTemplate?: string\n  }\n\n  video?: {\n    urlTemplate?: string\n  }\n\n  audio?: {\n    urlTemplate?: string\n    format?: string\n    isLossless?: boolean\n  }\n\n  spatialObject?: {\n    urlTemplate?: string\n    format?: string\n  }\n\n  file?: {\n    urlTemplate?: string\n  }\n\n  // collectionId: number\n  coverPicture: DecodedInfixOrUrlOrCidAndHash\n  coverPicturePreview?: DecodedInfixOrUrlOrCidAndHash\n\n  oldProperties?: {\n    _old_schemaVersion?: string\n    _old_offchainSchema?: string\n    _old_constOnChainSchema?: string\n    _old_variableOnChainSchema?: string\n  }\n\n  royalties?: IV2Royalty[]\n}\n\n\nexport type DecodedAttributes = {\n  [K: number]: {\n    name: LocalizedStringWithDefault\n    value: LocalizedStringOrBoxedNumberWithDefault | Array<LocalizedStringOrBoxedNumberWithDefault>\n    type: AttributeType\n    isArray: boolean\n    rawValue: EncodedTokenAttributeValue | string | Array<string>\n    isEnum: boolean\n  }\n}\n\nexport type DecodedInfixOrUrlOrCidAndHash = InfixOrUrlOrCidAndHash & { fullUrl: string | null }\n\nexport interface UniqueTokenIntermediate {\n  encodedAttributes?: EncodedTokenAttributes\n\n  name?: LocalizedStringWithDefault\n  description?: LocalizedStringWithDefault\n  image: DecodedInfixOrUrlOrCidAndHash\n  imagePreview?: DecodedInfixOrUrlOrCidAndHash\n  video?: DecodedInfixOrUrlOrCidAndHash\n  audio?: DecodedInfixOrUrlOrCidAndHash\n  file?: DecodedInfixOrUrlOrCidAndHash\n  spatialObject?: DecodedInfixOrUrlOrCidAndHash\n\n  nestingParentToken?: {\n    collectionId: number\n    tokenId: number\n  }\n  attributes: DecodedAttributes\n}\n\nexport type DecodingImageLinkOptions = {\n  imageUrlTemplate?: string\n  dummyImageFullUrl?: string\n}\n","import {\n  AttributeSchema,\n  AttributeType,\n  CollectionAttributesSchema,\n  DecodedAttributes,\n  DecodedInfixOrUrlOrCidAndHash,\n  DecodingImageLinkOptions,\n  UniqueCollectionSchemaIntermediate,\n  UniqueTokenIntermediate,\n  ValidationError\n} from \"./intermediate_types\";\n\nimport type {Message, Type} from 'protobufjs'\nimport protobufjs from 'protobufjs'\nimport {StringUtils} from \"@unique-nft/utils\";\nimport {buildDictionaryFromPropertiesArray, safeJSONParse, safeJSONParseWithPossibleEmptyInput} from '../../utils'\nimport {COLLECTION_SCHEMA_FAMILY, DecodeTokenOptions, ProbablyDecodedProperty} from '../../types'\nimport {parseImageLinkOptions} from './index'\n\n\nconst isOffchainSchemaAValidUrl = (offchainSchema: string | undefined): offchainSchema is string => {\n  return typeof offchainSchema === \"string\" && offchainSchema.indexOf('{id}') >= 0\n}\n\nexport const decodeOldSchemaCollection = (properties: ProbablyDecodedProperty[], decodingImageLinkOptions?: DecodingImageLinkOptions): UniqueCollectionSchemaIntermediate => {\n  const {imageUrlTemplate, dummyImageFullUrl} = parseImageLinkOptions(decodingImageLinkOptions)\n\n  const propObj = properties.reduce((acc, {key, value, valueHex}) => {\n    acc[key] = value ?? StringUtils.Utf8.hexStringToString(valueHex)\n    return acc\n  }, {} as Record<string, string>)\n\n  const offchainSchema: string | undefined = propObj._old_offchainSchema\n  const constOnchainSchema: string | undefined = propObj._old_constOnChainSchema\n  const schemaVersion: string | undefined = propObj._old_schemaVersion\n  const variableOnchainSchema: string | undefined = propObj._old_variableOnChainSchema\n\n  const offchainSchemaIsValidUrl = isOffchainSchemaAValidUrl(offchainSchema)\n\n  const schema: UniqueCollectionSchemaIntermediate = {\n    schemaName: 'unique',\n    schemaVersion: '0.0.1',\n    schemaFamily: COLLECTION_SCHEMA_FAMILY.V0,\n\n    coverPicture: {\n      url: dummyImageFullUrl,\n      fullUrl: null\n    },\n    image: {\n      urlTemplate: offchainSchemaIsValidUrl\n        ? offchainSchema.replace('{id}', '{infix}')\n        : imageUrlTemplate\n    },\n\n    attributesSchema: {},\n    attributesSchemaVersion: '1.0.0'\n  }\n\n  let parsedVariableOnchainSchema = null\n  try {\n    parsedVariableOnchainSchema = JSON.parse(variableOnchainSchema)\n  } catch {\n  }\n\n  if (parsedVariableOnchainSchema && typeof parsedVariableOnchainSchema === 'object' && typeof parsedVariableOnchainSchema.collectionCover === 'string') {\n    schema.coverPicture.ipfsCid = parsedVariableOnchainSchema.collectionCover\n    delete schema.coverPicture.url\n    schema.coverPicture.fullUrl = imageUrlTemplate.replace('{infix}', parsedVariableOnchainSchema.collectionCover)\n  } else if (offchainSchemaIsValidUrl) {\n    const coverUrl = offchainSchema.replace('{id}', '1')\n    schema.coverPicture.url = coverUrl\n    schema.coverPicture.fullUrl = coverUrl\n  }\n\n\n  let root: protobufjs.Root = {} as any\n  let NFTMeta: Type = {} as any\n\n  root = protobufjs.Root.fromJSON(JSON.parse(constOnchainSchema))\n  NFTMeta = root.lookupType('onChainMetaData.NFTMeta')\n\n  const attributesSchema: CollectionAttributesSchema = {}\n\n  let i = 0;\n  for (const field of NFTMeta.fieldsArray) {\n    if (field.name === 'ipfsJson') {\n      continue\n    }\n\n    const options = !['string', 'number'].includes(field.type) && root.lookupEnum(field.type).options || {}\n    const values = !['string', 'number'].includes(field.type) && root.lookupEnum(field.type).values || {}\n\n    const rawValueToDecodedValueDict: Record<number, any> = {}\n    for (const [innerKey, realJSONStr] of Object.entries(options || {})) {\n      const numberedKey = values[innerKey] as number | undefined\n      if (typeof numberedKey !== 'number') continue\n\n      const realJSON = safeJSONParseWithPossibleEmptyInput(realJSONStr) as any\n      if (typeof realJSON === 'string') continue\n\n      realJSON._ = realJSON._ || realJSON.en || realJSON[Object.keys(realJSON)[0]] || null\n      if (typeof realJSON._ !== 'string') continue\n\n      rawValueToDecodedValueDict[numberedKey] = realJSON\n    }\n\n    const attr: AttributeSchema = {\n      type: AttributeType.string,\n      name: {_: field.name},\n      isArray: field.repeated,\n      optional: !field.required,\n    }\n    if (Object.keys(rawValueToDecodedValueDict).length > 0) {\n      attr.enumValues = rawValueToDecodedValueDict\n    }\n\n    attributesSchema[i++] = attr\n  }\n\n  schema.attributesSchema = attributesSchema\n  schema.attributesSchemaVersion = '1.0.0'\n\n  schema.oldProperties = {\n    _old_schemaVersion: schemaVersion,\n    _old_offchainSchema: offchainSchema,\n    _old_constOnChainSchema: constOnchainSchema,\n    _old_variableOnChainSchema: variableOnchainSchema,\n  }\n\n  return schema\n}\n\nexport const decodeOldSchemaToken = (\n  propertiesArray: ProbablyDecodedProperty[],\n  schema: UniqueCollectionSchemaIntermediate,\n  decodingImageLinkOptions?: DecodingImageLinkOptions,\n  options?: DecodeTokenOptions\n): UniqueTokenIntermediate => {\n  const constOnchainSchema = schema.oldProperties?._old_constOnChainSchema\n\n  if (!constOnchainSchema) {\n    throw new ValidationError(`collection doesn't contain _old_constOnChainSchema field`)\n  }\n\n  const root = protobufjs.Root.fromJSON(JSON.parse(constOnchainSchema))\n  const NFTMeta = root.lookupType('onChainMetaData.NFTMeta')\n\n\n  if (!propertiesArray) {\n    throw new ValidationError(`parsing token with old schema: no token properties passed`)\n  }\n\n  const props = buildDictionaryFromPropertiesArray(propertiesArray)\n\n  const constDataProp = props._old_constData\n  if (!constDataProp) {\n    throw new ValidationError('no _old_constData property found')\n  }\n\n  const u8aToken = StringUtils.HexString.toU8a(constDataProp.valueHex)\n  let tokenDecoded: Message<{}> = {} as any\n  let tokenDecodedHuman: Record<string, any> = {}\n  let tokenDecodedWithRawValues: Array<{\n    name: string\n    rawValue: typeof Message<{}>[keyof typeof Message<{}>]\n    toJSONValue: any\n  }> = []\n\n  try {\n    tokenDecoded = NFTMeta.decode(u8aToken)\n    tokenDecodedHuman = tokenDecoded.toJSON()\n    tokenDecodedWithRawValues = Object.entries(tokenDecoded).map(([name, rawValue], index) => ({\n      name,\n      rawValue: rawValue,\n      toJSONValue: tokenDecodedHuman[name],\n    }))\n  } catch (err: any) {\n    throw new ValidationError(`Unable to parse token with old schema, error on decoding Protobuf: ${err.message}`)\n  }\n\n  const tokenAttributesResult: DecodedAttributes = {}\n\n  let i = 0\n  for (const entry of tokenDecodedWithRawValues) {\n    let {name, rawValue, toJSONValue} = entry\n    if (name === 'ipfsJson') {\n      continue\n    }\n\n    let value = toJSONValue\n    let isArray = false\n    let isEnum = false\n\n    const field = tokenDecoded.$type.fields[name]\n\n    if (!['string', 'number'].includes(field.type)) {\n      const enumOptions = root.lookupEnum(field.type).options\n      isEnum = !!enumOptions;\n\n      if (field.repeated && Array.isArray(rawValue) && toJSONValue) {\n        const parsedValues = toJSONValue\n          .map((v: any) => {\n            const parsed = safeJSONParse<any>(enumOptions?.[v] || v)\n            if (typeof parsed !== 'string') {\n              parsed._ = parsed.en\n              return parsed\n            } else {\n              return null\n            }\n          })\n          .filter((v: any) => typeof v?._ === 'string')\n\n        value = parsedValues\n        isArray = true\n      } else {\n        value = safeJSONParse(enumOptions?.[toJSONValue] || rawValue)\n        if (typeof value !== 'string') {\n          value._ = value.en || Object.values(value)[0]\n        }\n      }\n    }\n\n    if (field.type === 'string') value = {_: value}\n\n    const schemaAttr = Object.entries(schema.attributesSchema!).find(([attrId, attrValue]) => {\n      return attrValue.name._ === name\n    })\n\n    const index = schemaAttr ? schemaAttr[0] : i\n    i += 1\n\n    tokenAttributesResult[index as any] = {\n      name: {_: name},\n      type: field.type === 'number' ? AttributeType.float : AttributeType.string,\n      value,\n      isArray,\n      isEnum,\n      rawValue: isEnum ? rawValue as any : {_: rawValue},\n    }\n  }\n\n\n  const schemaVersion = schema.oldProperties?._old_schemaVersion\n  const offchainSchema = schema.oldProperties?._old_offchainSchema\n\n\n  const {imageUrlTemplate, dummyImageFullUrl} = parseImageLinkOptions(decodingImageLinkOptions)\n\n  let image: DecodedInfixOrUrlOrCidAndHash = {\n    url: dummyImageFullUrl,\n    fullUrl: null,\n  }\n\n  let ipfsImageIsSet = false\n  if (schemaVersion === 'Unique') {\n    try {\n      const ipfsCid = JSON.parse(tokenDecodedHuman.ipfsJson).ipfs\n      image = {\n        ipfsCid,\n        fullUrl: imageUrlTemplate.replace('{infix}', ipfsCid)\n      }\n      ipfsImageIsSet = true\n    } catch {\n    }\n  }\n\n  if (!ipfsImageIsSet && isOffchainSchemaAValidUrl(offchainSchema)) {\n    const tokenId = options?.tokenId?.toString()\n    if (!tokenId) {\n      throw new ValidationError(`Decoding token in Unique schema v0: tokenId is required to parse this token and it is not provided. Please pass it inside options param.`)\n    }\n    image = {\n      urlInfix: tokenId,\n      fullUrl: offchainSchema.replace('{id}', tokenId)\n    }\n  }\n\n  const decodedToken: UniqueTokenIntermediate = {\n    image,\n    attributes: tokenAttributesResult,\n  }\n\n  return decodedToken\n}\n","import {\n  DecodedAttributes,\n  DecodedInfixOrUrlOrCidAndHash,\n  EncodedTokenAttributes,\n  InfixOrUrlOrCidAndHash,\n  LocalizedStringOrBoxedNumberWithDefault,\n  LocalizedStringWithDefault,\n  UniqueCollectionSchemaIntermediate,\n  UniqueTokenIntermediate,\n  URL_TEMPLATE_INFIX\n} from './intermediate_types'\n\nimport {COLLECTION_SCHEMA_FAMILY, DecodeTokenOptions, ProbablyDecodedProperty} from '../../types'\nimport {StringUtils} from '@unique-nft/utils'\nimport {decodeHexAndParseJSONOrReturnNull} from '../../utils'\n\n\nexport const decodeTokenUrlOrInfixOrCidWithHashField = <U extends {\n  urlTemplate?: string\n}>(obj: InfixOrUrlOrCidAndHash, urlTemplateObj: U | undefined): DecodedInfixOrUrlOrCidAndHash => {\n  const result: DecodedInfixOrUrlOrCidAndHash = {\n    ...obj,\n    fullUrl: null\n  }\n\n  if (typeof obj.url === 'string') {\n    result.fullUrl = obj.url\n    return result\n  }\n\n  const urlTemplate = urlTemplateObj?.urlTemplate\n\n  if (typeof urlTemplate !== 'string' || urlTemplate.indexOf(URL_TEMPLATE_INFIX) < 0) {\n    if (typeof obj.ipfsCid === 'string') {\n      result.fullUrl = `ipfs://${obj.ipfsCid}`\n    }\n  } else {\n    if (typeof obj.urlInfix === 'string') {\n      result.fullUrl = urlTemplate.replace(URL_TEMPLATE_INFIX, obj.urlInfix)\n    } else if (typeof obj.ipfsCid === 'string') {\n      result.fullUrl = urlTemplate.replace(URL_TEMPLATE_INFIX, obj.ipfsCid)\n    }\n  }\n\n  return result\n}\n\n\nconst convertPropertyArrayTo2layerObject = <T extends object>(properties: ProbablyDecodedProperty[], separator: string): T => {\n  const obj: any = {}\n\n  for (let {key, valueHex} of properties) {\n    const keyParts = key.split(separator)\n    const length = keyParts.length\n    if (length === 1) {\n      obj[key] = decodeHexAndParseJSONOrReturnNull(valueHex)\n    } else {\n      const [key, innerKey] = keyParts\n      if (typeof obj[key] !== 'object') {\n        obj[key] = {}\n      }\n      obj[key][innerKey] = decodeHexAndParseJSONOrReturnNull(valueHex)\n    }\n  }\n  return obj as T\n}\n\n\nexport const decodeUniqueCollectionFromProperties = (properties: ProbablyDecodedProperty[]): UniqueCollectionSchemaIntermediate => {\n  const unpackedSchema: UniqueCollectionSchemaIntermediate = convertPropertyArrayTo2layerObject(properties, '.') as any\n  // validateUniqueCollectionSchema(unpackedSchema)\n\n  if (unpackedSchema.coverPicture) {\n    unpackedSchema.coverPicture = decodeTokenUrlOrInfixOrCidWithHashField(unpackedSchema.coverPicture, unpackedSchema.image)\n  }\n  if (unpackedSchema.coverPicturePreview) {\n    unpackedSchema.coverPicturePreview = decodeTokenUrlOrInfixOrCidWithHashField(unpackedSchema.coverPicturePreview, unpackedSchema.image)\n  }\n  unpackedSchema.schemaFamily = COLLECTION_SCHEMA_FAMILY.V1\n\n  return unpackedSchema\n}\n\n\n//////////////////////////////////////////////////////\n// token in schema v1 decoding\n//////////////////////////////////////////////////////\nconst fillTokenFieldByKeyPrefix = <T extends UniqueTokenIntermediate>(token: T, properties: ProbablyDecodedProperty[], prefix: string, tokenField: keyof T) => {\n  const keysMatchingPrefix = [`${prefix}.i`, `${prefix}.u`, `${prefix}.c`, `${prefix}.h`]\n  if (properties.some(({key}) => keysMatchingPrefix.includes(key))) token[tokenField] = {} as any\n\n  const field = token[tokenField] as any as InfixOrUrlOrCidAndHash\n\n  const urlInfixProperty = properties.find(({key}) => key === keysMatchingPrefix[0])\n  if (urlInfixProperty) field.urlInfix = StringUtils.Utf8.hexStringToString(urlInfixProperty.valueHex)\n\n  const urlProperty = properties.find(({key}) => key === keysMatchingPrefix[1])\n  if (urlProperty) field.url = StringUtils.Utf8.hexStringToString(urlProperty.valueHex)\n\n  const ipfsCidProperty = properties.find(({key}) => key === keysMatchingPrefix[2])\n  if (ipfsCidProperty) field.ipfsCid = StringUtils.Utf8.hexStringToString(ipfsCidProperty.valueHex)\n\n  const hashProperty = properties.find(({key}) => key === keysMatchingPrefix[3])\n  if (hashProperty) field.hash = StringUtils.Utf8.hexStringToString(hashProperty.valueHex)\n}\n\n\nexport const unpackEncodedTokenFromProperties = <T extends UniqueTokenIntermediate>(properties: ProbablyDecodedProperty[], schema: UniqueCollectionSchemaIntermediate): T => {\n  const token: T = {} as T\n\n  const nameProperty = properties.find(({key}) => key === 'n')\n  if (nameProperty) {\n    const parsedName = decodeHexAndParseJSONOrReturnNull<LocalizedStringWithDefault>(nameProperty.valueHex)\n    if (parsedName) token.name = parsedName\n  }\n\n  const descriptionProperty = properties.find(({key}) => key === 'd')\n  if (descriptionProperty) {\n    const parsedDescription = decodeHexAndParseJSONOrReturnNull<LocalizedStringWithDefault>(descriptionProperty.valueHex)\n    if (parsedDescription) token.description = parsedDescription\n  }\n\n  fillTokenFieldByKeyPrefix(token, properties, 'i', 'image')\n  fillTokenFieldByKeyPrefix(token, properties, 'p', 'imagePreview')\n  fillTokenFieldByKeyPrefix(token, properties, 'v', 'video')\n  fillTokenFieldByKeyPrefix(token, properties, 'au', 'audio')\n  fillTokenFieldByKeyPrefix(token, properties, 'so', 'spatialObject')\n\n  const attributeProperties = properties.filter(({key}) => key.startsWith('a.'))\n  if (attributeProperties.length) {\n    const attrs = {} as EncodedTokenAttributes\n\n    for (const attrProp of attributeProperties) {\n      const {key, valueHex} = attrProp\n      const parsed = decodeHexAndParseJSONOrReturnNull<any>(valueHex)\n      const attributeKey = parseInt(key.split('.')[1] || '')\n\n      if (!isNaN(attributeKey) && schema.attributesSchema?.hasOwnProperty(attributeKey)) {\n        attrs[attributeKey] = parsed\n      }\n    }\n\n    token.encodedAttributes = attrs\n  }\n\n  return token\n}\n\n\nexport const decodeTokenFromProperties = (\n  propertiesArray: ProbablyDecodedProperty[],\n  schema: UniqueCollectionSchemaIntermediate,\n  options?: DecodeTokenOptions,\n): UniqueTokenIntermediate => {\n  const unpackedToken = unpackEncodedTokenFromProperties(propertiesArray, schema)\n\n  const token: UniqueTokenIntermediate = {\n    attributes: fullDecodeTokenAttributes(unpackedToken, schema),\n    image: decodeTokenUrlOrInfixOrCidWithHashField(unpackedToken.image, schema.image)\n  }\n\n  if (unpackedToken.name) token.name = unpackedToken.name\n  if (unpackedToken.description) token.description = unpackedToken.description\n\n  if (unpackedToken.imagePreview) {\n    token.imagePreview = decodeTokenUrlOrInfixOrCidWithHashField(unpackedToken.imagePreview, schema.imagePreview)\n  }\n  if (unpackedToken.video) {\n    token.video = decodeTokenUrlOrInfixOrCidWithHashField(unpackedToken.video, schema.video)\n  }\n  if (unpackedToken.audio) {\n    token.audio = decodeTokenUrlOrInfixOrCidWithHashField(unpackedToken.audio, schema.audio)\n  }\n  if (unpackedToken.spatialObject) {\n    token.spatialObject = decodeTokenUrlOrInfixOrCidWithHashField(unpackedToken.spatialObject, schema.spatialObject)\n  }\n  if (unpackedToken.file) {\n    token.file = decodeTokenUrlOrInfixOrCidWithHashField(unpackedToken.file, schema.file)\n  }\n\n  return token\n}\n\nexport const fullDecodeTokenAttributes = (token: UniqueTokenIntermediate, collectionSchema: UniqueCollectionSchemaIntermediate): DecodedAttributes => {\n  const attributes: DecodedAttributes = {}\n  if (!token.encodedAttributes) return {}\n\n  const entries = Object.entries(token.encodedAttributes)\n  for (const entry of entries) {\n    const [key, rawValue] = entry\n\n    const schema = collectionSchema.attributesSchema?.[key as any]\n    if (!schema) continue\n\n    let value: any = rawValue\n\n    if (schema.enumValues) {\n      if (schema.isArray && Array.isArray(rawValue)) {\n        value = rawValue\n          .map(v => typeof v === 'number' ? schema.enumValues?.[v] : null)\n          .filter(v => !!v)\n      } else {\n        if (typeof rawValue === 'number') {\n          value = schema.enumValues[rawValue]\n        }\n      }\n    }\n\n    attributes[key as any] = {\n      name: schema.name,\n      value: value as LocalizedStringOrBoxedNumberWithDefault | Array<LocalizedStringOrBoxedNumberWithDefault>,\n      isArray: schema.isArray || false,\n      type: schema.type,\n      rawValue,\n      isEnum: !!schema.enumValues,\n    }\n  }\n\n  return attributes\n}\n","import {\n  DecodingImageLinkOptions,\n  UniqueCollectionSchemaIntermediate,\n  UniqueTokenIntermediate,\n  ValidationError\n} from './intermediate_types'\n\nimport * as decoders_v0 from './v0_to_intermediate'\nimport * as decoders_v1 from './v1_to_intermediate'\nimport {COLLECTION_SCHEMA_FAMILY, DecodeTokenOptions, ProbablyDecodedProperty} from '../../types'\nimport {Address} from '@unique-nft/utils'\nimport {Royalties} from '@unique-nft/utils/royalties'\n\nconst DEFAULT_IMAGE_URL_TEMPLATE: string = `https://ipfs.unique.network/ipfs/{infix}`\nconst DEFAULT_DUMMY_IMAGE_FULL_URL = `https://ipfs.unique.network/ipfs/QmPCqY7Lmxerm8cLKmB18kT1RxkwnpasPVksA8XLhViVT7`\n\nexport const parseImageLinkOptions = (options?: DecodingImageLinkOptions): Required<DecodingImageLinkOptions> => {\n  let imageUrlTemplate: string = DEFAULT_IMAGE_URL_TEMPLATE\n  if (typeof options?.imageUrlTemplate === 'string') {\n    imageUrlTemplate = options!.imageUrlTemplate\n  }\n\n  const dummyImageFullUrl = typeof options?.dummyImageFullUrl === 'string'\n    ? options.dummyImageFullUrl\n    : DEFAULT_DUMMY_IMAGE_FULL_URL\n\n  return {\n    imageUrlTemplate,\n    dummyImageFullUrl,\n  }\n}\n\nexport const decodeV0OrV1CollectionSchemaToIntermediate = (\n  properties: ProbablyDecodedProperty[] | undefined | null,\n  schemaFamily: COLLECTION_SCHEMA_FAMILY,\n  options?: DecodingImageLinkOptions\n): UniqueCollectionSchemaIntermediate => {\n  if (!properties || !properties.length) {\n    throw new ValidationError(`Unable to parse: collection properties are empty`)\n  }\n\n  const result = (schemaFamily === COLLECTION_SCHEMA_FAMILY.V0)\n    ? decoders_v0.decodeOldSchemaCollection(properties, options)\n    : (schemaFamily === COLLECTION_SCHEMA_FAMILY.V1)\n      ? decoders_v1.decodeUniqueCollectionFromProperties(properties)\n      : null\n\n  if (!result) throw new ValidationError(`Unknown collection schema: \"${schemaFamily}\"`)\n\n  const royaltyEncoded = properties.find(p => p.key === 'royalties')?.valueHex\n  const royalties = royaltyEncoded ? Royalties.uniqueV2.decode(royaltyEncoded) : []\n  if (royalties.length) result.royalties = royalties\n\n  return result\n}\n\nexport const decodeV0OrV1TokenToIntermediate = (\n  propertyArray: ProbablyDecodedProperty[] | undefined | null,\n  schema: UniqueCollectionSchemaIntermediate,\n  options?: DecodeTokenOptions,\n  imageLinkOptions?: DecodingImageLinkOptions\n): UniqueTokenIntermediate => {\n  if (!schema) {\n    throw new ValidationError('unable to parse: collection schema was not provided')\n  }\n  if (!propertyArray || !propertyArray.length) {\n    throw new ValidationError(`unable to parse: token properties are empty`)\n  }\n\n  const decodedToken = schema.schemaFamily === COLLECTION_SCHEMA_FAMILY.V0\n    ? decoders_v0.decodeOldSchemaToken(propertyArray, schema, imageLinkOptions, options)\n    : schema.schemaFamily === COLLECTION_SCHEMA_FAMILY.V1\n      ? decoders_v1.decodeTokenFromProperties(propertyArray, schema, options)\n      : null\n\n  if (!decodedToken) {\n    throw new ValidationError(`Unknown token schema`)\n  }\n\n  const owner = options?.tokenOwner\n  if (owner && Address.is.nestingAddress(owner)) {\n    decodedToken.nestingParentToken = Address.nesting.addressToIds(owner)\n  }\n\n  return decodedToken\n}\n","import {COLLECTION_SCHEMA_FAMILY, DecodeCollectionOptions, ProbablyDecodedProperty} from '../types'\nimport {IV2Collection, IV2PotentialAttributeValues} from '../schema.zod'\nimport {buildDictionaryFromPropertiesArray, decodeHexAndParseJSONOrReturnNull} from '../utils'\nimport {detectCollectionSchemaFamily} from './tokenDecoding'\nimport {decodeV0OrV1CollectionSchemaToIntermediate} from '../tools/old_to_intermediate'\n\nexport const decodeCollectionToV2 = async (collectionProperties: ProbablyDecodedProperty[], options?: DecodeCollectionOptions): Promise<IV2Collection> => {\n  const properties = buildDictionaryFromPropertiesArray(collectionProperties)\n\n  const {schemaFamily} = detectCollectionSchemaFamily(properties, properties) //twice because there is no any token info now\n\n  const isUniqueV2 = schemaFamily === COLLECTION_SCHEMA_FAMILY.V2\n  const isUniqueV0 = schemaFamily === COLLECTION_SCHEMA_FAMILY.V0\n\n  if (isUniqueV2) {\n    const collectionInfo = decodeHexAndParseJSONOrReturnNull(properties.collectionInfo?.valueHex)\n    return {\n      ...collectionInfo,\n    } as IV2Collection\n  }\n\n  // const collectionId = typeof options.collectionId === 'string'\n  //   ? Address.collection.addressToId(options.collectionId)\n  //   : options.collectionId\n\n  const collectionSchema = decodeV0OrV1CollectionSchemaToIntermediate(\n    collectionProperties,\n    schemaFamily,\n  )\n\n  const collectionData: IV2Collection = {\n    schemaName: 'unique',\n    schemaVersion: !isUniqueV2 ? '2.0.0' : (collectionSchema.schemaVersion || '2.0.0'),\n    originalSchemaVersion: isUniqueV0 ? '0.0.1' : (collectionSchema.schemaVersion || '1.0.0'),\n\n    // name: options.collectionName as string, //todo: parse UTF16\n    // description: options.collectionDescription as string, //todo: parse UTF16\n    // symbol: options.collectionSymbol as string, //todo: parse UTF16\n    // tokenPrefix: options.collectionSymbol as string, //todo: parse UTF16\n  }\n  const {royalties} = collectionSchema\n  if (Array.isArray(royalties) && royalties.length) collectionData.royalties = royalties\n\n  if (collectionSchema.attributesSchema) {\n    collectionData.potential_attributes = Object.values(collectionSchema.attributesSchema)\n      .map(oldAttribute => {\n        const newAttribute: IV2PotentialAttributeValues[number] = {\n          trait_type: oldAttribute.name._,\n          display_type: oldAttribute.type,\n        }\n        if (oldAttribute.enumValues) {\n          newAttribute.values = Object.values(oldAttribute.enumValues).map(enumValue => enumValue._)\n        }\n        return newAttribute\n      })\n  }\n\n  if (collectionSchema.coverPicture.fullUrl) {\n    collectionData.cover_image = {\n      url: collectionSchema.coverPicture.fullUrl\n    }\n    if (options?.tryRequestForMediaDetails) {\n      //todo: request for media details for cover image\n    }\n  }\n\n  return collectionData\n}\n","import {TokenPropertyPermission} from './types'\n\nexport const PERMISSION = <const>{\n  REWRITEABLE_FOR_BOTH: {mutable: true, collectionAdmin: true, tokenOwner: true},\n  REWRITEABLE_FOR_COLLECTION_ADMIN: {mutable: true, collectionAdmin: true, tokenOwner: false},\n  REWRITEABLE_FOR_TOKEN_OWNER: {mutable: true, collectionAdmin: false, tokenOwner: true},\n\n  WRITABLE_ONCE_FOR_BOTH: {mutable: false, collectionAdmin: true, tokenOwner: true},\n  WRITABLE_ONCE_FOR_COLLECTION_ADMIN: {mutable: false, collectionAdmin: true, tokenOwner: false},\n  WRITABLE_ONCE_FOR_TOKEN_OWNER: {mutable: false, collectionAdmin: false, tokenOwner: true},\n} satisfies { [K: string]: TokenPropertyPermission}\n\nexport const DEFAULT_PERMISSION = PERMISSION.REWRITEABLE_FOR_COLLECTION_ADMIN\n\n/*\n\nenum AttributeType {\n  integer = 'integer',        // number\n  float = 'float',            // number\n  boolean = 'boolean',        // number\n  timestamp = 'timestamp',    // number // js, milliseconds from epoch\n  string = 'string',          // string\n  url = 'url',                // string\n  isoDate = 'isoDate',        // string // ISO Date: YYYY-MM-DD\n  time = 'time',              // string // 24h time: HH:mm:ss\n  colorRgba = 'colorRgba',    // string // 'rrggbbaa'\n  colorLch = 'colorLch',      // string // '52.2345% 72.2 56.2 / .5'\n}\n\nexport type TokenMediaType = 'image' | 'video' | 'audio' | '3d' | 'file' | 'link'\nexport type SubType =\n  'youtube'\n  | 'vimeo'\n  | 'soundcloud'\n  | 'spotify'\n  | 'deezer'\n  | 'tiktok'\n  | 'instagram'\n  | 'twitter'\n  | 'facebook'\n  | 'twitch'\n  | 'dailymotion'\n  | 'mixcloud'\n  | 'figma'\n*/\n\nexport const SCHEMA_NAME = 'unique'\nexport const SCHEMA_VERSION = '2.0.0'\nexport const DEFAULT_COLLECTION_FLAGS_VALUE = 64\n","import 'zod-openapi/extend'\nimport {z} from 'zod'\nimport {SCHEMA_NAME, SCHEMA_VERSION} from './constants'\n\nexport const zCollectionIdOrAddress = z.union([\n  z.number().min(1).max((2 ** 32) - 1),\n  z.string().regex(/^0x[a-fA-F0-9]{40}$/)\n])\nexport type ICollectionIdOrAddress = z.infer<typeof zCollectionIdOrAddress>\n\nexport const zSemverString = z.string().regex(/^\\d+\\.\\d+\\.\\d+$/)\nexport type ISemverString = z.infer<typeof zSemverString>\n\nexport const zMediaType = z.enum([\n  'image',\n  'animation',\n  'video',\n  'audio',\n  'spatial',\n  'pdf',\n  'document',\n  'other',\n])\nexport type IV2MediaType = z.infer<typeof zMediaType>\n\nexport const zSemverString2xx = zSemverString.refine((version?: string) => {\n    if (typeof version === 'string') {\n      const [major, minor, patch] = version.split('.').map(Number)\n      if (major !== 2) return false\n      if (minor < 0) return false\n      if (patch < 0) return false\n    }\n    return true\n  },\n  'version must be in semver format: 2.x.x'\n)\nexport type IV2SemverString2xx = z.infer<typeof zSemverString2xx>\n\nexport const zImageDetails = z.object({\n  name: z.string().optional(),\n  type: zMediaType.optional(),\n  bytes: z.number().optional(),\n  format: z.string().optional(),\n  sha256: z.string().optional(),\n  width: z.number().optional(),\n  height: z.number().optional(),\n  order: z.number().optional(),\n})\nexport type IV2ImageDetails = z.infer<typeof zImageDetails>\n\nexport const zImageWithDetails = z.object({\n  url: z.string(),\n  details: zImageDetails.optional(),\n})\nexport type IV2ImageWithDetails = z.infer<typeof zImageWithDetails>\n\nexport const zImageWithDetailsAndThumbnail = zImageWithDetails.extend({\n  thumbnail: zImageWithDetails.optional(),\n})\nexport type IV2ImageWithDetailsAndThumbnail = z.infer<typeof zImageWithDetailsAndThumbnail>\n\nexport const zMediaDetails = zImageDetails.extend({\n  duration: z.number().optional(),\n  codecs: z.array(z.string()).optional(),\n  loop: z.boolean().optional(),\n})\nexport type IV2MediaDetails = z.infer<typeof zMediaDetails>\n\nexport const zMedia = z.object({\n  type: zMediaType,\n  url: z.string(),\n  name: z.string().optional(),\n  details: zMediaDetails.optional(),\n  thumbnail: zImageWithDetails.optional(),\n  poster: zImageWithDetails.optional(),\n})\nexport type IV2Media = z.infer<typeof zMedia>\n\nexport const zAttribute = z.object({\n  trait_type: z.string(),\n  value: z.union([z.string(), z.number()]),\n  display_type: z.string().optional(),\n})\nexport type IV2Attribute = z.infer<typeof zAttribute>\n\nexport const zRoyalty = z.object({\n  address: z.string(),\n  percent: z.number().min(0).max(100),\n  isPrimaryOnly: z.boolean().optional(),\n})\nexport type IV2Royalty = z.infer<typeof zRoyalty>\n\n///// customizing\n\nexport const zCustomizingImageOverlaySpecs = z.object({\n  layer: z.number(),\n  order_in_layer: z.number(),\n  offset: z.object({x: z.number(), y: z.number()}).partial(),\n  opacity: z.number(),\n  rotation: z.number(),\n  scale: z.object({\n    x: z.number().optional(),\n    y: z.number().optional(),\n    unit: z.enum(['px', '%']).default('%').optional(),\n  }),\n  anchor_point: z.object({x: z.number(), y: z.number()}),\n  parent_anchor_point: z.object({x: z.number(), y: z.number()}),\n}).partial()\nexport type IV2CustomizingImageOverlaySpecs = z.infer<typeof zCustomizingImageOverlaySpecs>\n\nexport const zCustomizingMutatorReaction = zCustomizingImageOverlaySpecs.extend({\n  url: z.string(),\n  details: zImageDetails,\n}).partial()\nexport type IV2CustomizingMutatorReaction = z.infer<typeof zCustomizingMutatorReaction>\n\nexport const zCustomizingFileInfo = z.object({\n  type: zMediaType,\n  url: z.string(),\n\n  name: z.string().optional(),\n  details: zMediaDetails.optional(),\n  image_overlay_specs: zCustomizingImageOverlaySpecs.optional(),\n  placeholder: zImageWithDetails.optional(),\n})\nexport type IV2CustomizingFileInfo = z.infer<typeof zCustomizingFileInfo>\n\nexport const zCustomizingSlot = z.object({\n  type: zMediaType,\n  collections: zCollectionIdOrAddress.array().optional(),\n  name: z.string().optional(),\n  image_overlay_specs: zCustomizingImageOverlaySpecs.optional(),\n})\nexport type IV2CustomizingSlot = z.infer<typeof zCustomizingSlot>\n\nexport const zCustomizing = z.object({\n  self: zCustomizingFileInfo.extend({tag: z.string(),}),\n  slots: z.record(zCustomizingSlot).optional(),\n  mutator_reactions: z.record(zCustomizingMutatorReaction).optional(),\n  mutators: z.array(z.string()).optional(),\n})\nexport type IV2Customizing = z.infer<typeof zCustomizing>\n\nexport const zCustomizingOverrides = z.object({\n  self: zCustomizingFileInfo.extend({tag: z.string(),}).partial().optional(),\n  slots: z.record(zCustomizingSlot.partial()).optional(),\n  mutator_reactions: z.record(zCustomizingMutatorReaction.partial()).optional(),\n  mutators: z.array(z.string()).optional(),\n})\nexport type IV2CustomizingOverrides = z.infer<typeof zCustomizingOverrides>\n\nexport const zTokenSchema = z.object({\n  // base stuff\n  schemaName: z.string().optional().default(SCHEMA_NAME),\n  schemaVersion: zSemverString2xx.optional().default(SCHEMA_VERSION),\n  originalSchemaVersion: zSemverString.optional(),\n\n  name: z.string().optional(),\n  description: z.string().optional(),\n  image: z.string().optional(),\n  image_details: zImageDetails.optional(),\n  attributes: z.array(zAttribute).optional(),\n\n  // Unique-specific stuff\n  media: z.record(zMedia).optional(),\n  royalties: z.array(zRoyalty).optional(),\n  customizing: zCustomizing.optional(),\n  customizing_overrides: zCustomizingOverrides.optional(),\n\n  // OpenSea-compatibility stuff\n  animation_url: z.string().optional(),\n  animation_details: zImageDetails.optional(),\n  youtube_url: z.string().optional(),\n  created_by: z.string().optional(),\n  background_color: z.string().optional(),\n  external_url: z.string().optional(),\n  locale: z.string().optional(),\n})\nexport type IV2Token = z.infer<typeof zTokenSchema>\nexport type IV2TokenForEncoding = z.input<typeof zTokenSchema>\n\nconst zPotentialAttributeValues = z.array(z.object({\n  trait_type: z.string(),\n  display_type: z.string().optional(),\n  values: z.array(z.union([z.string(), z.number()])).optional(),\n}))\nexport type IV2PotentialAttributeValues = z.infer<typeof zPotentialAttributeValues>\n\nexport const zCollectionSchema = z.object({\n  schemaName: z.string()\n    .optional()\n    .refine((v) => v === SCHEMA_NAME, {message: `schemaName must be \"${SCHEMA_NAME}\"`})\n    .default(SCHEMA_NAME),\n  schemaVersion: zSemverString2xx.optional().default(SCHEMA_VERSION),\n  originalSchemaVersion: zSemverString.optional(),\n\n  cover_image: zImageWithDetailsAndThumbnail.optional(),\n  default_token_image: zImageWithDetailsAndThumbnail.optional(),\n\n  potential_attributes: zPotentialAttributeValues.optional(),\n\n  customizing: z.object({\n    slots: z.record(zCustomizingSlot).optional(),\n    customizes: zCollectionIdOrAddress.array().optional(),\n  }).optional(),\n\n  royalties: z.array(zRoyalty).optional(),\n})\nexport type IV2Collection = z.infer<typeof zCollectionSchema>\nexport type IV2CollectionForEncoding = z.input<typeof zCollectionSchema>\n","import {\n  CollectionTokenPropertyPermissions,\n  EncodeCollectionOptions,\n  EncodeCollectionResult,\n  EncodeTokenOptions,\n  PropertyForEncoding,\n  PropertyWithHex,\n} from './types'\nimport {DEFAULT_COLLECTION_FLAGS_VALUE, DEFAULT_PERMISSION, SCHEMA_NAME, SCHEMA_VERSION} from './constants'\nimport {\n  IV2Collection,\n  IV2CollectionForEncoding,\n  IV2Token,\n  IV2TokenForEncoding,\n  zCollectionSchema,\n  zTokenSchema\n} from './schema.zod'\nimport {Royalties} from '@unique-nft/utils/royalties'\nimport {zipTwoArraysByKey, hexifyProperties} from './utils'\n\nexport const encodeCollection = (data: IV2CollectionForEncoding, options?: EncodeCollectionOptions): EncodeCollectionResult => {\n  const collectionInfo = zCollectionSchema.parse(data)\n\n  const permission = options?.defaultPermission ?? {...DEFAULT_PERMISSION}\n\n  const properties: PropertyForEncoding[] = [\n    {key: 'schemaName', value: collectionInfo.schemaName || SCHEMA_NAME},\n    {key: 'schemaVersion', value: collectionInfo.schemaVersion || SCHEMA_VERSION},\n    {key: 'collectionInfo', value: JSON.stringify(collectionInfo)},\n  ]\n  if (collectionInfo.royalties) {\n    // properties.push({key: 'royalties', value: Royalties.uniqueV2.encode(collectionInfo.royalties)})\n    throw new Error('Royalties are not supported in collections in v2, please use the token level royalties')\n  }\n\n  const TPPs: CollectionTokenPropertyPermissions = [\n    'schemaName', 'schemaVersion',\n    'tokenData', 'URI', 'URISuffix',\n    'overrides', 'customizing_overrides', 'royalties'\n  ].map(key => ({key, permission}))\n\n  return {\n    collectionProperties: hexifyProperties(zipTwoArraysByKey(properties, options?.overwriteProperties ?? [])),\n    tokenPropertyPermissions: zipTwoArraysByKey(TPPs, options?.overwriteTPPs ?? []),\n    flags: DEFAULT_COLLECTION_FLAGS_VALUE,\n  }\n}\n\nexport const encodeToken = (data: IV2TokenForEncoding, options?: EncodeTokenOptions): {\n  tokenProperties: PropertyWithHex[]\n} => {\n  const token = zTokenSchema.parse(data)\n\n  const properties: PropertyForEncoding[] = [\n    {key: 'schemaName', value: token.schemaName || SCHEMA_NAME},\n    {key: 'schemaVersion', value: token.schemaVersion || SCHEMA_VERSION},\n    {key: 'tokenData', value: JSON.stringify(token)},\n  ]\n\n  token.royalties && properties.push({key: 'royalties', valueHex: Royalties.uniqueV2.encode(token.royalties)})\n\n  options?.URI && properties.push({key: 'URI', value: options.URI})\n\n  return {\n    tokenProperties: hexifyProperties(zipTwoArraysByKey(properties, options?.overwriteProperties ?? []))\n  }\n}\n"],"mappings":"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","names":["COLLECTION_SCHEMA_FAMILY","import_royalties","import_utils","protobufjs","import_utils","key","import_utils","import_royalties"]}