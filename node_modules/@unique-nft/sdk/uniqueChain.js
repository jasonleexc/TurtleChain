// src/_base.ts
import Axios2 from "axios";
import { z as z3 } from "zod";
import qs from "qs";

// src/errors.ts
import { z } from "zod";
import Axios from "axios";
var ApiError = class extends Error {
  isApiError = true;
  data;
  zodError;
  constructor(axiosError) {
    if (!Axios.isAxiosError(axiosError) || !axiosError.response) {
      const isEconnRefused = axiosError?.code === "ECONNREFUSED" || axiosError?.message.includes("ECONNREFUSED");
      if (isEconnRefused) {
        throw new Error("Connection to the server refused, please check the server URL");
      }
      throw new Error(axiosError.message);
    }
    const resp = axiosError.response;
    const message = `Server responded with Error ${resp.status} - ${resp.statusText}: ` + (typeof resp.data === "string" ? resp.data : JSON.stringify(resp.data));
    super(message);
    this.data = resp.data;
    this.zodError = resp.data.zodError ? new z.ZodError(resp.data.zodError.issues) : null;
  }
  static isApiError(err) {
    return err.apiErrorFlag;
  }
};

// src/types.ts
import { z as z2 } from "zod";
import { Address } from "@unique-nft/utils/address";
z2.ZodType.prototype.openapi = function() {
  return this;
};
var zUniqueBuildExtrinsicOptions = z2.object({
  signerAddress: z2.string().refine((address) => Address.is.substrateAddress(address)),
  nonce: z2.number().optional(),
  mortalLength: z2.number().optional()
});

// src/_base.ts
z3.ZodType.prototype.openapi = function() {
  return this;
};
var DEFAULT_TIMES_TO_RETRY = 15;
var DEFAULT_TIMEOUT = 3e3;
var getStatusOptions = (instanceStatusOptions, requestStatusOptions) => {
  const timeout = requestStatusOptions?.timeout || instanceStatusOptions?.timeout;
  const retries = requestStatusOptions?.retries || instanceStatusOptions?.retries;
  const TIMEOUT = timeout || DEFAULT_TIMEOUT;
  const TIMES_TO_RETRY = retries || DEFAULT_TIMES_TO_RETRY;
  const IS_FINALIZED = requestStatusOptions?.isFinalized || instanceStatusOptions?.isFinalized;
  return { TIMEOUT, TIMES_TO_RETRY, IS_FINALIZED };
};
var serializeObjectWithBigInt = (obj) => {
  return JSON.parse(
    JSON.stringify(obj, (key, value) => {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    })
  );
};
var getBuildExtrinsic = (client, chainParams) => async (endpointPart, paramsValidator, _params, _buildOptions) => {
  let buildOptions = {};
  if (_buildOptions) {
    const buildOptionsResult = zUniqueBuildExtrinsicOptions.safeParse(_buildOptions);
    if (!buildOptionsResult.success) {
      throw buildOptionsResult.error.format();
    }
    buildOptions = buildOptionsResult.data;
  }
  buildOptions.signerAddress = buildOptions?.signerAddress || chainParams.account?.address || "";
  if (!buildOptions.signerAddress) {
    throw new Error("No signer address provided");
  }
  const paramsParseResult = await paramsValidator.safeParseAsync(_params);
  if (!paramsParseResult.success) {
    throw paramsParseResult.error.format();
  }
  const params = paramsParseResult.data;
  try {
    const { data: builtExtrinsic } = await client.post(endpointPart + "/build", {
      args: serializeObjectWithBigInt(params),
      options: buildOptions
    });
    return builtExtrinsic;
  } catch (e) {
    throw new ApiError(e);
  }
};
var getEncodeExtrinsic = (client) => async (endpointPart, paramsValidator, _params) => {
  const paramsParseResult = await paramsValidator.safeParseAsync(_params);
  if (!paramsParseResult.success) {
    throw paramsParseResult.error.format();
  }
  const params = paramsParseResult.data;
  try {
    const { data: encodeExtrinsic } = await client.post(endpointPart + "/encode", {
      args: serializeObjectWithBigInt(params)
    });
    return encodeExtrinsic;
  } catch (e) {
    throw new ApiError(e);
  }
};
var getExtrinsicFee = (client, chainParams) => async (endpointPart, paramsValidator, _params, _buildOptions) => {
  let buildOptions = {};
  if (_buildOptions) {
    const buildOptionsResult = zUniqueBuildExtrinsicOptions.safeParse(_buildOptions);
    if (!buildOptionsResult.success) {
      throw buildOptionsResult.error.format();
    }
    buildOptions = buildOptionsResult.data;
  }
  buildOptions.signerAddress = buildOptions?.signerAddress || chainParams.account?.address || "";
  if (!buildOptions.signerAddress) {
    throw new Error("No signer address provided");
  }
  const paramsParseResult = await paramsValidator.safeParseAsync(_params);
  if (!paramsParseResult.success) {
    throw paramsParseResult.error.format();
  }
  const params = paramsParseResult.data;
  try {
    const { data: extrinsicFees } = await client.post(endpointPart + "/fee", {
      args: serializeObjectWithBigInt(params),
      options: buildOptions
    });
    return extrinsicFees;
  } catch (e) {
    throw new ApiError(e);
  }
};
var getSignExtrinsic = (client, chainParams) => async (payload, account) => {
  const signer = account?.signer || chainParams.account?.signer;
  if (!signer)
    throw new Error("No signer provided");
  return (await signer.sign(payload)).signature;
};
var getSubmitExtrinsic = (client) => async (extrinsicOrPayload, signature) => {
  try {
    const { data: sentExtrinsic } = await client.post("/extrinsics/submit", {
      signerPayloadJSON: "signerPayloadJSON" in extrinsicOrPayload ? extrinsicOrPayload.signerPayloadJSON : extrinsicOrPayload,
      signature
    });
    return sentExtrinsic.hash;
  } catch (e) {
    throw new ApiError(e);
  }
};
var getExtrinsicStatusCheck = (client, chainParams) => async (endpointPart, extrinsicHash, options) => {
  let extrinsicStatusResponse;
  const { TIMEOUT, TIMES_TO_RETRY, IS_FINALIZED } = getStatusOptions(chainParams.statusOptions, options);
  const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  let counter = 0;
  do {
    try {
      let url = endpointPart + "/status/" + extrinsicHash;
      if (IS_FINALIZED)
        url += "?isFinalized=true";
      extrinsicStatusResponse = await client.get(url);
    } catch (_err) {
      if (!Axios2.isAxiosError(_err)) {
        throw _err;
      }
      const err = _err;
      if (err.response?.status === 404) {
        counter += 1;
        if (counter > TIMES_TO_RETRY) {
          throw new Error(`Extrinsic not found in ${(TIMES_TO_RETRY * TIMEOUT / 1e3).toFixed(2)}s`);
        }
        await sleep(TIMEOUT);
      } else {
        throw new ApiError(_err);
      }
    }
  } while (!extrinsicStatusResponse || extrinsicStatusResponse.status !== 200);
  const { data: extrinsicResult } = extrinsicStatusResponse;
  return {
    result: extrinsicResult.result,
    extrinsicOutput: extrinsicResult.extrinsic
  };
};
var getExtrinsicOperations = (client, chainParams) => {
  const buildExtrinsic = getBuildExtrinsic(client, chainParams);
  const encodeExtrinsic = getEncodeExtrinsic(client);
  const extrinsicFee = getExtrinsicFee(client, chainParams);
  const signExtrinsic = getSignExtrinsic(client, chainParams);
  const submitExtrinsic = getSubmitExtrinsic(client);
  const getExtrinsicStatus2 = getExtrinsicStatusCheck(client, chainParams);
  const buildAndSubmitExtrinsic = async (endpointPart, paramsValidator, params, buildOptions, account, getStatusOptions2) => {
    const builtExtrinsic = await buildExtrinsic(endpointPart, paramsValidator, params, buildOptions);
    const signature = await signExtrinsic(builtExtrinsic, account);
    const extrinsicHash = await submitExtrinsic(builtExtrinsic, signature);
    return getExtrinsicStatus2(endpointPart, extrinsicHash, getStatusOptions2);
  };
  const extrinsic = {
    build: buildExtrinsic,
    encode: encodeExtrinsic,
    fee: extrinsicFee,
    sign: signExtrinsic,
    submit: submitExtrinsic,
    getStatus: getExtrinsicStatus2,
    invoke: buildAndSubmitExtrinsic
  };
  const makeExtrinsicFn = (extrinsicSettings) => {
    const { route, schemaIn, schemaOut } = extrinsicSettings;
    const fn = async (...args) => {
      const [params, buildOptions, account, options] = args;
      return buildAndSubmitExtrinsic(route, schemaIn, params, buildOptions, account, options);
    };
    fn.buildAndSubmit = async (...args) => {
      const [params, buildOptions, account, options] = args;
      return buildAndSubmitExtrinsic(route, schemaIn, params, buildOptions, account, options);
    };
    fn.route = route;
    fn.schemaIn = schemaIn;
    fn.schemaOut = schemaOut;
    fn.build = async (...args) => {
      const [params, buildOptions] = args;
      return buildExtrinsic(route, schemaIn, params, buildOptions);
    };
    fn.encode = async (...args) => {
      const [params] = args;
      return encodeExtrinsic(route, schemaIn, params);
    };
    fn.fee = async (...args) => {
      const [params, buildOptions] = args;
      return extrinsicFee(route, schemaIn, params, buildOptions);
    };
    fn.getStatus = getExtrinsicStatus2;
    fn.sign = signExtrinsic;
    fn.submit = submitExtrinsic;
    return fn;
  };
  return { extrinsic, makeExtrinsicFn };
};
var getQueryFn = (client) => (settings) => {
  const { route, schemaIn, schemaOut, method = "GET" } = settings;
  const fn = async (params) => {
    const paramsParseResult = schemaIn.safeParse(params);
    if (!paramsParseResult.success)
      throw paramsParseResult.error.format();
    const parsedParams = paramsParseResult.data;
    try {
      const response = method === "GET" ? await client.get(route, { params: parsedParams }) : await client.post(route, serializeObjectWithBigInt(parsedParams));
      return response.data;
    } catch (e) {
      throw new ApiError(e);
    }
  };
  fn.route = route;
  fn.schemaIn = schemaIn;
  fn.schemaOut = schemaOut;
  return fn;
};
var createAxiosClient = (chainParams) => Axios2.create({
  ...chainParams.axiosConfig,
  baseURL: chainParams.baseUrl,
  paramsSerializer: (params) => qs.stringify(params, { arrayFormat: "repeat" })
});
var prepareBase = (options) => {
  const client = createAxiosClient(options);
  const makeQueryFn = getQueryFn(client);
  const { extrinsic, makeExtrinsicFn } = getExtrinsicOperations(client, options);
  return { client, makeQueryFn, extrinsic, makeExtrinsicFn };
};
var zAlternativeBatchArgs = z3.array(
  z3.promise(
    z3.object({
      compactExtrinsic: z3.string()
    })
  )
).transform(async (promises) => {
  const calls = await Promise.all(promises.map((call) => call.then((c) => c.compactExtrinsic)));
  return { calls };
});

// ../substrate-http-proxy/src/routes/balances.ts
import { z as z8 } from "zod";

// ../validation-schemas/extrinsics.ts
import { z as z5 } from "zod";

// ../validation-schemas/shared.ts
import { z as z4 } from "zod";
import { Address as Address2 } from "@unique-nft/utils/address";
var zSubstrateAddress = z4.string().refine((address) => Address2.is.substrateAddress(address)).openapi({
  description: "Substrate address",
  example: "5DvpvbetLdgBfbb4S5sZ1CCGDWeLDhLmX5WXHd73LjsB2E2v"
});
var zEthereumAddress = z4.string().refine((address) => Address2.is.ethereumAddress(address)).openapi({
  description: "Ethereum address",
  example: "0x52764bbc320189511E826A0a9b4763F104FfC3B0"
});
var zAddressString = z4.string().refine((address) => {
  return Address2.is.validAddressInAnyForm(address);
}).openapi({
  description: "Any Address: Ethereum address or Substrate address or Substrate public key",
  example: "5DvpvbetLdgBfbb4S5sZ1CCGDWeLDhLmX5WXHd73LjsB2E2v",
  minLength: 42,
  maxLength: 66
});
var zWeiString = z4.string().openapi({
  description: "The amount in wei",
  example: "1500000000000000000"
});
var zCoinsString = z4.string().openapi({
  description: "The amount in coins",
  example: "1.5"
});
var zExtrinsicEraEncoded = z4.string().openapi({
  description: "The era for this transaction, in hex",
  example: "0x9503"
});
var zExtrinsicMethodEncoded = z4.string().openapi({
  description: "The method for this transaction, in hex",
  example: "0x1e03008ea22863f6d84b1f76e4377c1ba1f6c8bd75b0d3bb5d11c36c0436bdd3110867e5c0"
});
var zSignerPayloadJSON = z4.object({
  address: zSubstrateAddress.openapi({
    description: "The address of the signer",
    example: "5DvpvbetLdgBfbb4S5sZ1CCGDWeLDhLmX5WXHd73LjsB2E2v"
  }),
  blockNumber: z4.string().openapi({
    description: "The block number of the chain",
    example: "0x000c9c52"
  }),
  era: zExtrinsicEraEncoded,
  method: zExtrinsicMethodEncoded,
  nonce: z4.string().openapi({
    description: "The nonce for this transaction, in hex",
    example: "0x00000000"
  }),
  version: z4.number(),
  blockHash: z4.string().openapi({
    description: "The block hash of the chain",
    example: "0xabb0ec38ebeaeae36dbad82cfb33a8e16b7d18a5f937543d5d80d845ef450329"
  }),
  genesisHash: z4.string().openapi({
    description: "The genesis hash of the chain",
    example: "0x49cc5821aa055c3ee9357fe109219230e9ee98792c2e26a0f416233f80a2b5d7"
  }),
  specVersion: z4.string().openapi({
    description: "The current spec version for the runtime",
    example: "0x00990bf6"
  }),
  tip: z4.string().openapi({
    description: "The tip for this transaction, in hex",
    example: "0x00000000000000000000000000000000"
  }),
  transactionVersion: z4.string().openapi({
    description: "The current transaction version for the runtime",
    example: "0x00000003"
  }),
  signedExtensions: z4.array(z4.string()).openapi({
    description: "The applicable signed extensions for this runtime",
    example: ["CheckSpecVersion", "CheckTxVersion", "CheckGenesis"]
  })
});
var zSignerPayloadRaw = z4.object({
  address: zSubstrateAddress.openapi({
    description: "The address of the signer"
  }),
  data: z4.string().openapi({
    description: "The raw data of the signer payload, in hex"
  }),
  type: z4.string()
});
var zSignerPayloadHex = z4.string().openapi({
  description: "The signer payload, in hex"
});
var zUniqueBuildExtrinsicOptions2 = z4.object({
  signerAddress: zSubstrateAddress,
  nonce: z4.number().optional(),
  mortalLength: z4.number().optional()
});

// ../validation-schemas/extrinsics.ts
var zQueryBoolean = z5.union([z5.string(), z5.boolean(), z5.number()]).transform((val) => {
  if (typeof val === "string")
    return val.toLowerCase() === "true";
  if (typeof val === "boolean")
    return val;
  return val !== 0;
}).openapi({ description: "Boolean query parameter", type: "boolean" });
var zArgsArray = z5.array(z5.any()).openapi({
  description: "The arguments to pass to the method",
  example: ["5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL", 777]
});
var zArgsObject = z5.object({}).catchall(z5.any()).openapi({
  description: "The arguments to pass to the method",
  example: {
    to: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL",
    value: 777
  }
});
var zBuildExtrinsic = z5.object({
  signerAddress: zSubstrateAddress,
  section: z5.string().openapi({
    description: "The section of the method to call",
    example: "balances"
  }),
  method: z5.string().openapi({
    description: "The method to call",
    example: "transferKeepAlive"
  }),
  args: z5.union([zArgsArray, zArgsObject]),
  mortalLength: z5.number().optional(),
  nonce: z5.number().optional()
});
var zEncodeExtrinsic = zBuildExtrinsic.omit({
  signerAddress: true,
  mortalLength: true,
  nonce: true
});
var zCompactExtrinsic = z5.object({
  compactExtrinsic: z5.string().openapi({
    description: "The encoded compact extrinsic, same as call, but with version and length",
    example: "0x1e03008ea22863f6d84b1f76e4377c1ba1f6c8bd75b0d3bb5d11c36c0436bdd3110867e5c0"
  })
});
var zSignerPayload = z5.object({
  signerPayloadJSON: zSignerPayloadJSON,
  signerPayloadRaw: zSignerPayloadRaw,
  signerPayloadHex: zSignerPayloadHex
});
var zSignerPayloadWithCompactExtrinsic = zSignerPayload.extend({
  compactExtrinsic: z5.string().openapi({
    description: "The encoded compact extrinsic, same as call, but with version and length",
    example: "0x1e03008ea22863f6d84b1f76e4377c1ba1f6c8bd75b0d3bb5d11c36c0436bdd3110867e5c0"
  })
});
var zSubmitExtrinsic = z5.object({
  signerPayloadJSON: zSignerPayloadJSON,
  signature: z5.string()
});
var zSubmittedExtrinsic = z5.object({
  hash: z5.string()
});
var zExtrinsicStatus = z5.object({
  hash: z5.string(),
  signer: zSubstrateAddress,
  section: z5.string(),
  method: z5.string(),
  args: z5.object({}).catchall(z5.any()),
  events: z5.array(
    z5.object({
      section: z5.string(),
      method: z5.string(),
      data: z5.object({}).catchall(z5.any())
    })
  ),
  groupedEvents: z5.object({}).catchall(z5.object({}).catchall(z5.array(z5.object({}).catchall(z5.any())))),
  blockHash: z5.string(),
  blockNumber: z5.coerce.string()
}).openapi({
  description: "The status of the extrinsic",
  example: {
    hash: "0xe888db18399714543558de271b1e67c68caad3f2778a9cb45cf03cd72a62735c",
    blockHash: "0xef7d8c3d68fb2f4e551b6d4dac534bf80f78b9137729e4442cc9d72d9798469e",
    blockNumber: "1111969",
    signer: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY",
    section: "balances",
    method: "transferKeepAlive",
    args: {
      to: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY",
      amount: "1500000000000000000"
    },
    events: [
      {
        section: "balances",
        method: "Withdraw",
        data: {
          who: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY",
          amount: "59280745607318347"
        }
      },
      "..."
    ],
    groupedEvents: {
      balances: {
        Withdraw: [
          {
            who: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY",
            amount: "59280745607318347"
          },
          "..."
        ]
      }
    }
  }
});
var getExtrinsicStatus = {
  input: z5.object({
    hash: z5.string(),
    isFinalized: zQueryBoolean.optional()
  }),
  output: {
    ok: zExtrinsicStatus,
    notFound: z5.object({
      error: z5.string()
    })
  }
};
var zExtrinsicFee = zBuildExtrinsic;
var zExtrinsicFeeOutput = z5.object({
  baseFee: z5.coerce.string(),
  lenFee: z5.coerce.string(),
  adjustedWeightFee: z5.coerce.string(),
  totalFee: z5.coerce.string(),
  xcmFee: z5.coerce.string()
});
var zErrors = {
  notFound: z5.object({ error: z5.string() }),
  generic: z5.object({
    error: z5.string(),
    details: z5.any().optional(),
    httpPart: z5.string().optional()
  })
};
var zExtrinsicApi = {
  buildInput: zBuildExtrinsic,
  buildOutput: zSignerPayloadWithCompactExtrinsic,
  encodeInput: zEncodeExtrinsic,
  encodeOutput: zCompactExtrinsic,
  extrinsicFeeInput: zExtrinsicFee,
  extrinsicFeeOutput: zExtrinsicFeeOutput,
  submitInput: zSubmitExtrinsic,
  submitOutput: z5.object({ hash: z5.string() }),
  getStatusInput: z5.object({ hash: z5.string() }),
  // todo - duplicate with getExtrinsicStatus.input
  getStatusOutput: zExtrinsicStatus
};
var zExtrinsicHash = z5.string().trim().toLowerCase().regex(/^0x[0-9a-f]{64}$/).openapi({
  description: "The hash of the extrinsic",
  example: "0x96affcbd6740d3d94b90996aee65b8a3075512c0e8bbedb92e79df0f5d2cad5f"
});

// ../validation-schemas/xcmUtils.ts
var MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);

// ../substrate-http-proxy/src/routes/_types.ts
var ExtrinsicEndpointsConfig = class {
  route;
  tags;
  description;
  extrinsicSection;
  extrinsicMethod;
  schemaIn;
  encodeSchemaIn;
  buildArgsFormatter;
  encodeArgsFormatter;
  schemaOut;
  resultFormatter;
  routeType = "unknown";
  constructor(config) {
    this.route = config.route;
    this.tags = config.tags;
    this.description = config.description;
    this.extrinsicSection = config.extrinsicSection;
    this.extrinsicMethod = config.extrinsicMethod;
    this.schemaIn = config.schemaIn;
    this.buildArgsFormatter = config.buildArgsFormatter;
    this.encodeSchemaIn = config.encodeSchemaIn ?? config.schemaIn;
    this.encodeArgsFormatter = config.encodeArgsFormatter ?? async function(args, client) {
      return config.buildArgsFormatter(args, { signerAddress: "" }, client);
    };
    this.schemaOut = config.schemaOut;
    this.resultFormatter = config.resultFormatter;
    this.routeType = config.routeType || this.routeType;
  }
};
var QueryEndpointConfig = class {
  route;
  method;
  tags;
  description;
  schemaIn;
  schemaOut;
  queryHandler;
  constructor(config) {
    this.route = config.route;
    this.tags = config.tags;
    this.description = config.description;
    this.schemaIn = config.schemaIn;
    this.schemaOut = config.schemaOut;
    this.queryHandler = config.queryHandler;
    this.method = config.method || "GET";
  }
};

// ../substrate-http-proxy/src/schemas/events.ts
import { z as z6 } from "zod";
import { Address as Address3 } from "@unique-nft/utils/address";

// ../../node_modules/coin-format/index.mjs
var DEFAULT_DECIMALS = 18;
var validateDecimals = (decimals) => {
  if (typeof decimals !== "number")
    throw new Error("Invalid decimals, must be a number");
  if (decimals < 1 || decimals > 18)
    throw new Error("Invalid decimals, must be between 0 and 18");
  return true;
};
var weiToCoin = (weiValue, decimals = DEFAULT_DECIMALS) => {
  validateDecimals(decimals);
  const weiBigInt = BigInt(weiValue);
  const divisor = 10n ** BigInt(decimals);
  const ethAmountBigInt = weiBigInt / divisor;
  const remainder = weiBigInt % divisor;
  const remainderStr = remainder.toString().padStart(decimals, "0");
  const formattedRemainder = remainderStr.replace(/0+$/, "");
  const formattedEthAmount = `${ethAmountBigInt}${formattedRemainder.length > 0 ? "." + formattedRemainder : ""}`;
  return formattedEthAmount;
};

// ../substrate-http-proxy/src/schemas/errors.ts
var ApiError2 = class extends Error {
  constructor(message, statusCode = 500, details) {
    super(message);
    this.statusCode = statusCode;
    this.details = details;
  }
};
var NotFoundError = class extends ApiError2 {
  statusCode = 404;
  constructor(message) {
    super(message);
  }
};
var EventNotFoundInExtrinsicError = class extends Error {
  statusCode = 503;
  constructor(extrinsic, event) {
    super(`The extrinsic (hash ${extrinsic.hash}, block ${extrinsic.blockNumber} / ${extrinsic.blockHash}) has no ${event} event`);
  }
};
var ExtrinsicFailedError = class extends Error {
  statusCode = 400;
  constructor(extrinsic, reason) {
    super(`The extrinsic failed for reason ${reason}, (hash ${extrinsic.hash}, block ${extrinsic.blockNumber} / ${extrinsic.blockHash})`);
  }
};

// ../substrate-http-proxy/src/schemas/events.ts
var tryParseDispatchError = (extrinsic, dispatchError, substrateClient) => {
  try {
    const { module } = JSON.parse(dispatchError);
    if (!module)
      return null;
    const dispatchErrorModule = substrateClient.registry.createType("DispatchErrorModuleU8a", module);
    const registryError = substrateClient.registry.findMetaError(dispatchErrorModule);
    const { args, docs, name, section } = registryError;
    const message = docs.join(" ") || "Extrinsic failed with unknown error";
    const details = {
      section,
      name,
      args,
      docs,
      extrinsicHash: extrinsic.hash,
      blockNumber: extrinsic.blockNumber.toString(),
      blockHash: extrinsic.blockHash,
      extrinsicIndex: extrinsic.indexInBlock
    };
    return new ApiError2(message, 400, details);
  } catch (e) {
    console.error(e);
    return null;
  }
};
var genericExtrinsicSuccessProcessor = (extrinsic, substrateClient) => {
  if (extrinsic.groupedEvents.system?.ExtrinsicSuccess)
    return;
  const failedEvent = extrinsic.groupedEvents.system?.ExtrinsicFailed;
  if (failedEvent) {
    const dispatchError = failedEvent?.[0]?.dispatch_error || "Extrinsic failed with unknown error";
    if (substrateClient) {
      const parsedError = tryParseDispatchError(extrinsic, dispatchError, substrateClient);
      if (parsedError)
        throw parsedError;
    }
    throw new ExtrinsicFailedError(extrinsic, dispatchError);
  } else {
    throw new EventNotFoundInExtrinsicError(extrinsic, "system.ExtrinsicSuccess or system.ExtrinsicFailed");
  }
};
var zEventBalancesTransfer = z6.object({
  from: zSubstrateAddress,
  to: zSubstrateAddress,
  amountInCoin: z6.string().openapi({
    description: "The amount of the transfer in coins",
    example: "1.5"
  }),
  amount: z6.string().openapi({
    description: "The amount of the transfer in wei",
    example: "1500000000000000000"
  })
});
var zTransferApprovedEvent = z6.object({
  collectionId: z6.number().openapi({ description: "The ID of the collection" }),
  tokenId: z6.number().openapi({ description: "The ID of the token" }),
  spender: z6.string().openapi({ description: "The spender of the token" }),
  amount: z6.number().openapi({ description: "The approved amount of the token" })
});
var BalancesEvents = {
  Transfer: {
    schema: zEventBalancesTransfer,
    parseExtrinsic: async (extrinsic, fastify) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const transferEvent = extrinsic.groupedEvents.balances?.Transfer?.[0];
      if (!transferEvent)
        throw new EventNotFoundInExtrinsicError(extrinsic, "balances.Transfer");
      const { tokenDecimals } = fastify.substrateClient.systemProperties;
      const { from, to, amount } = zEventBalancesTransfer.omit({ amountInCoin: true }).parse(transferEvent);
      return {
        from: Address3.extract.addressNormalized(from),
        to: Address3.extract.addressNormalized(to),
        amountInCoin: weiToCoin(amount, tokenDecimals),
        amount
      };
    }
  }
};
var zCollectionEventParsed = z6.object({
  collectionId: z6.number().openapi({ description: "The ID of the created collection" })
});
var factoryParseCollectionEventArg0CollectionId = (eventName) => async (extrinsic) => {
  genericExtrinsicSuccessProcessor(extrinsic);
  const event = extrinsic.groupedEvents?.common?.[eventName];
  if (!event)
    throw new EventNotFoundInExtrinsicError(extrinsic, `common.${eventName}`);
  const collectionIdStr = event[0]?.["0"];
  if (!collectionIdStr)
    throw new EventNotFoundInExtrinsicError(extrinsic, `common.${eventName}[0].0 - cant parse event`);
  const collectionId = parseInt(collectionIdStr, 10);
  if (isNaN(collectionId))
    throw new EventNotFoundInExtrinsicError(extrinsic, `common.${eventName}[0].0 - cant parse event`);
  return {
    collectionId
  };
};
var CollectionEvents = {
  CollectionCreated: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionCreated")
  },
  CollectionPropertySet: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionPropertySet")
  },
  CollectionPropertyDeleted: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionPropertyDeleted")
  },
  CollectionLimitsSet: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionLimitSet")
  },
  CollectionSponsorSet: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionSponsorSet")
  },
  SponsorshipConfirmed: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("SponsorshipConfirmed")
  },
  CollectionOwnerChanged: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionOwnerChanged")
  },
  CollectionAdminAdded: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionAdminAdded")
  },
  CollectionAdminRemoved: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionAdminRemoved")
  },
  CollectionDestroyed: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionDestroyed")
  },
  PropertyPermissionSet: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("PropertyPermissionSet")
  }
};
var zItemCreatedEvent = z6.object({
  collectionId: z6.number().openapi({ description: "The ID of the created collection" }),
  tokens: z6.array(
    z6.object({
      tokenId: z6.number().openapi({ description: "The ID of the created token" }),
      amount: z6.number().openapi({ description: `The amount of the created token (for NFTs it's always 1)` }),
      owner: z6.string().openapi({ description: "The owner of the token" })
    })
  )
});
var zFungibleItemCreatedEvent = z6.object({
  collectionId: z6.number().openapi({ description: "The ID of the created collection" }),
  recipient: z6.string().openapi({ description: "The owner of the token" }),
  amount: z6.number().openapi({ description: `The amount of the created token (for NFTs it's always 1)` })
});
var zItemTransferredEvent = z6.object({
  collectionId: z6.number().openapi({ description: "The ID of the collection" }),
  tokens: z6.array(
    z6.object({
      tokenId: z6.number().openapi({ description: "The ID of the token" }),
      amount: z6.number().openapi({ description: `The amount of the token (for NFTs it's always 1)` }),
      from: z6.string().openapi({ description: "The previous owner of the token" }),
      to: z6.string().openapi({ description: "The new owner of the token" })
    })
  )
});
var zFungibleItemsTransferredEvent = z6.object({
  collectionId: z6.number().openapi({ description: "The ID of the collection" }),
  from: z6.string().openapi({ description: "The previous owner of the token" }),
  to: z6.string().openapi({ description: "The new owner of the token" }),
  amount: z6.number().openapi({ description: `The amount of the token (for NFTs it's always 1)` })
});
var zItemDestroyedEvent = zItemCreatedEvent;
var zItemPropertiesSetEvent = z6.object({
  collectionId: z6.number().openapi({ description: "The ID of the collection" }),
  tokenId: z6.number().openapi({ description: "The ID of the token" }),
  keys: z6.array(z6.string()).openapi({ description: "The keys of the properties" })
});
var zFungibleItemsDestroyedEvent = z6.object({
  collectionId: z6.number().openapi({ description: "The ID of the collection" }),
  amount: z6.coerce.string().openapi({ description: `The amount of the token (for NFTs it's always 1)` }),
  from: z6.string().openapi({ description: "The previous owner of the token" })
});
var TokenEvents = {
  ItemCreated: {
    schema: zItemCreatedEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.ItemCreated;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.ItemCreated");
      }
      const collectionId = parseInt(events[0]["0"], 10);
      const tokens = events.map((event) => {
        const tokenId = parseInt(event["1"], 10);
        const owner = Address3.extract.address(JSON.parse(event["2"]));
        const amount = parseInt(event["3"], 10);
        return { tokenId, owner, amount };
      });
      return {
        collectionId,
        tokens
      };
    }
  },
  FungibleItemsCreated: {
    schema: zItemCreatedEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.ItemCreated;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.ItemCreated");
      }
      const { ["0"]: collectionId, ["2"]: owner, ["3"]: amount } = events[0];
      return {
        collectionId: parseInt(collectionId, 10),
        recipient: Address3.extract.address(JSON.parse(owner)),
        amount: parseInt(amount, 10)
      };
    }
  },
  ItemTransferred: {
    schema: zItemTransferredEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.Transfer;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.Transfer");
      }
      const collectionId = parseInt(events[0]["0"], 10);
      const tokens = events.map((event) => {
        const tokenId = parseInt(event["1"], 10);
        const from = Address3.extract.address(JSON.parse(event["2"]));
        const to = Address3.extract.address(JSON.parse(event["3"]));
        const amount = parseInt(event["4"], 10);
        return { tokenId, from, to, amount };
      });
      return {
        collectionId,
        tokens
      };
    }
  },
  FungibleItemsTransferred: {
    schema: zItemTransferredEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.Transfer;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.Transfer");
      }
      const { ["0"]: collectionId, ["2"]: from, ["3"]: to, ["4"]: amount } = events[0];
      return {
        collectionId: parseInt(collectionId, 10),
        from: Address3.extract.address(JSON.parse(from)),
        to: Address3.extract.address(JSON.parse(to)),
        amount: parseInt(amount, 10)
      };
    }
  },
  ItemDestroyed: {
    schema: zItemDestroyedEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.ItemDestroyed;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.ItemDestroyed");
      }
      const collectionId = parseInt(events[0]["0"], 10);
      const tokens = events.map((event) => {
        const tokenId = parseInt(event["1"], 10);
        const owner = Address3.extract.address(JSON.parse(event["2"]));
        const amount = parseInt(event["3"], 10);
        return { tokenId, owner, amount };
      });
      return {
        collectionId,
        tokens
      };
    }
  },
  FungibleItemsDestroyed: {
    schema: zItemDestroyedEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.ItemDestroyed;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.ItemDestroyed");
      }
      const { ["0"]: collectionId, ["2"]: owner, ["3"]: amount } = events[0];
      return {
        collectionId: parseInt(collectionId, 10),
        from: Address3.extract.address(JSON.parse(owner)),
        amount: amount.toString()
      };
    }
  },
  ItemPropertiesSet: {
    schema: zItemPropertiesSetEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.TokenPropertySet;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.TokenPropertySet");
      }
      const collectionId = parseInt(events[0]["0"], 10);
      const tokenId = parseInt(events[0]["1"], 10);
      const keys = events.map((event) => event["2"]);
      return {
        collectionId,
        tokenId,
        keys
      };
    }
  },
  TokenPropertiesDeleted: {
    schema: zItemPropertiesSetEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.TokenPropertyDeleted;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.TokenPropertyDeleted");
      }
      const collectionId = parseInt(events[0]["0"], 10);
      const tokenId = parseInt(events[0]["1"], 10);
      const keys = events.map((event) => event["2"]);
      return {
        collectionId,
        tokenId,
        keys
      };
    }
  },
  TransferApproved: {
    schema: zTransferApprovedEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.Approved;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.Approved");
      }
      const collectionId = parseInt(events[0]["0"], 10);
      const tokenId = parseInt(events[0]["1"], 10);
      const spender = Address3.extract.address(JSON.parse(events[0]["3"]));
      const amount = parseInt(events[0]["4"], 10);
      return { collectionId, tokenId, spender, amount };
    }
  }
};

// ../substrate-http-proxy/src/schemas/common.ts
import z7 from "zod";
var zAtBlockHash = z7.object({
  atBlockHash: z7.string().optional().openapi({ description: "Block hash" })
});
var zHashOrNumber = z7.string().transform((value) => {
  if (value.startsWith("0x") && value.length === 66)
    return { hash: value };
  return { number: BigInt(value) };
});
var zAtBlockHashOrNumber = z7.object({
  atBlockHashOrNumber: zHashOrNumber.optional()
});
var zVestedItem = z7.object({
  start: z7.string().openapi({ description: "Number of the block when the vesting starts", example: "123456" }),
  period: z7.string().openapi({ description: "The duration of the vesting period", example: "1" }),
  periodCount: z7.string().openapi({ description: "The number of periods", example: "1" }),
  perPeriod: z7.string().openapi({ description: "The amount per period in coins", example: "1.5" })
});
var zQueryBoolean2 = z7.union([z7.string(), z7.boolean(), z7.number()]).transform((val) => {
  if (typeof val === "string")
    return val.toLowerCase() === "true";
  if (typeof val === "boolean")
    return val;
  return val !== 0;
}).openapi({ description: "Boolean query parameter", type: "boolean" });
var zPagination = z7.object({
  limit: z7.coerce.number().int().min(1).max(1e3).optional().openapi({ description: "Number of items to return, min 1, max 1000", example: 10 }),
  skip: z7.coerce.number().int().min(0).optional().openapi({ description: "Number of items to skip, min 0", example: 0 })
});
var zParsedMetadata = z7.object({
  data: z7.string().nullable(),
  resolved: z7.string().nullable(),
  parsed: z7.object({
    name: z7.string().optional(),
    description: z7.string().optional(),
    image: z7.string().optional()
  })
});

// ../substrate-http-proxy/src/routes/balances.ts
var transferBalances = new ExtrinsicEndpointsConfig({
  route: "/balances/transfer",
  schemaIn: z8.object({
    to: zAddressString,
    amount: z8.coerce.string().openapi({ description: "The amount of the transfer in coins or wei (default)", example: "150000" }),
    isAmountInCoins: z8.boolean().optional().openapi({
      description: "If true, the value is in coins, otherwise in wei. Default is false",
      example: false
    })
  }),
  schemaOut: BalancesEvents.Transfer.schema
});
var getBalances = new QueryEndpointConfig({
  route: "/balances/get",
  schemaIn: z8.object({
    address: zAddressString
  }).merge(zAtBlockHash),
  schemaOut: z8.object({
    available: z8.string().openapi({
      description: "The amount of the available balance in coins",
      example: "1.5"
    }),
    locked: z8.string().openapi({ description: "The amount of the locked balance in wei", example: "1000000000" }),
    free: z8.string().openapi({ description: "The amount of the free balance in wei", example: "1000000000" }),
    total: z8.string().openapi({ description: "The amount of the total balance in wei", example: "1000000000" }),
    reserved: z8.string().openapi({ description: "The amount of the reserved balance in wei", example: "1000000000" }),
    staked: z8.string().openapi({ description: "The amount of the staked balance in wei", example: "1000000000" }),
    unstaked: z8.string().openapi({ description: "The amount of the unstaked balance in wei", example: "1000000000" }),
    canstake: z8.string().openapi({ description: "The amount of the canstake balance in wei", example: "1000000000" }),
    vested: z8.array(zVestedItem).optional().openapi({
      description: "The list of the vested balances",
      example: [{ start: "123456", period: "1", periodCount: "1", perPeriod: "1000000000" }]
    }),
    decimals: z8.number().openapi({ description: "The number of decimals of the token", example: 18 }),
    tokenSymbol: z8.string().openapi({ description: "The token symbol", example: "UNQ" })
  })
});
var BalancesRoutesConfig = {
  extrinsics: {
    transferBalances
  },
  queries: {
    getBalances
  }
};

// ../substrate-http-proxy/src/schemas/collection.ts
import { z as z11 } from "zod";
import { zCollectionSchema } from "@unique-nft/schemas/pure";
import { Address as Address4 } from "@unique-nft/utils/address";

// ../substrate-http-proxy/src/schemas/input.ts
import { z as z9 } from "zod";
var maxByteValidation = (maxSize) => {
  return (str) => {
    const byteSize = new TextEncoder().encode(str).length;
    if (byteSize > maxSize) {
      return false;
    }
    return true;
  };
};
var zMaxBytesPipe = (maxSize) => {
  return z9.string().refine(maxByteValidation(maxSize), `String must not exceed ${maxSize} bytes`);
};

// ../validation-schemas/xcmSchemas.ts
import { z as z10 } from "zod";
var uint8ArraySchema = z10.string().regex(/^0x[a-fA-F0-9]+$/);
var zNetworkIdLiteral = z10.enum(["polkadot", "kusama", "bitcoinCore", "bitcoinCash", "polkadotBulletin"]);
var zNetworkIdByGenesis = z10.object({
  byGenesis: uint8ArraySchema
}).openapi({
  description: "Network ID by genesis",
  example: { byGenesis: "0x0000000000000000000000000000000000000000000000000000000000000000" }
});
var zNetworkId = z10.union([zNetworkIdByGenesis, zNetworkIdLiteral]);
var zGlobalConsensus = z10.object({
  globalConsensus: zNetworkId
});
var zParachain = z10.object({
  parachain: z10.number().optional().openapi({ description: "Parachain ID", example: 2037 })
});
var zGeneralIndex = z10.object({
  generalIndex: z10.number().optional().openapi({ description: "General index", example: 1 })
});
var zPalletInstance = z10.object({
  palletInstance: z10.number().optional().openapi({ description: "Pallet instance", example: 51 })
});
var zUniversalLocationObject = zGlobalConsensus.merge(zParachain).merge(zGeneralIndex).merge(zPalletInstance);
var zFeeAsset = z10.object({
  universalLocation: zUniversalLocationObject,
  decimals: z10.number().openapi({ description: "Decimals", example: 18 })
});
var zTransferParams = z10.object({
  senderAddress: z10.string().openapi({
    description: "Sender address",
    example: "5HWY6cWgaqdov6f2essczduzkBc7yt6mjjbowLJKGMN82KSP"
  }),
  recipientAddress: z10.string().optional().openapi({
    description: "Recipient address",
    example: "5HWY6cWgaqdov6f2essczduzkBc7yt6mjjbowLJKGMN82KSP"
  }),
  collectionUniversalLocation: zUniversalLocationObject,
  sourceParachainId: z10.number().openapi({ description: "Source parachain ID", example: 1e3 }),
  destinationParachainId: z10.number().openapi({ description: "Destination parachain ID", example: 2037 })
});
var zTransferNftParams = zTransferParams.extend({
  itemId: z10.number().openapi({ description: "Item ID", example: 2 }),
  feeAsset: zFeeAsset
});
var zTransferFungibleParams = zTransferParams.extend({
  amount: z10.number().openapi({ description: "Amount in coins", example: 1.1 }),
  decimals: z10.number().openapi({ description: "Decimals", example: 18 }),
  feeAsset: zFeeAsset.optional()
});
var zPreparedTransfer = z10.object({
  txHex: z10.string(),
  fee: z10.string(),
  error: z10.string().optional()
});

// ../substrate-http-proxy/src/schemas/collection.ts
var zCollectionIdNumber = z11.number().int().min(1).max(2 ** 32 - 1).positive().openapi({
  description: "Collection ID",
  example: 1
});
var zCollectionAddress = z11.string().regex(/^0x[0-9a-fA-F]{40}$/).openapi({
  description: "Collection address",
  example: "0x71C7656EC7ab88b098defB751B7401B5f6d8976F"
});
var zCollectionIdString = z11.string().regex(/^[1-9]\d*$/).openapi({
  description: "Collection ID",
  example: "1"
});
var zCollectionIdOrAddress = z11.union([zCollectionIdNumber, zCollectionAddress, zCollectionIdString]).transform((value) => {
  if (typeof value === "number") {
    Address4.validate.collectionId(value);
    return value;
  }
  if (Address4.is.collectionAddress(value)) {
    return Address4.collection.addressToId(value);
  }
  const numberValue = parseInt(value, 10);
  Address4.validate.collectionId(numberValue);
  return numberValue;
}).openapi({
  description: "Collection ID (number) or address (in format 0x)"
});
var zCollectionIdQuery = z11.object({
  collectionId: zCollectionIdOrAddress
}).merge(zAtBlockHash);
var zCollectionLimits = z11.object({
  accountTokenOwnershipLimit: z11.number().nullable().optional().openapi({
    description: "Maximum number of tokens that one address can own",
    example: 1e3
  }),
  sponsoredDataSize: z11.number().nullable().optional().openapi({
    description: "Maximum byte size of custom token data that can be sponsored when tokens are minted in sponsored mode",
    example: 1024
  }),
  sponsoredDataRateLimit: z11.union([z11.number(), z11.string()]).nullable().optional().openapi({
    description: "Defines how many blocks need to pass between setVariableMetadata transactions in order for them to be sponsored",
    example: 30
  }),
  tokenLimit: z11.number().nullable().optional().openapi({
    description: "Total amount of tokens that can be minted in this collection",
    example: 1e6
  }),
  sponsorTransferTimeout: z11.number().nullable().optional().openapi({
    description: "Time interval in blocks that defines once per how long a non-privileged user transfer or mint transaction can be sponsored",
    example: 6
  }),
  sponsorApproveTimeout: z11.number().nullable().optional().openapi({
    description: "Time interval in blocks that defines once per how long a non-privileged user approve transaction can be sponsored",
    example: 6
  }),
  ownerCanTransfer: z11.boolean().nullable().optional().openapi({
    description: "Boolean value that tells if collection owner or admins can transfer or burn tokens owned by other non-privileged users",
    example: false
  }),
  ownerCanDestroy: z11.boolean().nullable().optional().openapi({
    description: "Boolean value that tells if collection owner can destroy it",
    example: false
  }),
  transfersEnabled: z11.boolean().nullable().optional().openapi({
    description: "Flag that defines whether token transfers between users are currently enabled",
    example: false
  })
});
var zAllCollectionStats = z11.object({
  created: z11.number().openapi({ description: "Total number of collections created", example: 100 }),
  destroyed: z11.number().openapi({ description: "Total number of collections destroyed", example: 10 }),
  alive: z11.number().openapi({
    description: "Total number of collections that are created and not destroyed",
    example: 90
  })
});
var zCollectionDecodedSponsorship = z11.object({
  isEnabled: z11.boolean().openapi({
    description: "Flag that defines whether sponsorship is enabled for this collection",
    example: true
  }),
  isConfirmed: z11.boolean().openapi({
    description: "Flag that defines whether sponsorship is confirmed for this collection",
    example: true
  }),
  sponsor: z11.string().nullable().openapi({ description: "Address of the sponsor" })
});
var zDecodedProperty = z11.object({
  key: z11.string().openapi({ description: "The key of the property", example: "my_key" }),
  value: z11.string().openapi({ description: "The value of the property", example: "my_value" }),
  valueHex: z11.string().openapi({ description: "The value of the property in hex", example: "0x02" })
});
var zPropertiesToEncode = z11.array(
  z11.union([
    z11.object({
      key: z11.string().pipe(zMaxBytesPipe(64)),
      value: z11.string().pipe(zMaxBytesPipe(32768)),
      valueHex: z11.string().pipe(zMaxBytesPipe(32768)).optional()
    }),
    z11.object({
      key: z11.string().pipe(zMaxBytesPipe(64)),
      value: z11.string().pipe(zMaxBytesPipe(32768)).optional(),
      valueHex: z11.string().pipe(zMaxBytesPipe(32768))
    })
  ])
);
var zPropertyPermission = z11.object({
  mutable: z11.boolean().openapi({ description: "Flag that defines whether the property is mutable", example: true }),
  collectionAdmin: z11.boolean().openapi({
    description: "Flag that defines whether the property can be changed by collection admin",
    example: true
  }),
  tokenOwner: z11.boolean().openapi({
    description: "Flag that defines whether the property can be changed by token owner",
    example: true
  })
});
var zTokenPropertyPermission = z11.object({
  key: z11.string().pipe(zMaxBytesPipe(256)).openapi({ description: "The key of the property", example: "my_key" }),
  permission: zPropertyPermission
});
var zCollection = z11.object({
  collectionId: zCollectionIdNumber,
  collectionAddress: zCollectionAddress,
  owner: z11.string().openapi({ description: "The owner of the collection", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  mode: z11.enum(["NFT", "Fungible", "ReFungible"]),
  decimals: z11.number().nullable().openapi({ description: "The decimals if collection is fungible, null otherwise" }),
  name: z11.string().openapi({ description: "The name of the collection", example: "My Collection" }),
  description: z11.string().openapi({ description: "The description of the collection", example: "My Collection description" }),
  symbol: z11.string().openapi({ description: "The symbol (token prefix) of the collection", example: "MC" }),
  properties: z11.array(zDecodedProperty),
  limits: zCollectionLimits.or(z11.null()).openapi({ description: "The collection limits" }),
  admins: z11.array(zAddressString).or(z11.null()).openapi({ description: "The collection admins" }),
  lastTokenId: z11.number().or(z11.null()).openapi({ description: "The last token ID" }),
  totalSupply: z11.number().or(z11.null()).openapi({ description: "The total supply (number of minted tokens)" }),
  sponsorship: zCollectionDecodedSponsorship,
  readOnly: z11.boolean().openapi({ description: "Flag that defines whether the collection is read only", example: false }),
  tokenPropertyPermissions: z11.array(zTokenPropertyPermission),
  permissions: z11.object({
    access: z11.union([z11.literal("Normal"), z11.literal("AllowList")]).openapi({ description: "The access mode" }),
    mintMode: z11.boolean().openapi({ description: "Flag that defines whether the mint mode is enabled" }),
    nesting: z11.object({
      tokenOwner: z11.boolean().openapi({ description: "Flag that defines whether the token owner can nest tokens" }),
      collectionAdmin: z11.boolean().openapi({ description: "Flag that defines whether the collection admin can nest tokens" }),
      restricted: z11.array(z11.number()).optional().openapi({ description: "The restricted collection IDs" })
    }).openapi({ description: "The nesting permissions" })
  }),
  info: z11.object(zCollectionSchema.shape).nullable().openapi({ description: "Collection info" }),
  infoDecodingError: z11.string().nullable().openapi({ description: "Error message if decoding of collection info failed" }),
  universalLocation: zUniversalLocationObject.nullable().openapi({ description: "The universal location of the collection" }),
  originalUniversalLocation: zUniversalLocationObject.nullable().openapi({ description: "The universal location of the collection" }),
  isForeign: z11.boolean().nullable().openapi({ description: "Flag that defines whether the collection is foreign" }),
  isErc721Metadata: z11.boolean().nullable().openapi({ description: "Flag that defines whether the collection is ERC721 metadata compatible" })
});
var zCollectionAccess = z11.enum(["Normal", "AllowList"]).openapi({ description: "The access mode", example: "Normal" });
var zCreateCollection = z11.object({
  mode: z11.enum(["Nft", "Fungible", "ReFungible"]).openapi({ description: "The mode of the collection", example: "Nft" }),
  tokenDecimals: z11.coerce.number().int().positive().optional().openapi({ description: "Fungible token decimals", example: 18 }),
  name: z11.string().pipe(zMaxBytesPipe(64)).openapi({ description: "The name of the collection", example: "My Collection" }),
  description: z11.string().pipe(zMaxBytesPipe(256)).openapi({
    description: "The description of the collection",
    example: "My Collection description"
  }),
  symbol: z11.string().optional().pipe(zMaxBytesPipe(16)).openapi({ description: "The symbol of the collection", example: "MC" }),
  access: zCollectionAccess.optional(),
  limits: zCollectionLimits.partial().optional().openapi({ description: "The limits of the collection" }),
  admins: z11.array(zAddressString).openapi({ description: "The collection admins" }).optional(),
  permissions: z11.object({
    access: zCollectionAccess.optional(),
    nesting: z11.object({
      tokenOwner: z11.boolean().optional().openapi({
        description: "Flag that defines whether the token owner can be changed",
        example: true
      }),
      collectionAdmin: z11.boolean().optional().openapi({
        description: "Flag that defines whether the collection admin can be changed",
        example: true
      }),
      restricted: zCollectionIdOrAddress.array().optional().openapi({ description: "The restricted collection IDs or addresses" })
    }).optional().openapi({ description: "The nesting permissions" }),
    mintMode: z11.boolean().optional().openapi({
      description: "Flag that defines whether the mint mode is enabled",
      example: true
    })
  }).optional(),
  pendingSponsor: zAddressString.optional().openapi({ description: "The pending sponsor" }).transform((value) => {
    return typeof value === "string" ? Address4.extract.crossAccountIdNormalized(value) : void 0;
  }),
  info: zCollectionSchema.optional().openapi({ description: "Collection info" }),
  properties: zPropertiesToEncode.optional().openapi({ description: "The properties of the collection" }),
  tokenPropertyPermissions: z11.array(zTokenPropertyPermission).optional().openapi({ description: "The token property permissions (collection setting)" })
});

// ../substrate-http-proxy/src/routes/collection.ts
import { z as z12 } from "zod";
var endpointPrefix = "/collection";
var getCollectionById = new QueryEndpointConfig({
  route: `${endpointPrefix}`,
  schemaIn: zCollectionIdQuery.extend({
    withAdmins: zQueryBoolean2.optional().default(true).openapi({
      description: "If true, the admins will be included in the result",
      example: true
    }),
    withLimits: zQueryBoolean2.optional().default(true).openapi({
      description: "If true, the limits will be included in the result",
      example: true
    }),
    withLastTokenId: zQueryBoolean2.optional().default(true).openapi({
      description: "If true, the last token ID will be included in the result",
      example: true
    }),
    withTotalSupply: zQueryBoolean2.optional().default(true).openapi({
      description: "If true, the total supply will be included in the result",
      example: true
    })
  }),
  schemaOut: zCollection
});
var getCollectionsPaginated = new QueryEndpointConfig({
  route: `${endpointPrefix}/list`,
  schemaIn: zPagination,
  schemaOut: z12.object({
    collections: z12.array(zCollection),
    isLastPage: z12.boolean()
  })
});
var getAllCollectionsStats = new QueryEndpointConfig({
  route: `/allCollectionsStats`,
  schemaIn: zAtBlockHash,
  schemaOut: zAllCollectionStats
});
var getAccountTokens = new QueryEndpointConfig({
  route: "/collection/account/tokens",
  schemaIn: zCollectionIdQuery.extend({
    address: zAddressString
  }),
  schemaOut: z12.array(
    z12.object({
      collectionId: z12.number().int().positive(),
      tokenId: z12.number().int().positive(),
      originalTokenId: z12.number().int().positive().optional()
    })
  )
});
var createCollection = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/create`,
  schemaIn: zCreateCollection,
  schemaOut: zCollection
});
var setCollectionProperties = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/properties/set`,
  schemaIn: z12.object({
    collectionId: zCollectionIdOrAddress,
    properties: zPropertiesToEncode
  }),
  schemaOut: zCollection
});
var setTokenPropertyPermissions = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/token-property-permissions`,
  schemaIn: z12.object({
    collectionId: zCollectionIdOrAddress,
    tokenPropertyPermissions: z12.array(zTokenPropertyPermission)
  }),
  schemaOut: zCollection
});
var deleteCollectionProperties = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/properties/delete`,
  schemaIn: z12.object({
    collectionId: zCollectionIdOrAddress,
    keys: z12.array(z12.string()).min(1)
  }),
  schemaOut: zCollection
});
var setCollectionSponsor = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/sponsor/set`,
  schemaIn: z12.object({
    collectionId: zCollectionIdOrAddress,
    sponsor: zSubstrateAddress
  }),
  schemaOut: zCollection
});
var confirmCollectionSponsorship = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/sponsor/confirm`,
  schemaIn: z12.object({
    collectionId: zCollectionIdOrAddress
  }),
  schemaOut: zCollection
});
var transferCollection = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/transferCollection`,
  schemaIn: z12.object({
    collectionId: zCollectionIdOrAddress,
    to: zAddressString
  }),
  schemaOut: zCollection
});
var setCollectionLimits = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/limits/set`,
  schemaIn: z12.object({
    collectionId: zCollectionIdOrAddress,
    limits: zCollectionLimits
  }),
  schemaOut: zCollection
});
var addCollectionAdmin = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/admin/add`,
  schemaIn: z12.object({
    collectionId: zCollectionIdOrAddress,
    newAdmin: zAddressString
  }),
  schemaOut: zCollection
});
var removeCollectionAdmin = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/admin/remove`,
  schemaIn: z12.object({
    collectionId: zCollectionIdOrAddress,
    adminToDelete: zAddressString
  }),
  schemaOut: zCollection
});
var deleteCollection = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/delete`,
  schemaIn: z12.object({
    collectionId: zCollectionIdOrAddress
  }),
  schemaOut: z12.object({
    collectionId: z12.number()
  })
});
var CollectionRoutesConfig = {
  queries: {
    getCollectionById,
    getCollectionsPaginated,
    getAllCollectionsStats,
    getAccountTokens
  },
  extrinsics: {
    createCollection,
    setCollectionProperties,
    deleteCollectionProperties,
    setCollectionSponsor,
    confirmCollectionSponsorship,
    transferCollection,
    setCollectionLimits,
    addCollectionAdmin,
    removeCollectionAdmin,
    deleteCollection,
    setTokenPropertyPermissions
  }
};

// ../substrate-http-proxy/src/routes/token.ts
import { z as z14 } from "zod";

// ../substrate-http-proxy/src/schemas/token.ts
import { z as z13 } from "zod";
import { SchemaTools } from "@unique-nft/schemas";
var { zTokenSchema } = SchemaTools.tools.schemas;
var zApiQueryTokenId = zAtBlockHash.extend({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  tokenId: z13.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  withChildren: zQueryBoolean2.optional().openapi({ description: "If true, the nested tokens will be included in the result", example: false })
});
var zApiResultToken = zTokenSchema.partial().extend({
  tokenId: z13.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  collectionId: z13.number().int().positive().openapi({ description: "Collection ID", example: 1 }),
  collectionAddress: z13.string().openapi({ description: "Collection address" }),
  symbol: z13.string().openapi({ description: "Symbol (token prefix)" }),
  owner: z13.string().openapi({ description: "Owner address" }),
  parentToken: z13.object({
    collectionId: z13.number().int().positive().openapi({ description: "Collection ID", example: 1 }),
    tokenId: z13.number().int().positive().openapi({ description: "Token ID", example: 1 })
  }).optional().openapi({ description: "Parent token (if the token is nested)" }),
  topmostOwner: z13.string().openapi({ description: "Topmost owner address (if the token is nested)" }),
  properties: z13.array(zDecodedProperty),
  decodingError: z13.string().nullable().openapi({ description: "Error message if decoding failed" })
});
var zTokenURI = z13.string().optional().openapi({ description: "The URI of the token, optional param which might be used for special extended ERC721 standards compat" });
var zTokenPossibleActionsQuery = z13.object({
  sender: zAddressString.openapi({ description: "Sender address", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  collectionId: z13.coerce.number().int().nonnegative().openapi({ description: "Collection ID or address", example: 1 }),
  tokenId: z13.coerce.number().int().nonnegative().openapi({ description: "Token ID", example: 1 }),
  transferTo: zAddressString.optional().openapi({ description: "Recipient address, optional" }),
  nestTo: z13.object({
    collectionId: z13.coerce.number().int().nonnegative(),
    tokenId: z13.coerce.number().int().nonnegative()
  }).optional().openapi({ description: "Token nest options, optional" }),
  amount: z13.coerce.number().int().nonnegative().optional().default(1).openapi({ description: "Amount of tokens to transfer" })
});
var zApiResultTokenWithChildren = zApiResultToken.extend({
  children: z13.array(zApiResultToken).optional().openapi({ description: "Nested tokens" })
});
var zTokenId = z13.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  tokenId: z13.number().int().positive().openapi({ description: "Token ID", example: 1 })
});
var zNestToken = z13.object({
  parent: zTokenId,
  nested: zTokenId,
  from: zAddressString.optional().openapi({ description: 'Sender address (for "transfer from" operations)' }),
  amount: z13.number().int().positive().optional().openapi({ description: "Amount of tokens to nest", example: 1 })
});
var zApproveToken = z13.object({
  spender: zAddressString,
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  tokenId: z13.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  amount: z13.number().int().nonnegative().optional().openapi({ description: "Amount of tokens to approve, default is 1", example: 1 })
});
var zUnnestToken = z13.object({
  to: zAddressString.optional().openapi({ description: "Recipient address" }),
  nested: zTokenId,
  amount: z13.number().int().positive().optional().openapi({ description: "Amount of tokens to transfer (for Fungible and Refungible tokens))", example: 1 })
});

// ../substrate-http-proxy/src/routes/token.ts
var endpointPrefix2 = "/token";
var getToken = new QueryEndpointConfig({
  route: `${endpointPrefix2}`,
  schemaIn: zApiQueryTokenId,
  schemaOut: zApiResultTokenWithChildren
});
var mintNftTokens = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/nfts/mint`,
  schemaIn: z14.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokens: z14.array(
      z14.object({
        data: zTokenSchema.optional().openapi({ description: "Token data" }),
        owner: zAddressString.optional().openapi({ description: "The owner of the token" }),
        URI: zTokenURI,
        properties: zPropertiesToEncode.optional().openapi({ description: "The properties of the token" })
      })
    )
  }),
  schemaOut: z14.array(zApiResultToken)
});
var updateNft = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/update`,
  schemaIn: z14.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: z14.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    data: zTokenSchema.pick({ attributes: true, image: true, image_details: true }).optional().openapi({ description: "Token data" })
  }),
  schemaOut: zApiResultToken
});
var transferTokenFrom = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/transfer-from`,
  schemaIn: z14.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: z14.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    amount: z14.number().int().positive().optional().openapi({ description: "Amount of tokens to transfer (for Fungible and Refungible tokens))", example: 1 }),
    from: zAddressString.optional().openapi({ description: 'Sender address (for "transfer from" operations)' }),
    to: zAddressString.openapi({ description: "Recipient address" })
  }),
  schemaOut: zApiResultToken
});
var burnToken = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/burn`,
  schemaIn: z14.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: z14.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    amount: z14.number().int().positive().optional().openapi({ description: "Amount of tokens to burn (for Fungible and Refungible tokens))", example: 1 })
  }),
  schemaOut: z14.object({
    collectionId: z14.number().int().positive().openapi({ description: "Collection ID", example: 1 }),
    tokenId: z14.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    amount: z14.number().int().positive().openapi({ description: "Amount of tokens burned", example: 1 })
  })
});
var burnTokenFrom = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/burn-from`,
  schemaIn: z14.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: z14.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    from: zAddressString.optional().openapi({ description: 'Token owner address (for "burn from" operations)' }),
    amount: z14.number().int().positive().optional().openapi({ description: "Amount of tokens to burn (for Fungible and Refungible tokens))", example: 1 })
  }),
  schemaOut: burnToken.schemaOut
});
var setTokenProperties = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/properties/set`,
  schemaIn: z14.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: z14.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    properties: zPropertiesToEncode.openapi({ description: "The properties of the token" })
  }),
  schemaOut: zApiResultToken
});
var deleteTokenProperties = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/properties/delete`,
  schemaIn: z14.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: z14.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    keys: z14.array(z14.string()).min(1).openapi({ description: "The keys of the properties to delete" })
  }),
  schemaOut: zApiResultToken
});
var nestToken = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/nest`,
  schemaIn: zNestToken,
  schemaOut: zApiResultToken
});
var unnestToken = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/unnest`,
  schemaIn: zUnnestToken,
  schemaOut: zApiResultToken
});
var approveTokenTransfer = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/approve`,
  schemaIn: zApproveToken,
  schemaOut: TokenEvents.TransferApproved.schema
});
var getApproved = new QueryEndpointConfig({
  route: `${endpointPrefix2}/is-approved`,
  schemaIn: z14.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: z14.coerce.number().int().nonnegative().openapi({ description: "Token ID", example: 1 }),
    sender: zAddressString.optional().openapi({ description: "Owner address" }),
    spender: zAddressString.openapi({ description: "Spender address" })
  }),
  schemaOut: z14.object({
    isApproved: z14.boolean().openapi({ description: "Is token approved for transfer (or burn)", example: true }),
    amount: z14.string().openapi({ description: "Approved amount in decimal string", example: "1" })
  })
});
var getTokenPossibleActions = new QueryEndpointConfig({
  route: `${endpointPrefix2}/possible-actions`,
  schemaIn: zTokenPossibleActionsQuery,
  schemaOut: z14.object({
    burn: z14.boolean().openapi({ description: "Is token burn possible", example: true }),
    nest: z14.boolean().openapi({ description: "Is token nesting possible", example: true }),
    unnest: z14.boolean().openapi({ description: "Is token unnesting possible", example: true }),
    transfer: z14.boolean().openapi({ description: "Is token transfer possible", example: true }),
    changeProperties: z14.array(z14.string()).openapi({ description: "List of properties that can be changed", example: ["key1", "key2"] })
  })
});
var TokenRoutesConfig = {
  queries: {
    getToken,
    getApproved,
    getTokenPossibleActions
  },
  extrinsics: {
    mintNftTokens,
    updateNft,
    transferTokenFrom,
    burnToken,
    burnTokenFrom,
    setTokenProperties,
    deleteTokenProperties,
    nestToken,
    unnestToken,
    approveTokenTransfer
  }
};

// ../substrate-http-proxy/src/routes/fungible.ts
import { z as z16 } from "zod";

// ../substrate-http-proxy/src/schemas/fungible.ts
import { z as z15 } from "zod";
var zMintFungibleTokens = z15.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  recipient: zAddressString.optional(),
  amount: z15.coerce.string().openapi({ example: "150000", type: ["string", "number", "integer"] })
});
var zMintFungibleTokenResult = zMintFungibleTokens.extend({
  collectionId: z15.number().int().positive().openapi({ description: "Collection ID", example: 1 })
});
var zTransferFungibleTokens = z15.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  from: zAddressString.optional().openapi({ description: 'Sender address (for "transfer from" operations)' }),
  to: zAddressString.openapi({ description: "Recipient address", example: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY" }),
  amount: z15.coerce.string().openapi({ example: "150000", type: ["string", "number", "integer"] })
});
var zTransferFungibleTokensResult = zTransferFungibleTokens.extend({
  collectionId: z15.number().int().positive().openapi({ description: "Collection ID", example: 1 })
});
var zBurnFungibleTokens = z15.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  from: zAddressString.optional().openapi({ description: 'Token owner address (for "burn from" operations)' }),
  amount: z15.coerce.string().openapi({ example: "150000", type: ["string", "number", "integer"] })
});
var zBurnFungibleTokensResult = zBurnFungibleTokens.extend({
  collectionId: z15.number().int().positive().openapi({ description: "Collection ID", example: 1 })
});
var zApproveFungibleTokens = z15.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  sender: zAddressString.optional().openapi({ description: "Sender address", example: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY" }),
  spender: zAddressString.openapi({ description: "Spender address", example: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY" }),
  amount: z15.coerce.string().openapi({ example: "150000", type: ["string", "number", "integer"] })
});
var zApproveFungibleTokensResult = zApproveFungibleTokens.omit({ sender: true }).extend({
  collectionId: z15.number().int().positive().openapi({ description: "Collection ID", example: 1 })
});

// ../substrate-http-proxy/src/routes/fungible.ts
var endpointPrefix3 = "/fungible";
var mintTokens = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix3}/mint`,
  schemaIn: zMintFungibleTokens,
  schemaOut: zMintFungibleTokenResult
});
var transferTokensFrom = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix3}/transfer-from`,
  schemaIn: zTransferFungibleTokens,
  schemaOut: zTransferFungibleTokensResult
});
var burnTokens = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix3}/burn`,
  schemaIn: zBurnFungibleTokens.omit({ from: true }),
  schemaOut: zBurnFungibleTokensResult
});
var burnTokensFrom = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix3}/burn-from`,
  schemaIn: zBurnFungibleTokens,
  schemaOut: zBurnFungibleTokensResult
});
var approveTokens = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix3}/approve`,
  schemaIn: zApproveFungibleTokens,
  schemaOut: zApproveFungibleTokensResult
});
var getAccountBalance = new QueryEndpointConfig({
  route: `${endpointPrefix3}/balance`,
  schemaIn: z16.object({
    address: zAddressString,
    collectionId: zCollectionIdOrAddress
  }),
  schemaOut: z16.object({
    address: zAddressString,
    collectionId: z16.number().int().positive().openapi({ description: "Collection ID", example: 1 }),
    balance: z16.string().openapi({ description: "Balance of the account", example: "100" }),
    decimals: z16.number().int().positive().openapi({ description: "Decimals of the fungible token", example: 18 }),
    symbol: z16.string().openapi({ description: "Symbol of the fungible token", example: "DOT" })
  })
});
var getAccountAllowance = new QueryEndpointConfig({
  route: `${endpointPrefix3}/allowance`,
  schemaIn: z16.object({
    sender: zAddressString,
    spender: zAddressString,
    collectionId: zCollectionIdOrAddress
  }),
  schemaOut: z16.object({
    allowance: z16.number().openapi({ description: "Allowance of the account", example: 100 }),
    address: zAddressString,
    collectionId: z16.number().int().positive().openapi({ description: "Collection ID", example: 1 }),
    sender: zAddressString
  })
});
var getCollectionTotalSupply = new QueryEndpointConfig({
  route: `${endpointPrefix3}/total-supply`,
  schemaIn: z16.object({
    collectionId: zCollectionIdOrAddress
  }),
  schemaOut: z16.object({
    totalSupply: z16.number().openapi({ description: "Total supply of the collection", example: 100 })
  })
});
var FungibleRoutesConfig = {
  queries: {
    getAccountBalance,
    getAccountAllowance,
    getCollectionTotalSupply
  },
  extrinsics: {
    mintTokens,
    transferTokensFrom,
    burnTokens,
    burnTokensFrom,
    approveTokens
  }
};

// ../substrate-http-proxy/src/routes/evm/deploy.ts
import { z as z17 } from "zod";

// ../substrate-http-proxy/src/routes/evm/constants.ts
var tags = ["EVM"];
var endpointPrefix4 = "/evm";

// ../substrate-http-proxy/src/routes/evm/deploy.ts
var zEvmDeployArgs = z17.object({
  bytecode: z17.string().regex(/^0x[0-9a-fA-F]*$/, { message: "Bytecode of the contract, must start with 0x" }),
  value: z17.coerce.bigint().optional().openapi({ description: "Value to send with the transaction", type: "string" }),
  gasLimit: z17.coerce.bigint().optional().openapi({ description: "Gas limit for the transaction", type: "string" }),
  maxFeePerGas: z17.coerce.bigint().optional().openapi({ description: "Maximum fee per gas", type: "string" }),
  maxPriorityFeePerGas: z17.coerce.bigint().optional().openapi({ description: "Maximum priority fee per gas", type: "string" }),
  nonce: z17.number().optional().openapi({ description: "Nonce of the transaction" }),
  accessList: z17.array(zEthereumAddress).optional().openapi({ description: "Access list" }),
  source: z17.string().optional().openapi({ description: "Source address" })
});
var contractExistsRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/contract/exists`,
  schemaIn: z17.object({
    address: zEthereumAddress
  }),
  schemaOut: z17.object({
    exists: z17.boolean().openapi({ description: "Flag that defines whether the contract exists" })
  })
});
var contractDeployRoute = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix4}/contract/deploy`,
  schemaIn: zEvmDeployArgs,
  schemaOut: z17.object({
    contractAddress: z17.string().openapi({ description: "Address of the created contract" })
  })
});

// ../substrate-http-proxy/src/routes/evm/call.ts
import { z as z19 } from "zod";

// ../substrate-http-proxy/src/schemas/evm/abi.ts
import z18 from "zod";
var zBaseAbiInput = z18.object({
  name: z18.string().optional(),
  type: z18.string(),
  internalType: z18.string().optional(),
  indexed: z18.boolean().optional()
});
var zAbiInput = zBaseAbiInput.extend({
  components: z18.lazy(() => zAbiInput.array()).optional().openapi({ type: "array" })
});
var zAbiItem = z18.object({
  name: z18.string().optional(),
  inputs: zAbiInput.array().optional(),
  outputs: zAbiInput.array().optional(),
  stateMutability: z18.string().optional(),
  type: z18.string(),
  payable: z18.boolean().optional(),
  constant: z18.boolean().optional()
});
var zAbi = zAbiItem.array();

// ../substrate-http-proxy/src/routes/evm/call.ts
var zEvmCallBodyBase = z19.object({
  functionName: z19.string().openapi({ description: "Name of the function to call" }),
  functionArgs: z19.array(z19.any()).openapi({ description: "Arguments of the function" }),
  senderAddress: z19.string().optional().openapi({ description: "Address of the sender" }),
  gasPrice: z19.coerce.bigint().optional().openapi({ description: "Gas price for the transaction", type: "string" }),
  gasLimit: z19.coerce.bigint().optional().openapi({ description: "Gas limit for the transaction", type: "string" }),
  value: z19.coerce.bigint().optional().openapi({ description: "The amount of the transfer in wei", type: "string" }),
  blockNumber: z19.coerce.bigint().optional().openapi({
    description: "Block number to execute the transaction",
    type: "string"
  })
});
var zEvmCallBody = zEvmCallBodyBase.extend({
  contract: z19.object({
    address: z19.string().openapi({ description: "Address of the contract" }),
    abi: zAbi
  })
});
var zEvmCallBodyKnownContract = zEvmCallBody.extend({
  contract: z19.object({
    address: z19.string().openapi({ description: "Address of the contract" })
  })
});
var unknownContractCall = new QueryEndpointConfig({
  route: `${endpointPrefix4}/contract/call`,
  schemaIn: zEvmCallBody,
  schemaOut: z19.any(),
  method: "POST"
});
var collectionHelpersCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/collection-helpers/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyBase,
  schemaOut: unknownContractCall.schemaOut
});
var contractHelpersCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/contract-helpers/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyBase,
  schemaOut: unknownContractCall.schemaOut
});
var uniqueNftCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/unique-nft/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyKnownContract,
  schemaOut: unknownContractCall.schemaOut
});
var uniqueFungibleCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/unique-fungible/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyKnownContract,
  schemaOut: unknownContractCall.schemaOut
});
var uniqueRefungibleCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/unique-refungible/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyKnownContract,
  schemaOut: unknownContractCall.schemaOut
});
var uniqueNativeFungibleCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/unique-native-fungible/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyKnownContract,
  schemaOut: unknownContractCall.schemaOut
});
var uniqueRefungibleTokenCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/unique-refungible-token/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyKnownContract,
  schemaOut: unknownContractCall.schemaOut
});
var contractCallRoute = unknownContractCall;

// ../substrate-http-proxy/src/routes/evm/send.ts
import { z as z20 } from "zod";
var zEvmSend = z20.object({
  functionName: z20.string(),
  functionArgs: z20.array(z20.any()),
  contract: z20.object({
    address: z20.string().openapi({ description: "Address of the contract" }),
    abi: zAbi
  }),
  value: z20.coerce.bigint().optional().openapi({ description: "The amount of the transfer in wei", type: "string" }),
  gasLimit: z20.coerce.bigint().optional().openapi({ description: "Gas limit for the transaction", type: "string" }),
  maxFeePerGas: z20.coerce.bigint().optional().openapi({ description: "Maximum fee per gas", type: "string" }),
  maxPriorityFeePerGas: z20.coerce.bigint().optional().openapi({
    description: "Maximum priority fee per gas",
    type: "string"
  }),
  source: z20.string().optional().openapi({ description: "Source address" })
});
var zEvmSendKnownContractAbi = zEvmSend.extend({
  contract: z20.object({
    address: z20.string().openapi({ description: "Address of the contract" })
  })
});
var unknownContractSendRoute = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix4}/contract/send`,
  schemaIn: zEvmSend,
  schemaOut: z20.object({
    isSuccessful: z20.boolean().nullable()
  })
});
var collectionHelpersSendRoute = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix4}/collection-helpers/send`,
  schemaOut: unknownContractSendRoute.schemaOut,
  schemaIn: zEvmSend.omit({ contract: true })
});
var contractHelpersSendRoute = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix4}/contract-helpers/send`,
  schemaIn: zEvmSend.omit({ contract: true }),
  schemaOut: unknownContractSendRoute.schemaOut
});
var uniqueNftSendRoute = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix4}/unique-nft/send`,
  schemaOut: unknownContractSendRoute.schemaOut,
  schemaIn: zEvmSendKnownContractAbi
});
var uniqueFungibleSendRoute = new ExtrinsicEndpointsConfig({
  schemaOut: unknownContractSendRoute.schemaOut,
  route: `${endpointPrefix4}/unique-fungible/send`,
  schemaIn: zEvmSendKnownContractAbi
});
var uniqueRefungibleSendRoute = new ExtrinsicEndpointsConfig({
  schemaOut: unknownContractSendRoute.schemaOut,
  route: `${endpointPrefix4}/unique-refungible/send`,
  schemaIn: zEvmSendKnownContractAbi
});
var uniqueNativeFungibleSendRoute = new ExtrinsicEndpointsConfig({
  schemaOut: unknownContractSendRoute.schemaOut,
  route: `${endpointPrefix4}/unique-native-fungible/send`,
  schemaIn: zEvmSendKnownContractAbi
});
var uniqueRefungibleTokenSendRoute = new ExtrinsicEndpointsConfig({
  schemaOut: unknownContractSendRoute.schemaOut,
  route: `${endpointPrefix4}/unique-refungible-token/send`,
  schemaIn: zEvmSendKnownContractAbi
});
var contractSendRoute = unknownContractSendRoute;

// ../substrate-http-proxy/src/routes/evm/parseLogs.ts
import { z as z21 } from "zod";

// ../substrate-http-proxy/src/utils/evm/evmUtils.ts
import { Address as Address5 } from "@unique-nft/utils/address";
var fixBigint = (input) => {
  const asString = JSON.stringify(input, (_, value) => typeof value === "bigint" ? value.toString() : value);
  return JSON.parse(asString);
};

// ../substrate-http-proxy/src/routes/evm/parseLogs.ts
var zEvmParseLogs = z21.object({
  hash: z21.string().openapi({ description: "Hash of the extrinsic" }),
  isFinalized: z21.boolean().optional().openapi({ description: "Is the block with the extrinsic finalized" }),
  abi: zAbi
});
var zEvmLogEventData = z21.object({
  address: z21.string().openapi({ description: "Address of the contract" }),
  topics: z21.array(z21.string()).openapi({ description: "Topics of the log" }),
  data: z21.string().openapi({ description: "Data of the log" })
});
var getEvmLogs = (extrinsic) => {
  const rawLogs = extrinsic.groupedEvents.evm?.Log || [];
  const logs = [];
  for (const { log } of rawLogs) {
    const parsed = zEvmLogEventData.safeParse(JSON.parse(log));
    if (parsed.success)
      logs.push(parsed.data);
  }
  return logs;
};
var unknownContractParseLogsConfig = {
  tags,
  route: `${endpointPrefix4}/contract/logs`,
  schemaIn: zEvmParseLogs,
  schemaOut: z21.object({
    logs: z21.array(z21.any()).openapi({ description: "Decoded logs" })
  }),
  method: "POST",
  queryHandler: async (fastify, query) => {
    const { extrinsicsStorage } = fastify;
    const { hash, abi, isFinalized } = query;
    const extrinsic = await extrinsicsStorage.getExtrinsic(hash, isFinalized);
    if (!extrinsic)
      throw new NotFoundError(`Extrinsic with hash ${hash} not found`);
    const contractInterface = new (void 0).Interface(abi);
    const rawLogs = getEvmLogs(extrinsic);
    const logs = [];
    for (const rawLog of rawLogs) {
      const log = contractInterface.parseLog(rawLog);
      if (!log)
        continue;
      const { name, signature, args } = log;
      logs.push(fixBigint({ name, signature, args }));
    }
    return { logs };
  }
};
var contractLogsRoute = new QueryEndpointConfig(unknownContractParseLogsConfig);

// ../substrate-http-proxy/src/routes/evm/index.ts
var EvmRoutesConfig = {
  queries: {
    contractExistsRoute,
    contractCallRoute,
    collectionHelpersCallRoute,
    contractHelpersCallRoute,
    uniqueNftCallRoute,
    uniqueFungibleCallRoute,
    uniqueRefungibleCallRoute,
    uniqueRefungibleTokenCallRoute,
    uniqueNativeFungibleCallRoute,
    contractLogsRoute
  },
  extrinsics: {
    contractDeployRoute,
    contractSendRoute,
    collectionHelpersSendRoute,
    contractHelpersSendRoute,
    uniqueNftSendRoute,
    uniqueFungibleSendRoute,
    uniqueRefungibleSendRoute,
    uniqueRefungibleTokenSendRoute,
    uniqueNativeFungibleSendRoute
  }
};

// ../substrate-http-proxy/src/routes/batch.ts
import { z as z22 } from "zod";
var zBatchResultParsedExtrinsic = z22.object({
  args: z22.object({
    calls: z22.array(
      z22.object({
        callIndex: z22.string().startsWith("0x"),
        args: z22.any()
      })
    )
  })
});
var batchAll = new ExtrinsicEndpointsConfig({
  route: "/utility/batch-all",
  schemaIn: z22.object({
    calls: z22.array(z22.string()).openapi({ description: "The list of encoded calls to execute" })
  }),
  schemaOut: z22.object({
    isSuccess: z22.boolean(),
    calls: z22.array(
      z22.object({
        callIndex: z22.string().startsWith("0x"),
        name: z22.string(),
        args: z22.any()
      })
    )
  })
});
var BatchEndpoints = {
  extrinsics: {
    batchAll
  },
  queries: {}
};

// ../substrate-http-proxy/src/routes/system.ts
import { z as z23 } from "zod";
var getAccountNextIndex = new QueryEndpointConfig({
  route: "/accounts/next_index",
  schemaIn: z23.object({ address: zAddressString }),
  schemaOut: z23.object({
    nextIndex: z23.number().openapi({ description: "The next index of the account" })
  })
});
var SystemRoutesConfig = {
  extrinsics: {},
  queries: {
    getAccountNextIndex
  }
};

// ../substrate-http-proxy/src/schemas/refungible.ts
import { z as z24 } from "zod";
var zRefungibleTokenQuery = z24.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "The ID of the collection.", example: 1 }),
  tokenId: z24.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 })
});
var zRefungibleToken = z24.object({
  tokenId: z24.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  collectionId: z24.number().int().positive().openapi({ description: "Collection ID", example: 1 }),
  owners: z24.array(zAddressString.openapi({ description: "The owner of the token.", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })),
  pieces: z24.number().positive().openapi({ description: "The number of pieces in the token.", example: 1e4 }),
  properties: z24.array(zDecodedProperty)
});
var zRefungibleAccountBalanceQuery = z24.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "The ID of the collection.", example: 1 }),
  tokenId: z24.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  account: zAddressString.openapi({ description: "The owner of the token.", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })
});
var zRefungibleAccountBalance = zRefungibleAccountBalanceQuery.extend({
  collectionId: z24.number().int().positive().openapi({ description: "The ID of the collection.", example: 1 }),
  balance: z24.number().openapi({ description: "The number of pieces in the token.", example: 1e4 })
});
var zMintRefungibleToken = z24.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "The ID of the collection.", example: 1 }),
  owners: z24.array(
    z24.object({
      address: zAddressString.optional(),
      pieces: z24.number().int().positive().openapi({ description: "The number of pieces in the token.", example: 1e4 })
    })
  ).openapi({ description: "The owners of the token.", example: [{ address: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL", pieces: 1e4 }] }),
  properties: zPropertiesToEncode.optional().openapi({ description: "The properties of the token" }),
  URI: zTokenURI,
  data: zTokenSchema.optional().openapi({ description: "Token data" })
});
var zMintMultipleRefungibleTokens = z24.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "The ID of the collection.", example: 1 }),
  tokens: z24.array(
    z24.object({
      owner: zAddressString.optional().openapi({ description: "The owner of the token.", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
      data: zTokenSchema.optional().openapi({ description: "Token data" }),
      pieces: z24.number().int().positive().openapi({ description: "The number of pieces in the token.", example: 1e4 }),
      properties: zPropertiesToEncode.optional().openapi({ description: "The properties of the token" }),
      URI: zTokenURI
    })
  )
});
var zTransferRefungibleToken = z24.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "The ID of the collection.", example: 1 }),
  from: zAddressString.optional().openapi({ description: "The address of the sender.", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  to: zAddressString.openapi({ description: "The address of the recipient.", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  tokenId: z24.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  pieces: z24.number().int().positive().openapi({ description: "The number of pieces in the token.", example: 1e4 })
});
var zBurnRefungibleToken = z24.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "The ID of the collection.", example: 1 }),
  tokenId: z24.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  from: zAddressString.optional().openapi({ description: "The address of the sender.", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  pieces: z24.number().int().positive().openapi({ description: "The number of pieces in the token.", example: 5e3 })
});
var zBurnRefungibleTokenResult = z24.object({
  collectionId: z24.number().int().positive().openapi({ description: "The ID of the collection.", example: 1 }),
  tokenId: z24.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  pieces: z24.number().int().positive().openapi({ description: "The number of pieces in the token.", example: 5e3 })
});
var zUpdateRefungibleToken = z24.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  tokenId: z24.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  data: zTokenSchema.pick({ attributes: true, image: true, image_details: true }).optional().openapi({ description: "Token data" })
});

// ../substrate-http-proxy/src/routes/refungible.ts
import { z as z25 } from "zod";
var endpointPrefix5 = "/refungible";
var getRefungibleToken = new QueryEndpointConfig({
  route: `${endpointPrefix5}`,
  method: "GET",
  schemaIn: zRefungibleTokenQuery,
  schemaOut: zRefungibleToken
});
var getRefungibleAccountBalance = new QueryEndpointConfig({
  route: `${endpointPrefix5}/account-balance`,
  method: "GET",
  schemaIn: zRefungibleAccountBalanceQuery,
  schemaOut: zRefungibleAccountBalance
});
var mintRefungibleToken = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix5}/mint`,
  schemaIn: zMintRefungibleToken,
  schemaOut: zRefungibleToken
});
var mintRefungibleTokens = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix5}/mint-multiple`,
  schemaIn: zMintMultipleRefungibleTokens,
  schemaOut: z25.array(zRefungibleToken)
});
var RefungibleRoutesConfig = {
  queries: {
    getRefungibleToken,
    getRefungibleAccountBalance
  },
  extrinsics: {
    mintRefungibleToken,
    mintRefungibleTokens
  }
};

// ../substrate-http-proxy/src/routes/utils.ts
import { z as z26 } from "zod";
var getTokenParsedMetadata = new QueryEndpointConfig({
  route: "/utils/parsed-metadata",
  schemaIn: z26.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: z26.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 })
  }),
  schemaOut: zParsedMetadata
});
var UtilsRoutesConfig = {
  queries: {
    getTokenParsedMetadata
  },
  extrinsics: {}
};

// ../substrate-http-proxy/src/routes/palletNfts/collection.ts
import { z as z29 } from "zod";

// ../substrate-http-proxy/src/schemas/palletNfts/collection.ts
import { z as z28 } from "zod";

// ../substrate-http-proxy/src/schemas/palletNfts/attributes.ts
import { z as z27 } from "zod";
var AttributeNamespaceEnum = /* @__PURE__ */ ((AttributeNamespaceEnum2) => {
  AttributeNamespaceEnum2["pallet"] = "pallet";
  AttributeNamespaceEnum2["collectionOwner"] = "collectionOwner";
  AttributeNamespaceEnum2["itemOwner"] = "itemOwner";
  return AttributeNamespaceEnum2;
})(AttributeNamespaceEnum || {});
var zAttributeNamespace = z27.union([z27.nativeEnum(AttributeNamespaceEnum), zSubstrateAddress]).openapi({ description: "Namespace, which can be either a named namespace or an account address" });
var zAttribute = z27.object({
  key: z27.string().openapi({ description: "Attribute key" }),
  value: z27.string().openapi({ description: "Attribute value" }),
  namespace: zAttributeNamespace
});
var zGetAttributesQuery = z27.object({
  collectionId: z27.coerce.number().nonnegative(),
  itemId: z27.coerce.number().nonnegative().optional(),
  namespace: zAttributeNamespace
});
var zGetAttributeQuery = zGetAttributesQuery.extend({
  key: z27.string().openapi({ description: "Attribute key" })
});

// ../substrate-http-proxy/src/schemas/palletNfts/collection.ts
var zNftsCollectionId = z28.object({
  collectionId: z28.coerce.number().openapi({ description: "Collection ID", example: 1 })
});
var zPalletNftsCollectionQuery = z28.object({
  collectionId: z28.coerce.number().int().nonnegative().openapi({ description: "Collection ID", example: 1 })
}).merge(zAtBlockHash);
var zNftsCollectionSettings = z28.object({
  lockedTransferItems: z28.boolean().openapi({ description: "Locked transfer items", example: false }),
  lockedMetadata: z28.boolean().openapi({ description: "Locked metadata", example: false }),
  lockedAttributes: z28.boolean().openapi({ description: "Locked attributes", example: false }),
  lockedMaxSupply: z28.boolean().openapi({ description: "Locked max supply", example: false })
});
var zMintType = z28.union([z28.literal("Issuer"), z28.literal("Public"), z28.object({ holderOf: z28.number() })]);
var zNftsItemSettings = z28.object({
  lockedTransfers: z28.boolean().openapi({ description: "Locked transfers", example: false }),
  lockedMetadata: z28.boolean().openapi({ description: "Locked metadata", example: false }),
  lockedAttributes: z28.boolean().openapi({ description: "Locked attributes", example: false })
});
var zNftsMintSettings = z28.object({
  mintType: zMintType.openapi({ description: "Mint type", example: "Issuer" }),
  price: z28.string().or(z28.number()).nullable().openapi({ description: "Price", example: "1000000000000000000000" }),
  startBlock: z28.number().nullable().openapi({ description: "Start block", example: 1 }),
  endBlock: z28.number().nullable().openapi({ description: "End block", example: 1 }),
  defaultItemSettings: zNftsItemSettings.partial().optional().openapi({ description: "Default item settings" })
});
var zNftsCreateCollectionConfig = z28.object({
  settings: zNftsCollectionSettings.optional().openapi({ description: "Collection settings" }),
  maxSupply: z28.number().optional().openapi({ description: "Max supply", example: 100 }),
  mintSettings: zNftsMintSettings.partial().optional().openapi({ description: "Mint settings" })
});
var zNftsCollectionCreateArguments = z28.object({
  admin: zAddressString.optional(),
  collectionConfig: zNftsCreateCollectionConfig.optional().openapi({ description: "Collection config" })
});
var zCollectionCreateResult = z28.object({
  collectionId: z28.number().openapi({ description: "Collection ID", example: 1 }),
  creator: z28.string().openapi({ description: "Creator", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  owner: z28.string().openapi({ description: "Owner", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })
});
var zNftsCollectionConfig = z28.object({
  settings: zNftsCollectionSettings.optional().openapi({ description: "Collection settings" }),
  maxSupply: z28.number().nullable().openapi({ description: "Max supply", example: 100 }),
  mintSettings: zNftsMintSettings.partial().optional().openapi({ description: "Mint settings" })
});
var zNftsCollectionRole = z28.object({
  issuer: z28.boolean(),
  admin: z28.boolean(),
  freezer: z28.boolean()
});
var zNftsCollectionLockResult = zNftsCollectionId.extend({});
var zNftsCollectionMetadata = z28.object({
  deposit: z28.string(),
  data: z28.string()
});
var zNftsCollectionDetails = z28.object({
  collectionId: z28.number().openapi({ description: "The ID of the collection", example: 0 }),
  owner: z28.string().openapi({ description: "The owner of the collection", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  ownerDeposit: z28.number().openapi({ description: "The owner deposit" }),
  items: z28.number().openapi({ description: "The number of items" }),
  itemMetadatas: z28.number().openapi({ description: "The number of item metadatas" }),
  itemConfigs: z28.number().openapi({ description: "The number of item configs" }),
  attributes: z28.array(zAttribute).openapi({ description: "Attributes of the collection" }),
  metadata: zNftsCollectionMetadata.nullable().openapi({ description: "The collection metadata" }),
  config: zNftsCollectionConfig.openapi({ description: "The collection config" }),
  universalLocation: zUniversalLocationObject.nullable(),
  isForeign: z28.boolean().optional().openapi({ description: "Is foreign collection" }),
  originalUniversalLocation: zUniversalLocationObject.nullable().openapi({ description: "Original collection universal location" })
});

// ../substrate-http-proxy/src/routes/palletNfts/collection.ts
var getCollection = new QueryEndpointConfig({
  route: "/pallet-nfts/collection/get",
  schemaIn: zPalletNftsCollectionQuery,
  schemaOut: zNftsCollectionDetails
});
var getCollectionsPaginated2 = new QueryEndpointConfig({
  route: "/pallet-nfts/collections",
  schemaIn: zPagination,
  schemaOut: z29.object({
    collections: z29.array(zNftsCollectionDetails),
    isLastPage: z29.boolean()
  })
});
var getNextCollectionId = new QueryEndpointConfig({
  route: "/pallet-nfts/collection/next-id",
  schemaIn: z29.object({}),
  schemaOut: z29.object({
    nextCollectionId: z29.number()
  })
});
var createCollection2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/create",
  schemaIn: zNftsCollectionCreateArguments.optional(),
  schemaOut: zNftsCollectionDetails.extend({
    creator: zAddressString
  })
});
var destroyCollection = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/destroy",
  schemaIn: z29.object({
    collectionId: z29.number().positive(),
    witness: z29.object({
      itemMetadatas: z29.number().default(0),
      itemConfigs: z29.number().default(0),
      attributes: z29.number().default(0)
    }).default({})
  }),
  schemaOut: z29.object({
    collectionId: z29.number()
  })
});
var acceptCollectionOwnership = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/accept-ownership",
  schemaIn: z29.object({
    collectionId: z29.number().positive().optional()
  }),
  schemaOut: z29.object({
    who: z29.string(),
    collectionId: z29.number().optional()
  })
});
var transferCollectionOwnership = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/transfer",
  schemaIn: z29.object({
    collectionId: z29.number().positive(),
    newOwner: zAddressString
  }),
  schemaOut: zNftsCollectionDetails
});
var lockNftsCollection = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/lock",
  schemaIn: z29.object({
    collectionId: z29.number().positive(),
    settings: zNftsCollectionSettings.partial().refine((settings) => Object.keys(settings).length > 0, { message: "At least one setting must be changed" })
  }),
  schemaOut: zNftsCollectionDetails
});
var updateMintSettings = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/update-mint-settings",
  schemaIn: z29.object({
    collectionId: z29.number().positive(),
    mintSettings: zNftsMintSettings.partial().refine((settings) => Object.keys(settings).length > 0, { message: "At least one setting must be changed" }).refine((settings) => settings.defaultItemSettings ? Object.keys(settings.defaultItemSettings).length > 0 : true, {
      message: "At least one default item setting must be changed"
    })
  }),
  schemaOut: zNftsCollectionDetails
});
var setMaxSupply = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/set-max-supply",
  schemaIn: z29.object({
    collectionId: z29.number().positive(),
    maxSupply: z29.number().positive()
  }),
  schemaOut: zNftsCollectionDetails
});
var setCollectionTeam = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/set-team",
  schemaIn: z29.object({
    collectionId: z29.number().positive(),
    issuer: zAddressString.optional(),
    admin: zAddressString.optional(),
    freezer: zAddressString.optional()
  }),
  schemaOut: zNftsCollectionDetails.extend({
    role: z29.object({
      issuer: zAddressString.nullable(),
      admin: zAddressString.nullable(),
      freezer: zAddressString.nullable()
    })
  })
});
var setCollectionAttribute = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/set-attribute",
  schemaIn: z29.object({
    collectionId: z29.number().positive(),
    attribute: zAttribute
  }),
  schemaOut: zNftsCollectionDetails
});
var clearCollectionAttribute = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/clear-attribute",
  schemaIn: z29.object({
    collectionId: z29.number().positive(),
    attribute: zAttribute.omit({ value: true })
  }),
  schemaOut: zNftsCollectionDetails
});
var setCollectionMetadata = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/set-metadata",
  schemaIn: z29.object({
    collectionId: z29.number().positive(),
    data: z29.string()
  }),
  schemaOut: zNftsCollectionDetails
});
var clearCollectionMetadata = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/clear-metadata",
  schemaIn: z29.object({
    collectionId: z29.number().positive()
  }),
  schemaOut: zNftsCollectionDetails
});

// ../substrate-http-proxy/src/schemas/palletNfts/item.ts
import { z as z30 } from "zod";
var zNftsItemPrice = z30.object({
  amount: z30.string(),
  buyer: z30.string().nullable()
});
var zNftsItemSettings2 = z30.object({
  lockedTransfers: z30.boolean(),
  lockedMetadata: z30.boolean(),
  lockedAttributes: z30.boolean()
});
var zNftsItemMetadata = z30.object({
  data: z30.string(),
  deposit: z30.object({
    account: z30.string().nullable(),
    amount: z30.string()
  })
});
var zNftsTransferApproval = z30.object({
  delegate: z30.string(),
  deadlineBlock: z30.number().optional()
});
var zNftsItemDeposit = z30.object({
  account: z30.string(),
  amount: z30.string()
});
var zNftsItem = z30.object({
  collectionId: z30.number(),
  itemId: z30.number(),
  owner: z30.string(),
  deposit: zNftsItemDeposit,
  transferApprovals: z30.array(zNftsTransferApproval),
  metadata: zNftsItemMetadata.nullable(),
  price: zNftsItemPrice.nullable(),
  attributes: z30.array(zAttribute),
  settings: zNftsItemSettings2.nullable()
});

// ../substrate-http-proxy/src/routes/palletNfts/items.ts
import { z as z31 } from "zod";
var getItem = new QueryEndpointConfig({
  route: "/pallet-nfts/items/get",
  schemaIn: z31.object({
    collectionId: z31.coerce.number().positive(),
    itemId: z31.coerce.number().positive()
  }),
  schemaOut: zNftsItem
});
var mintItem = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/mint",
  schemaIn: z31.object({
    collectionId: z31.number().nonnegative(),
    itemId: z31.number().nonnegative(),
    mintTo: zAddressString,
    witnessData: z31.object({
      ownedItemId: z31.number().optional(),
      mintPrice: z31.number().optional()
    }).optional()
  }),
  schemaOut: zNftsItem
});
var burnItem = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/burn",
  schemaIn: z31.object({
    collectionId: z31.number().positive(),
    itemId: z31.number().positive()
  }),
  schemaOut: z31.any()
});
var approveItemAttributes = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/approve-attributes",
  schemaIn: z31.object({
    collectionId: z31.number().positive(),
    itemId: z31.number().positive(),
    delegate: zAddressString
  }),
  schemaOut: z31.any()
});
var approveItemTransfer = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/approve-transfer",
  schemaIn: z31.object({
    collectionId: z31.number().positive(),
    itemId: z31.number().positive(),
    delegate: zAddressString,
    deadline: z31.number().positive().optional().openapi({ description: "Transfer will be approved in next N blocks" })
  }),
  schemaOut: z31.any()
});
var cancelItemTransferApproval = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/cancel-transfer-approval",
  schemaIn: z31.object({
    collectionId: z31.number().positive(),
    itemId: z31.number().positive(),
    delegate: zAddressString
  }),
  schemaOut: z31.object({
    collectionId: z31.number(),
    itemId: z31.number(),
    owner: z31.string(),
    delegate: z31.string()
  })
});
var clearAllTransferApprovals = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/clear-all-transfer-approvals",
  schemaIn: z31.object({
    collectionId: z31.number().positive(),
    itemId: z31.number().positive()
  }),
  schemaOut: z31.object({
    collectionId: z31.number(),
    itemId: z31.number()
  })
});
var setItemAttribute = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/set-attribute",
  schemaIn: z31.object({
    collectionId: z31.number().positive(),
    itemId: z31.number().positive(),
    attribute: zAttribute
  }),
  schemaOut: zNftsItem
});
var clearItemAttribute = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/clear-attribute",
  schemaIn: z31.object({
    collectionId: z31.number().positive(),
    itemId: z31.number().positive(),
    attribute: zAttribute
  }),
  schemaOut: zNftsItem
});
var setItemMetadata = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/set-metadata",
  schemaIn: z31.object({
    collectionId: z31.number().positive(),
    itemId: z31.number().positive(),
    data: z31.string()
  }),
  schemaOut: zNftsItem
});
var clearItemMetadata = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/clear-metadata",
  schemaIn: z31.object({
    collectionId: z31.number().positive(),
    itemId: z31.number().positive()
  }),
  schemaOut: zNftsItem
});
var cancelItemAttributesApproval = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/cancel-attributes-approval",
  schemaIn: z31.object({
    collectionId: z31.number().positive(),
    itemId: z31.number().positive(),
    delegate: zAddressString
  }),
  schemaOut: z31.object({
    collectionId: z31.number(),
    itemId: z31.number(),
    owner: z31.string(),
    delegate: z31.string()
  })
});
var lockItemTransfer = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/lock-transfer",
  schemaIn: z31.object({
    collectionId: z31.number().positive(),
    itemId: z31.number().positive()
  }),
  schemaOut: z31.object({
    collectionId: z31.number(),
    itemId: z31.number()
  })
});
var unlockItemTransfer = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/unlock-transfer",
  schemaIn: z31.object({
    collectionId: z31.number().positive(),
    itemId: z31.number().positive()
  }),
  schemaOut: z31.object({
    collectionId: z31.number(),
    itemId: z31.number()
  })
});
var transferItem = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/transfer",
  schemaIn: z31.object({
    collectionId: z31.number().positive(),
    itemId: z31.number().positive(),
    to: zAddressString
  }),
  schemaOut: zNftsItem
});
var lockItemPropertiesIn = z31.object({
  collectionId: z31.number().positive(),
  itemId: z31.number().positive(),
  lockMetadata: z31.boolean().optional().openapi({ description: "Lock metadata, default: false" }),
  lockAttributes: z31.boolean().optional().openapi({ description: "Lock attributes, default: false" })
});
var lockItemProperties = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/lock-properties",
  schemaIn: lockItemPropertiesIn,
  schemaOut: lockItemPropertiesIn
});

// ../substrate-http-proxy/src/routes/palletNfts/attributes.ts
import { z as z32 } from "zod";
var getAttribute = new QueryEndpointConfig({
  route: "/pallet-nfts/attribute",
  schemaIn: z32.object({
    collectionId: z32.coerce.number().positive(),
    itemId: z32.coerce.number().positive().optional(),
    namespace: zAttributeNamespace,
    key: z32.string()
  }),
  schemaOut: z32.object({
    collectionId: z32.number().positive(),
    itemId: z32.number().positive().optional(),
    attribute: zAttribute.nullable()
  })
});
var getAttributes = new QueryEndpointConfig({
  route: "/pallet-nfts/attributes",
  schemaIn: z32.object({
    collectionId: z32.coerce.number().positive(),
    itemId: z32.coerce.number().positive().optional(),
    namespace: zAttributeNamespace.optional()
  }),
  schemaOut: z32.any()
});
var zSetAttributeIn = z32.object({
  collectionId: z32.number().positive(),
  itemId: z32.number().positive().optional(),
  attribute: zAttribute
});
var setAttribute = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/set-attribute",
  schemaIn: zSetAttributeIn,
  schemaOut: zSetAttributeIn
});
var zClearAttributeIn = z32.object({
  collectionId: z32.number().positive(),
  itemId: z32.number().positive().optional(),
  attribute: zAttribute.omit({ value: true })
});
var clearAttribute = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/clear-attribute",
  schemaIn: zClearAttributeIn,
  schemaOut: zClearAttributeIn
});

// ../substrate-http-proxy/src/routes/palletNfts/account.ts
import { z as z33 } from "zod";
var getAccountCollections = new QueryEndpointConfig({
  route: "/pallet-nfts/account/collections",
  schemaIn: z33.object({
    account: zAddressString
  }),
  schemaOut: z33.object({
    account: zAddressString,
    collections: z33.number().array()
  })
});
var getCollectionOwnershipAcceptance = new QueryEndpointConfig({
  route: "/pallet-nfts/account/ownership-acceptance",
  schemaIn: z33.object({
    account: zAddressString
  }),
  schemaOut: z33.object({
    collectionId: z33.number().nullable()
  })
});
var getCollectionRole = new QueryEndpointConfig({
  route: "/pallet-nfts/account/collection-role",
  schemaIn: z33.object({
    collectionId: z33.coerce.number(),
    account: zAddressString
  }),
  schemaOut: zNftsCollectionRole.extend({
    owner: z33.boolean()
  })
});
var getAccountItems = new QueryEndpointConfig({
  route: "/pallet-nfts/account/items",
  schemaIn: z33.object({
    account: zAddressString,
    collectionId: z33.coerce.number().int().nonnegative().openapi({ description: "Collection ID", example: 1 })
  }),
  schemaOut: z33.array(z33.object({
    collectionId: z33.number(),
    tokenId: z33.number(),
    original: z33.object({
      collectionId: z33.number(),
      tokenId: z33.number()
    }).optional()
  }))
});

// ../substrate-http-proxy/src/routes/palletNfts/common.ts
import { z as z34 } from "zod";
var getPalletVersion = new QueryEndpointConfig({
  route: "/pallet-nfts/common/pallet-version",
  schemaIn: z34.object({}),
  schemaOut: z34.object({
    version: z34.number().openapi({ description: "The version of the NFTs pallet" })
  })
});
var getNextCollectionId2 = new QueryEndpointConfig({
  route: "/pallet-nfts/common/next-collection-id",
  schemaIn: z34.object({}),
  schemaOut: z34.object({
    nextCollectionId: z34.number().openapi({ description: "The next collection id that is going to be used" })
  })
});

// ../substrate-http-proxy/src/routes/palletNfts/trades.ts
import { z as z35 } from "zod";
var setPrice = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/set-price",
  schemaIn: z35.object({
    collectionId: z35.number().positive(),
    itemId: z35.number().positive(),
    price: z35.union([z35.number().positive(), z35.string()]).nullable().optional(),
    buyer: zAddressString.optional()
  }),
  schemaOut: z35.any()
});
var buyItem = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/buy",
  schemaIn: z35.object({
    collectionId: z35.number().positive(),
    itemId: z35.number().positive(),
    bidPrice: z35.union([z35.number().positive(), z35.string().regex(/^\d+$/)])
  }),
  schemaOut: z35.object({
    collectionId: z35.number(),
    itemId: z35.number(),
    price: z35.string(),
    seller: z35.string(),
    buyer: z35.string()
  })
});

// ../substrate-http-proxy/src/routes/palletNfts/utils.ts
import { z as z36 } from "zod";
var getTokenParsedMetadata2 = new QueryEndpointConfig({
  route: "/pallet-nfts/utils/parsed-metadata",
  schemaIn: z36.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: z36.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 })
  }),
  schemaOut: z36.any()
});

// ../substrate-http-proxy/src/schemas/palletUniques/item.ts
import { z as z38 } from "zod";

// ../substrate-http-proxy/src/schemas/palletUniques/attributes.ts
import { z as z37 } from "zod";
var zUniquesGetCollectionAttributesIn = z37.object({
  collectionId: z37.coerce.number().openapi({ description: "The ID of the collection." })
});
var zUniquesItemAttributesIn = z37.object({
  collectionId: z37.coerce.number().openapi({ description: "The ID of the collection." }),
  itemId: z37.coerce.number().openapi({ description: "The ID of the asset." })
});
var zAttributesIn = z37.object({
  collectionId: z37.coerce.number().openapi({ description: "The ID of the collection." }),
  itemId: z37.coerce.number().optional().openapi({ description: "The ID of the item." })
});
var zUniquesAttribute = z37.object({
  key: z37.string().openapi({ description: "Attribute key" }),
  value: z37.string().nullable().openapi({ description: "Attribute value" })
});
var zUniquesGetAttribute = z37.object({
  collectionId: z37.coerce.number().openapi({ description: "The ID of the collection." }),
  itemId: z37.coerce.number().optional().openapi({ description: "The ID of the item." }),
  attributeKey: z37.string().openapi({ description: "The key of the attribute." })
});
var zUniquesSetAttributeIn = z37.object({
  collectionId: z37.coerce.number().openapi({ description: "The ID of the collection." }),
  itemId: z37.coerce.number().optional().openapi({ description: "The ID of the item." }),
  attribute: z37.object({
    key: z37.string().openapi({ description: "The key of the attribute." }),
    value: z37.string().openapi({ description: "The value of the attribute." })
  })
});
var zUniquesClearAttributeIn = z37.object({
  collectionId: z37.coerce.number().openapi({ description: "The ID of the collection." }),
  itemId: z37.coerce.number().optional().openapi({ description: "The ID of the item." }),
  attributeKey: z37.string().openapi({ description: "The key of the attribute." })
});
var zUniquesSetCollectionMetadataIn = z37.object({
  collectionId: z37.coerce.number().openapi({ description: "The ID of the collection." }),
  data: z37.string().openapi({ description: "The metadata of the collection." }),
  isFrozen: z37.boolean().optional().default(false).openapi({ description: "Whether the collection is frozen." })
});
var zUniquesMetadata = z37.object({
  data: z37.string().openapi({ description: "The metadata of the collection." }),
  isFrozen: z37.boolean().optional().default(false).openapi({ description: "Whether the collection is frozen." }),
  deposit: z37.string().openapi({ description: "The deposit of the collection." })
});
var zUniquesSetItemMetadataIn = zUniquesSetCollectionMetadataIn.extend({
  itemId: z37.coerce.number().openapi({ description: "The ID of the item." })
});
var zUniquesClearCollectionMetadataIn = z37.object({
  collectionId: z37.coerce.number().openapi({ description: "The ID of the collection." })
});
var zUniquesClearItemMetadataIn = zUniquesClearCollectionMetadataIn.extend({
  itemId: z37.coerce.number().openapi({ description: "The ID of the item." })
});

// ../substrate-http-proxy/src/schemas/palletUniques/item.ts
var zUniquesItem = z38.object({
  itemId: z38.coerce.number().int().openapi({ description: "Item ID", example: 0 }),
  collectionId: z38.coerce.number().int().openapi({ description: "Collection ID", example: 0 }),
  owner: z38.string().openapi({ description: "The owner of the item" }),
  approved: z38.string().nullable().openapi({ description: "Approved address" }),
  isFrozen: z38.boolean().openapi({ description: "Whether the item is frozen" }),
  deposit: z38.number().openapi({ description: "The deposit of the item" })
});
var zUniquesItemDetails = zUniquesItem.extend({
  metadata: zUniquesMetadata.nullable().openapi({ description: "The metadata of the item" }),
  attributes: z38.array(zUniquesAttribute)
});
var zUniquesItemsQuery = z38.object({
  collectionId: z38.coerce.number().int().openapi({ description: "Collection ID", example: 0 }),
  itemId: z38.coerce.number().int().openapi({ description: "Item ID", example: 0 })
});
var zUniquesCollectionItemsQuery = zUniquesItemsQuery.omit({ itemId: true });
var zUniquesMintItem = zUniquesItemsQuery.extend({
  owner: zAddressString.openapi({ description: "The owner of the item", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })
});
var zUniquesCollectionMetadataQuery = zUniquesItemsQuery.omit({ itemId: true });
var zUniquesTransferItem = zUniquesItemsQuery.extend({
  newOwner: zAddressString.openapi({ description: "The new owner of the item", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  oldOwner: zAddressString.optional().openapi({ description: "The old owner of the item", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })
});
var zUniquesBurnItemQuery = zUniquesItemsQuery.extend({
  checkOwner: zAddressString.optional().openapi({ description: "The owner of the item", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })
});

// ../substrate-http-proxy/src/schemas/palletUniques/collection.ts
import { z as z39 } from "zod";
var zUniquesCollectionQuery = z39.object({
  collectionId: z39.coerce.number().int().openapi({ description: "Collection ID", example: 0 })
});
var zUniquesCreateCollectionQuery = zUniquesCollectionQuery.extend({
  collectionId: z39.coerce.number().int().optional().openapi({ description: "Collection ID", example: 0 }),
  admin: zAddressString
});
var zUniquesTransferCollectionQuery = zUniquesCollectionQuery.extend({
  newOwner: zAddressString
});
var zUniquesCollectionDetails = z39.object({
  collectionId: z39.coerce.number().int().openapi({ description: "Collection ID", example: 0 }),
  owner: z39.string().openapi({ description: "The owner of the collection." }),
  issuer: z39.string().openapi({ description: "The issuer of the collection." }),
  admin: z39.string().openapi({ description: "The admin of the collection." }),
  freezer: z39.string().openapi({ description: "The freezer of the collection." }),
  totalDeposit: z39.number().openapi({ description: "The total deposit of the collection." }),
  freeHolding: z39.boolean().openapi({ description: "Whether the collection is free-holding." }),
  items: z39.number().openapi({ description: "The number of items in the collection." }),
  itemMetadatas: z39.number().openapi({ description: "The number of item metadatas in the collection." }),
  isFrozen: z39.boolean().openapi({ description: "Whether the collection is frozen." }),
  maxSupply: z39.coerce.number().int().openapi({ description: "Max supply", example: 0 }),
  attributes: z39.array(zUniquesAttribute),
  metadata: zUniquesMetadata.nullable().openapi({ description: "The metadata of the collection." }),
  universalLocation: zUniversalLocationObject.nullable().openapi({ description: "The universal location of the collection" })
});

// ../substrate-http-proxy/src/routes/palletUniques/collection.ts
import { z as z40 } from "zod";
var getFreeCollectionId = new QueryEndpointConfig({
  route: "/pallet-uniques/collection/free-id",
  schemaIn: z40.object({}),
  schemaOut: z40.object({
    freeCollectionId: z40.number()
  })
});
var createCollection3 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/create",
  schemaIn: zUniquesCreateCollectionQuery,
  schemaOut: zUniquesCollectionDetails.extend({
    creator: zAddressString
  })
});
var destroyCollection2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/destroy",
  schemaIn: zUniquesCollectionQuery.extend({
    witness: z40.object({
      itemMetadatas: z40.number().default(0),
      itemConfigs: z40.number().default(0),
      attributes: z40.number().default(0)
    }).default({})
  }),
  schemaOut: zUniquesCollectionQuery
});
var freezeCollection = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/freeze",
  schemaIn: zUniquesCollectionQuery,
  schemaOut: zUniquesCollectionDetails
});
var thawCollection = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/thaw",
  schemaIn: zUniquesCollectionQuery,
  schemaOut: zUniquesCollectionDetails
});
var setCollectionAttribute2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/set-attribute",
  schemaIn: zUniquesSetAttributeIn.omit({ itemId: true }),
  schemaOut: zUniquesCollectionDetails
});
var clearCollectionAttribute2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/clear-attribute",
  schemaIn: zUniquesClearAttributeIn.omit({ itemId: true }),
  schemaOut: zUniquesCollectionDetails
});
var setCollectionMetadata2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/set-metadata",
  schemaIn: zUniquesSetCollectionMetadataIn,
  schemaOut: zUniquesCollectionDetails
});
var clearCollectionMetadata2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/clear-metadata",
  schemaIn: zUniquesClearCollectionMetadataIn,
  schemaOut: zUniquesCollectionDetails
});
var transferCollection2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/transfer",
  schemaIn: zUniquesTransferCollectionQuery,
  schemaOut: zUniquesCollectionDetails
});
var getCollection2 = new QueryEndpointConfig({
  route: "/pallet-uniques/collection/get",
  schemaIn: zUniquesCollectionQuery,
  schemaOut: zUniquesCollectionDetails
});
var getCollectionsPaginated3 = new QueryEndpointConfig({
  route: "/pallet-uniques/collections",
  schemaIn: zPagination,
  schemaOut: z40.object({
    collections: z40.array(zUniquesCollectionDetails),
    isLastPage: z40.boolean()
  })
});
var getCollectionAttributes = new QueryEndpointConfig({
  route: "/pallet-uniques/collection/attributes",
  schemaIn: zUniquesGetCollectionAttributesIn,
  schemaOut: z40.object({
    collectionId: z40.number(),
    attributes: z40.array(zUniquesAttribute)
  })
});
var getCollectionItems = new QueryEndpointConfig({
  route: "/pallet-uniques/collection/items",
  schemaIn: zUniquesCollectionItemsQuery,
  schemaOut: z40.object({
    collectionId: z40.number(),
    items: z40.array(
      z40.object({
        itemId: z40.number(),
        details: zUniquesItem
      })
    )
  })
});

// ../substrate-http-proxy/src/routes/palletUniques/item.ts
import { z as z41 } from "zod";
var mintItem2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/mint",
  schemaIn: zUniquesMintItem,
  schemaOut: zUniquesItemDetails
});
var transferItem2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/transfer",
  schemaIn: zUniquesTransferItem,
  schemaOut: zUniquesItemDetails
});
var freezeItem = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/freeze",
  schemaIn: zUniquesBurnItemQuery,
  schemaOut: zUniquesItemDetails
});
var thawItem = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/thaw",
  schemaIn: zUniquesBurnItemQuery,
  schemaOut: zUniquesItemDetails
});
var burnItem2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/burn",
  schemaIn: zUniquesBurnItemQuery,
  schemaOut: z41.object({
    collectionId: z41.number(),
    itemId: z41.number()
  })
});
var setItemAttribute2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/set-attribute",
  schemaIn: zUniquesSetAttributeIn.extend({
    itemId: z41.coerce.number().openapi({ description: "The ID of the item." })
  }),
  schemaOut: zUniquesItemDetails
});
var setItemMetadata2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/set-metadata",
  schemaIn: zUniquesSetItemMetadataIn,
  schemaOut: zUniquesItemDetails
});
var clearItemAttribute2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/clear-attribute",
  schemaIn: zUniquesClearAttributeIn.required({ itemId: true }),
  schemaOut: zUniquesItemDetails
});
var clearItemMetadata2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/clear-metadata",
  schemaIn: zUniquesClearItemMetadataIn,
  schemaOut: zUniquesItemDetails
});
var getItem2 = new QueryEndpointConfig({
  route: "/pallet-uniques/item/get",
  schemaIn: zUniquesItemsQuery,
  schemaOut: zUniquesItemDetails
});
var getItemAttributes = new QueryEndpointConfig({
  route: "/pallet-uniques/item/attributes",
  schemaIn: zUniquesItemAttributesIn,
  schemaOut: z41.object({
    itemId: z41.number(),
    attributes: z41.array(zUniquesAttribute)
  })
});

// ../substrate-http-proxy/src/schemas/palletUniques/account.ts
import { z as z42 } from "zod";
var zUniquesAccountCollections = z42.object({
  account: zAddressString.openapi({ description: "The ID of the account", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  collections: z42.array(z42.number().openapi({ description: "The ID of the collection" }))
});
var zUniquesAccountCollectionsQuery = z42.object({
  address: z42.string().openapi({ description: "The ID of the account", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })
});
var zUniquesAccountItems = z42.object({
  account: zAddressString.openapi({ description: "The ID of the account", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  items: z42.array(z42.number().openapi({ description: "The ID of the asset" }))
});
var zUniquesAccountItemsQuery = z42.object({
  address: z42.string().openapi({ description: "The ID of the account", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  collectionId: z42.coerce.number().int().openapi({ description: "Collection ID", example: 0 })
});
var zUniquesAccountAcceptOwnerQuery = z42.object({
  collectionId: z42.coerce.number().int().optional().openapi({ description: "Collection ID", example: 0 })
});

// ../substrate-http-proxy/src/routes/palletUniques/account.ts
import { z as z43 } from "zod";
var acceptCollectionOwnership2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/account/accept-collection-ownership",
  schemaIn: zUniquesAccountAcceptOwnerQuery,
  schemaOut: z43.object({
    collectionId: z43.number().nullable(),
    account: zAddressString
  })
});
var getAccountCollectionIds = new QueryEndpointConfig({
  route: "/pallet-uniques/account/collections",
  schemaIn: zUniquesAccountCollectionsQuery,
  schemaOut: zUniquesAccountCollections
});
var getAccountItemIds = new QueryEndpointConfig({
  route: "/pallet-uniques/account/items",
  schemaIn: zUniquesAccountItemsQuery,
  schemaOut: zUniquesAccountItems
});

// ../substrate-http-proxy/src/routes/palletUniques/attributes.ts
var setAttribute2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/set-attribute",
  schemaIn: zUniquesSetAttributeIn,
  schemaOut: zUniquesSetAttributeIn
});
var clearAttribute2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/clear-attribute",
  schemaIn: zUniquesClearAttributeIn,
  schemaOut: zUniquesClearAttributeIn
});
var getAttribute2 = new QueryEndpointConfig({
  route: "/pallet-uniques/attribute",
  schemaIn: zUniquesGetAttribute,
  schemaOut: zUniquesAttribute
});

// ../substrate-http-proxy/src/routes/palletUniques/utils.ts
import { z as z44 } from "zod";
var getTokenParsedMetadata3 = new QueryEndpointConfig({
  route: "/pallet-uniques/utils/parsed-metadata",
  schemaIn: z44.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: z44.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 })
  }),
  schemaOut: z44.any()
});

// ../substrate-http-proxy/src/schemas/palletAssets/index.ts
import { z as z45 } from "zod";
var zAssetsAddress = z45.string().openapi({ description: "The owner of the collection", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" });
var zAsset = z45.object({
  id: z45.number().openapi({ description: "Asset ID", example: 1 }),
  owner: zAssetsAddress,
  issuer: zAssetsAddress,
  admin: zAssetsAddress,
  freezer: zAssetsAddress,
  supply: z45.string().openapi({ description: "Supply", example: "1000000000000000000000" }),
  deposit: z45.string().openapi({ description: "Deposit", example: "1000000000000000000000" }),
  minBalance: z45.string().openapi({ description: "Min balance", example: "1000000000000000000000" }),
  isSufficient: z45.boolean().openapi({ description: "Is sufficient", example: true }),
  accounts: z45.number().openapi({ description: "Accounts", example: 23 }),
  sufficients: z45.number().openapi({ description: "Sufficients", example: 23 }),
  approvals: z45.number().openapi({ description: "Approvals", example: 23 }),
  status: z45.string().openapi({ description: "Status", example: "Live" }),
  name: z45.string().openapi({ description: "Name", example: "USD Stablecoin" }),
  symbol: z45.string().openapi({ description: "Symbol", example: "USD" }),
  decimals: z45.number().openapi({ description: "Decimals", example: 18 }),
  isFrozen: z45.boolean().openapi({ description: "Is frozen", example: false }),
  universalLocation: zUniversalLocationObject.nullable().openapi({ description: "The universal location of the collection" })
});
var zAssetQuery = z45.object({
  id: z45.coerce.number().int().positive().openapi({ description: "Collection ID", example: 1 })
});

// ../substrate-http-proxy/src/routes/palletAssets/asset.ts
import { z as z46 } from "zod";
var getAsset = new QueryEndpointConfig({
  route: "/pallet-assets/asset",
  schemaIn: zAssetQuery,
  schemaOut: zAsset
});
var getAssetsPaginated = new QueryEndpointConfig({
  route: "/pallet-assets/assets",
  schemaIn: zPagination,
  schemaOut: z46.object({
    assets: z46.array(zAsset),
    isLastPage: z46.boolean()
  })
});
var getBalance = new QueryEndpointConfig({
  route: "/pallet-assets/balance",
  schemaIn: z46.object({
    address: z46.string(),
    id: z46.coerce.number().int().positive().openapi({ description: "Collection ID", example: 1 })
  }),
  schemaOut: z46.object({
    balance: z46.string(),
    symbol: z46.string(),
    decimals: z46.number()
  })
});

// ../substrate-http-proxy/src/routes/palletForeignUniques/foreignUniquesAssetHub.ts
import { z as z47 } from "zod";
var getDerivativeRegistered = new QueryEndpointConfig({
  route: "/pallet-foreign-uniques-asset-hub/registered",
  method: "POST",
  schemaIn: z47.object({
    universalLocation: zUniversalLocationObject
  }),
  schemaOut: z47.object({
    registered: z47.boolean()
  })
});
var listDerivatives = new QueryEndpointConfig({
  route: "/pallet-foreign-uniques-asset-hub/list",
  method: "GET",
  schemaIn: zPagination,
  schemaOut: z47.array(
    z47.object({
      itemsCount: z47.number(),
      universalLocation: zUniversalLocationObject
    })
  )
});
var registerDerivative = new ExtrinsicEndpointsConfig({
  route: "/pallet-foreign-uniques-asset-hub/register",
  schemaIn: z47.object({
    universalLocation: zUniversalLocationObject
  }),
  schemaOut: z47.object({
    registered: z47.boolean()
  })
});
var getAccountItems2 = new QueryEndpointConfig({
  route: "/pallet-foreign-uniques-asset-hub/account-items",
  method: "POST",
  schemaIn: z47.object({
    universalLocation: zUniversalLocationObject,
    account: zAddressString
  }),
  schemaOut: z47.object({
    items: z47.array(z47.number())
  })
});

// ../substrate-http-proxy/src/routes/palletForeignUniques/derivativeCollections.ts
import { z as z48 } from "zod";
var getDerivativeRegistered2 = new QueryEndpointConfig({
  route: "/derivative-collections/registered",
  method: "POST",
  schemaIn: z48.object({
    universalLocation: zUniversalLocationObject
  }),
  schemaOut: z48.object({
    registered: z48.boolean()
  })
});
var registerDerivativeUnique = new ExtrinsicEndpointsConfig({
  route: "/derivative-collections/register",
  schemaIn: z48.object({
    universalLocation: zUniversalLocationObject,
    mode: z48.enum(["Nft", "Fungible"]).openapi({ description: "The mode of the collection", example: "Nft" }),
    name: z48.string().pipe(zMaxBytesPipe(64)).openapi({ description: "The name of the collection", example: "My Collection" }),
    tokenDecimals: z48.coerce.number().int().positive().optional().openapi({ description: "Fungible token decimals", example: 18 }),
    symbol: z48.string().optional().pipe(zMaxBytesPipe(16)).openapi({ description: "The symbol of the collection", example: "MC" })
  }),
  schemaOut: z48.object({
    registered: z48.boolean()
  })
});
var registerDerivativeAssetHub = new ExtrinsicEndpointsConfig({
  route: "/derivative-collections/register",
  schemaIn: z48.object({
    universalLocation: zUniversalLocationObject
  }),
  schemaOut: z48.object({
    registered: z48.boolean()
  })
});
var UniqueDerivativeCollectionsRoutesConfig = {
  queries: {
    getDerivativeRegistered: getDerivativeRegistered2
  },
  extrinsics: {
    registerDerivative: registerDerivativeUnique
  }
};

// ../substrate-http-proxy/src/routes/palletForeignUniques/foreignAssetsAssetHub.ts
import { z as z49 } from "zod";

// ../substrate-client/registry/registry.ts
import { HexString } from "@unique-nft/utils/string";

// ../substrate-http-proxy/src/routes/palletAssets/_queries.ts
import { Address as Address6 } from "@unique-nft/utils/address";

// ../substrate-http-proxy/src/routes/palletForeignUniques/foreignAssetsAssetHub.ts
var getDerivativeRegistered3 = new QueryEndpointConfig({
  route: "/pallet-foreign-assets-asset-hub/registered",
  method: "POST",
  schemaIn: z49.object({
    universalLocation: zUniversalLocationObject
  }),
  schemaOut: z49.object({
    registered: z49.boolean()
  })
});
var listDerivatives2 = new QueryEndpointConfig({
  route: "/pallet-foreign-assets-asset-hub/list",
  method: "GET",
  schemaIn: zPagination,
  schemaOut: z49.array(
    zAsset.omit({ id: true })
  )
});
var getAccountBalance2 = new QueryEndpointConfig({
  route: "/pallet-foreign-assets-asset-hub/account-items",
  method: "POST",
  schemaIn: z49.object({
    universalLocation: zUniversalLocationObject,
    account: zAddressString
  }),
  schemaOut: z49.object({
    balance: z49.string(),
    symbol: z49.string(),
    decimals: z49.number()
  })
});

// src/xcm.ts
import { z as z50 } from "zod";
var uint8ArraySchema2 = z50.string().regex(/^0x[a-fA-F0-9]+$/);
var zNetworkIdLiteral2 = z50.enum(["polkadot", "kusama", "bitcoinCore", "bitcoinCash", "polkadotBulletin"]);
var zNetworkIdByGenesis2 = z50.object({
  byGenesis: uint8ArraySchema2
});
var zNetworkId2 = z50.union([zNetworkIdByGenesis2, zNetworkIdLiteral2]);
var zUniversalLocationObject2 = z50.object({
  globalConsensus: zNetworkId2,
  parachain: z50.number().optional(),
  palletInstance: z50.number().optional(),
  generalIndex: z50.number().optional()
});
var zTransferParams2 = z50.object({
  senderAddress: z50.string(),
  recipientAddress: z50.string().optional(),
  itemId: z50.number(),
  collectionUniversalLocation: zUniversalLocationObject2,
  sourceParachainId: z50.number(),
  destinationParachainId: z50.number()
});
var zFeeAsset2 = z50.object({
  universalLocation: zUniversalLocationObject2,
  decimals: z50.number()
});
var zTransferNftParams2 = zTransferParams2.extend({
  itemId: z50.number(),
  feeAsset: zFeeAsset2
});
var zTransferFungibleParams2 = zTransferParams2.extend({
  amount: z50.number(),
  decimals: z50.number(),
  feeAsset: zFeeAsset2.optional()
});
var zXcmTransferResult = z50.object({
  xcmMessageId: z50.string(),
  xcmMessageHash: z50.string()
});
var xcmMethods = {
  transferNft: {
    route: "/xcm/nft-transfer",
    schemaIn: zTransferNftParams2,
    encodeSchemaIn: zTransferNftParams2,
    schemaOut: zXcmTransferResult
  },
  transferFungible: {
    route: "/xcm/fungible-transfer",
    schemaIn: zTransferFungibleParams2,
    encodeSchemaIn: zTransferNftParams2,
    schemaOut: zXcmTransferResult
  },
  feeAssets: {
    route: "/xcm/fee-assets",
    schemaIn: z50.object({
      parachainId: z50.number()
    }),
    encodeSchemaIn: z50.object({
      parachainId: z50.number()
    }),
    schemaOut: z50.array(zUniversalLocationObject2)
  }
};

// src/uniqueChain.ts
var UniqueChain = (options) => {
  const { extrinsic, makeExtrinsicFn, makeQueryFn } = prepareBase(options);
  return {
    options,
    extrinsic,
    utility: {
      batchAll: makeExtrinsicFn({
        ...BatchEndpoints.extrinsics.batchAll,
        schemaIn: zAlternativeBatchArgs
      }),
      getParsedMetadata: makeQueryFn(UtilsRoutesConfig.queries.getTokenParsedMetadata)
    },
    balance: {
      get: makeQueryFn(BalancesRoutesConfig.queries.getBalances),
      transfer: makeExtrinsicFn(BalancesRoutesConfig.extrinsics.transferBalances)
    },
    account: {
      nextIndex: makeQueryFn(SystemRoutesConfig.queries.getAccountNextIndex)
    },
    collection: {
      get: makeQueryFn(CollectionRoutesConfig.queries.getCollectionById),
      list: makeQueryFn(CollectionRoutesConfig.queries.getCollectionsPaginated),
      getAllCollectionStats: makeQueryFn(CollectionRoutesConfig.queries.getAllCollectionsStats),
      create: makeExtrinsicFn(CollectionRoutesConfig.extrinsics.createCollection),
      setProperties: makeExtrinsicFn(CollectionRoutesConfig.extrinsics.setCollectionProperties),
      deleteProperties: makeExtrinsicFn(CollectionRoutesConfig.extrinsics.deleteCollectionProperties),
      setSponsor: makeExtrinsicFn(CollectionRoutesConfig.extrinsics.setCollectionSponsor),
      confirmSponsorship: makeExtrinsicFn(CollectionRoutesConfig.extrinsics.confirmCollectionSponsorship),
      transferCollection: makeExtrinsicFn(CollectionRoutesConfig.extrinsics.transferCollection),
      setLimits: makeExtrinsicFn(CollectionRoutesConfig.extrinsics.setCollectionLimits),
      setTokenPropertyPermissions: makeExtrinsicFn(CollectionRoutesConfig.extrinsics.setTokenPropertyPermissions),
      accountTokens: makeQueryFn(CollectionRoutesConfig.queries.getAccountTokens)
    },
    token: {
      get: makeQueryFn(TokenRoutesConfig.queries.getToken),
      mintNFTs: makeExtrinsicFn(TokenRoutesConfig.extrinsics.mintNftTokens),
      updateNft: makeExtrinsicFn(TokenRoutesConfig.extrinsics.updateNft),
      transfer: makeExtrinsicFn(TokenRoutesConfig.extrinsics.transferTokenFrom),
      burn: makeExtrinsicFn(TokenRoutesConfig.extrinsics.burnToken),
      burnFrom: makeExtrinsicFn(TokenRoutesConfig.extrinsics.burnTokenFrom),
      setProperties: makeExtrinsicFn(TokenRoutesConfig.extrinsics.setTokenProperties),
      deleteProperties: makeExtrinsicFn(TokenRoutesConfig.extrinsics.deleteTokenProperties),
      nest: makeExtrinsicFn(TokenRoutesConfig.extrinsics.nestToken),
      unnest: makeExtrinsicFn(TokenRoutesConfig.extrinsics.unnestToken),
      approve: makeExtrinsicFn(TokenRoutesConfig.extrinsics.approveTokenTransfer),
      getApproved: makeQueryFn(TokenRoutesConfig.queries.getApproved),
      possibleActions: makeQueryFn(TokenRoutesConfig.queries.getTokenPossibleActions)
    },
    fungible: {
      totalSupply: makeQueryFn(FungibleRoutesConfig.queries.getCollectionTotalSupply),
      getApproved: makeQueryFn(FungibleRoutesConfig.queries.getAccountAllowance),
      getAccountBalance: makeQueryFn(FungibleRoutesConfig.queries.getAccountBalance),
      mint: makeExtrinsicFn(FungibleRoutesConfig.extrinsics.mintTokens),
      transfer: makeExtrinsicFn(FungibleRoutesConfig.extrinsics.transferTokensFrom),
      burn: makeExtrinsicFn(FungibleRoutesConfig.extrinsics.burnTokens),
      burnFrom: makeExtrinsicFn(FungibleRoutesConfig.extrinsics.burnTokensFrom),
      approve: makeExtrinsicFn(FungibleRoutesConfig.extrinsics.approveTokens)
    },
    refungible: {
      get: makeQueryFn(RefungibleRoutesConfig.queries.getRefungibleToken),
      getAccountBalance: makeQueryFn(RefungibleRoutesConfig.queries.getRefungibleAccountBalance),
      getApproved: makeQueryFn(TokenRoutesConfig.queries.getApproved),
      mint: makeExtrinsicFn(RefungibleRoutesConfig.extrinsics.mintRefungibleToken),
      mintMultiple: makeExtrinsicFn(RefungibleRoutesConfig.extrinsics.mintRefungibleTokens),
      transfer: makeExtrinsicFn(TokenRoutesConfig.extrinsics.transferTokenFrom),
      approve: makeExtrinsicFn(TokenRoutesConfig.extrinsics.approveTokenTransfer),
      burn: makeExtrinsicFn(TokenRoutesConfig.extrinsics.burnToken),
      burnFrom: makeExtrinsicFn(TokenRoutesConfig.extrinsics.burnTokenFrom),
      updateNft: makeExtrinsicFn(TokenRoutesConfig.extrinsics.updateNft),
      setProperties: makeExtrinsicFn(TokenRoutesConfig.extrinsics.setTokenProperties),
      deleteProperties: makeExtrinsicFn(TokenRoutesConfig.extrinsics.deleteTokenProperties)
    },
    evm: {
      call: makeQueryFn(EvmRoutesConfig.queries.contractCallRoute),
      send: makeExtrinsicFn(EvmRoutesConfig.extrinsics.contractSendRoute),
      logs: makeQueryFn(EvmRoutesConfig.queries.contractLogsRoute),
      exists: makeQueryFn(EvmRoutesConfig.queries.contractExistsRoute),
      deploy: makeExtrinsicFn(EvmRoutesConfig.extrinsics.contractDeployRoute),
      collectionHelpers: {
        call: makeQueryFn(EvmRoutesConfig.queries.collectionHelpersCallRoute),
        send: makeExtrinsicFn(EvmRoutesConfig.extrinsics.collectionHelpersSendRoute)
      },
      contractHelpers: {
        call: makeQueryFn(EvmRoutesConfig.queries.contractHelpersCallRoute),
        send: makeExtrinsicFn(EvmRoutesConfig.extrinsics.contractHelpersSendRoute)
      },
      uniqueNft: {
        call: makeQueryFn(EvmRoutesConfig.queries.uniqueNftCallRoute),
        send: makeExtrinsicFn(EvmRoutesConfig.extrinsics.uniqueNftSendRoute)
      },
      uniqueFungible: {
        call: makeQueryFn(EvmRoutesConfig.queries.uniqueFungibleCallRoute),
        send: makeExtrinsicFn(EvmRoutesConfig.extrinsics.uniqueFungibleSendRoute)
      },
      uniqueRefungible: {
        call: makeQueryFn(EvmRoutesConfig.queries.uniqueRefungibleCallRoute),
        send: makeExtrinsicFn(EvmRoutesConfig.extrinsics.uniqueRefungibleSendRoute)
      },
      uniqueRefungibleToken: {
        call: makeQueryFn(EvmRoutesConfig.queries.uniqueRefungibleTokenCallRoute),
        send: makeExtrinsicFn(EvmRoutesConfig.extrinsics.uniqueRefungibleTokenSendRoute)
      },
      uniqueNativeFungible: {
        call: makeQueryFn(EvmRoutesConfig.queries.uniqueNativeFungibleCallRoute),
        send: makeExtrinsicFn(EvmRoutesConfig.extrinsics.uniqueNativeFungibleSendRoute)
      },
      contractExists: makeQueryFn(EvmRoutesConfig.queries.contractExistsRoute)
    },
    derivative: {
      registered: makeQueryFn(UniqueDerivativeCollectionsRoutesConfig.queries.getDerivativeRegistered),
      register: makeExtrinsicFn(UniqueDerivativeCollectionsRoutesConfig.extrinsics.registerDerivative)
    },
    xcm: {
      transferNft: makeExtrinsicFn(xcmMethods.transferNft),
      transferFungible: makeExtrinsicFn(xcmMethods.transferFungible),
      feeAssets: makeQueryFn(xcmMethods.feeAssets)
    }
  };
};
export {
  UniqueChain
};
//# sourceMappingURL=uniqueChain.js.map