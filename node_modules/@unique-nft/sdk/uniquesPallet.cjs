"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/uniquesPallet.ts
var uniquesPallet_exports = {};
__export(uniquesPallet_exports, {
  UniquesPalletRoutes: () => UniquesPalletRoutes
});
module.exports = __toCommonJS(uniquesPallet_exports);

// src/_base.ts
var import_axios2 = __toESM(require("axios"), 1);
var import_zod3 = require("zod");
var import_qs = __toESM(require("qs"), 1);

// src/errors.ts
var import_zod = require("zod");
var import_axios = __toESM(require("axios"), 1);
var ApiError = class extends Error {
  isApiError = true;
  data;
  zodError;
  constructor(axiosError) {
    if (!import_axios.default.isAxiosError(axiosError) || !axiosError.response) {
      const isEconnRefused = axiosError?.code === "ECONNREFUSED" || axiosError?.message.includes("ECONNREFUSED");
      if (isEconnRefused) {
        throw new Error("Connection to the server refused, please check the server URL");
      }
      throw new Error(axiosError.message);
    }
    const resp = axiosError.response;
    const message = `Server responded with Error ${resp.status} - ${resp.statusText}: ` + (typeof resp.data === "string" ? resp.data : JSON.stringify(resp.data));
    super(message);
    this.data = resp.data;
    this.zodError = resp.data.zodError ? new import_zod.z.ZodError(resp.data.zodError.issues) : null;
  }
  static isApiError(err) {
    return err.apiErrorFlag;
  }
};

// src/types.ts
var import_zod2 = require("zod");
var import_address = require("@unique-nft/utils/address");
import_zod2.z.ZodType.prototype.openapi = function() {
  return this;
};
var zUniqueBuildExtrinsicOptions = import_zod2.z.object({
  signerAddress: import_zod2.z.string().refine((address) => import_address.Address.is.substrateAddress(address)),
  nonce: import_zod2.z.number().optional(),
  mortalLength: import_zod2.z.number().optional()
});

// src/_base.ts
import_zod3.z.ZodType.prototype.openapi = function() {
  return this;
};
var DEFAULT_TIMES_TO_RETRY = 15;
var DEFAULT_TIMEOUT = 3e3;
var getStatusOptions = (instanceStatusOptions, requestStatusOptions) => {
  const timeout = requestStatusOptions?.timeout || instanceStatusOptions?.timeout;
  const retries = requestStatusOptions?.retries || instanceStatusOptions?.retries;
  const TIMEOUT = timeout || DEFAULT_TIMEOUT;
  const TIMES_TO_RETRY = retries || DEFAULT_TIMES_TO_RETRY;
  const IS_FINALIZED = requestStatusOptions?.isFinalized || instanceStatusOptions?.isFinalized;
  return { TIMEOUT, TIMES_TO_RETRY, IS_FINALIZED };
};
var serializeObjectWithBigInt = (obj) => {
  return JSON.parse(
    JSON.stringify(obj, (key, value) => {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    })
  );
};
var getBuildExtrinsic = (client, chainParams) => async (endpointPart, paramsValidator, _params, _buildOptions) => {
  let buildOptions = {};
  if (_buildOptions) {
    const buildOptionsResult = zUniqueBuildExtrinsicOptions.safeParse(_buildOptions);
    if (!buildOptionsResult.success) {
      throw buildOptionsResult.error.format();
    }
    buildOptions = buildOptionsResult.data;
  }
  buildOptions.signerAddress = buildOptions?.signerAddress || chainParams.account?.address || "";
  if (!buildOptions.signerAddress) {
    throw new Error("No signer address provided");
  }
  const paramsParseResult = await paramsValidator.safeParseAsync(_params);
  if (!paramsParseResult.success) {
    throw paramsParseResult.error.format();
  }
  const params = paramsParseResult.data;
  try {
    const { data: builtExtrinsic } = await client.post(endpointPart + "/build", {
      args: serializeObjectWithBigInt(params),
      options: buildOptions
    });
    return builtExtrinsic;
  } catch (e) {
    throw new ApiError(e);
  }
};
var getEncodeExtrinsic = (client) => async (endpointPart, paramsValidator, _params) => {
  const paramsParseResult = await paramsValidator.safeParseAsync(_params);
  if (!paramsParseResult.success) {
    throw paramsParseResult.error.format();
  }
  const params = paramsParseResult.data;
  try {
    const { data: encodeExtrinsic } = await client.post(endpointPart + "/encode", {
      args: serializeObjectWithBigInt(params)
    });
    return encodeExtrinsic;
  } catch (e) {
    throw new ApiError(e);
  }
};
var getExtrinsicFee = (client, chainParams) => async (endpointPart, paramsValidator, _params, _buildOptions) => {
  let buildOptions = {};
  if (_buildOptions) {
    const buildOptionsResult = zUniqueBuildExtrinsicOptions.safeParse(_buildOptions);
    if (!buildOptionsResult.success) {
      throw buildOptionsResult.error.format();
    }
    buildOptions = buildOptionsResult.data;
  }
  buildOptions.signerAddress = buildOptions?.signerAddress || chainParams.account?.address || "";
  if (!buildOptions.signerAddress) {
    throw new Error("No signer address provided");
  }
  const paramsParseResult = await paramsValidator.safeParseAsync(_params);
  if (!paramsParseResult.success) {
    throw paramsParseResult.error.format();
  }
  const params = paramsParseResult.data;
  try {
    const { data: extrinsicFees } = await client.post(endpointPart + "/fee", {
      args: serializeObjectWithBigInt(params),
      options: buildOptions
    });
    return extrinsicFees;
  } catch (e) {
    throw new ApiError(e);
  }
};
var getSignExtrinsic = (client, chainParams) => async (payload, account) => {
  const signer = account?.signer || chainParams.account?.signer;
  if (!signer)
    throw new Error("No signer provided");
  return (await signer.sign(payload)).signature;
};
var getSubmitExtrinsic = (client) => async (extrinsicOrPayload, signature) => {
  try {
    const { data: sentExtrinsic } = await client.post("/extrinsics/submit", {
      signerPayloadJSON: "signerPayloadJSON" in extrinsicOrPayload ? extrinsicOrPayload.signerPayloadJSON : extrinsicOrPayload,
      signature
    });
    return sentExtrinsic.hash;
  } catch (e) {
    throw new ApiError(e);
  }
};
var getExtrinsicStatusCheck = (client, chainParams) => async (endpointPart, extrinsicHash, options) => {
  let extrinsicStatusResponse;
  const { TIMEOUT, TIMES_TO_RETRY, IS_FINALIZED } = getStatusOptions(chainParams.statusOptions, options);
  const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  let counter = 0;
  do {
    try {
      let url = endpointPart + "/status/" + extrinsicHash;
      if (IS_FINALIZED)
        url += "?isFinalized=true";
      extrinsicStatusResponse = await client.get(url);
    } catch (_err) {
      if (!import_axios2.default.isAxiosError(_err)) {
        throw _err;
      }
      const err = _err;
      if (err.response?.status === 404) {
        counter += 1;
        if (counter > TIMES_TO_RETRY) {
          throw new Error(`Extrinsic not found in ${(TIMES_TO_RETRY * TIMEOUT / 1e3).toFixed(2)}s`);
        }
        await sleep(TIMEOUT);
      } else {
        throw new ApiError(_err);
      }
    }
  } while (!extrinsicStatusResponse || extrinsicStatusResponse.status !== 200);
  const { data: extrinsicResult } = extrinsicStatusResponse;
  return {
    result: extrinsicResult.result,
    extrinsicOutput: extrinsicResult.extrinsic
  };
};
var getExtrinsicOperations = (client, chainParams) => {
  const buildExtrinsic = getBuildExtrinsic(client, chainParams);
  const encodeExtrinsic = getEncodeExtrinsic(client);
  const extrinsicFee = getExtrinsicFee(client, chainParams);
  const signExtrinsic = getSignExtrinsic(client, chainParams);
  const submitExtrinsic = getSubmitExtrinsic(client);
  const getExtrinsicStatus2 = getExtrinsicStatusCheck(client, chainParams);
  const buildAndSubmitExtrinsic = async (endpointPart, paramsValidator, params, buildOptions, account, getStatusOptions2) => {
    const builtExtrinsic = await buildExtrinsic(endpointPart, paramsValidator, params, buildOptions);
    const signature = await signExtrinsic(builtExtrinsic, account);
    const extrinsicHash = await submitExtrinsic(builtExtrinsic, signature);
    return getExtrinsicStatus2(endpointPart, extrinsicHash, getStatusOptions2);
  };
  const extrinsic = {
    build: buildExtrinsic,
    encode: encodeExtrinsic,
    fee: extrinsicFee,
    sign: signExtrinsic,
    submit: submitExtrinsic,
    getStatus: getExtrinsicStatus2,
    invoke: buildAndSubmitExtrinsic
  };
  const makeExtrinsicFn = (extrinsicSettings) => {
    const { route, schemaIn, schemaOut } = extrinsicSettings;
    const fn = async (...args) => {
      const [params, buildOptions, account, options] = args;
      return buildAndSubmitExtrinsic(route, schemaIn, params, buildOptions, account, options);
    };
    fn.buildAndSubmit = async (...args) => {
      const [params, buildOptions, account, options] = args;
      return buildAndSubmitExtrinsic(route, schemaIn, params, buildOptions, account, options);
    };
    fn.route = route;
    fn.schemaIn = schemaIn;
    fn.schemaOut = schemaOut;
    fn.build = async (...args) => {
      const [params, buildOptions] = args;
      return buildExtrinsic(route, schemaIn, params, buildOptions);
    };
    fn.encode = async (...args) => {
      const [params] = args;
      return encodeExtrinsic(route, schemaIn, params);
    };
    fn.fee = async (...args) => {
      const [params, buildOptions] = args;
      return extrinsicFee(route, schemaIn, params, buildOptions);
    };
    fn.getStatus = getExtrinsicStatus2;
    fn.sign = signExtrinsic;
    fn.submit = submitExtrinsic;
    return fn;
  };
  return { extrinsic, makeExtrinsicFn };
};
var getQueryFn = (client) => (settings) => {
  const { route, schemaIn, schemaOut, method = "GET" } = settings;
  const fn = async (params) => {
    const paramsParseResult = schemaIn.safeParse(params);
    if (!paramsParseResult.success)
      throw paramsParseResult.error.format();
    const parsedParams = paramsParseResult.data;
    try {
      const response = method === "GET" ? await client.get(route, { params: parsedParams }) : await client.post(route, serializeObjectWithBigInt(parsedParams));
      return response.data;
    } catch (e) {
      throw new ApiError(e);
    }
  };
  fn.route = route;
  fn.schemaIn = schemaIn;
  fn.schemaOut = schemaOut;
  return fn;
};
var createAxiosClient = (chainParams) => import_axios2.default.create({
  ...chainParams.axiosConfig,
  baseURL: chainParams.baseUrl,
  paramsSerializer: (params) => import_qs.default.stringify(params, { arrayFormat: "repeat" })
});
var prepareBase = (options) => {
  const client = createAxiosClient(options);
  const makeQueryFn = getQueryFn(client);
  const { extrinsic, makeExtrinsicFn } = getExtrinsicOperations(client, options);
  return { client, makeQueryFn, extrinsic, makeExtrinsicFn };
};
var zAlternativeBatchArgs = import_zod3.z.array(
  import_zod3.z.promise(
    import_zod3.z.object({
      compactExtrinsic: import_zod3.z.string()
    })
  )
).transform(async (promises) => {
  const calls = await Promise.all(promises.map((call) => call.then((c) => c.compactExtrinsic)));
  return { calls };
});

// ../substrate-http-proxy/src/routes/balances.ts
var import_zod8 = require("zod");

// ../validation-schemas/extrinsics.ts
var import_zod5 = require("zod");

// ../validation-schemas/shared.ts
var import_zod4 = require("zod");
var import_address2 = require("@unique-nft/utils/address");
var zSubstrateAddress = import_zod4.z.string().refine((address) => import_address2.Address.is.substrateAddress(address)).openapi({
  description: "Substrate address",
  example: "5DvpvbetLdgBfbb4S5sZ1CCGDWeLDhLmX5WXHd73LjsB2E2v"
});
var zEthereumAddress = import_zod4.z.string().refine((address) => import_address2.Address.is.ethereumAddress(address)).openapi({
  description: "Ethereum address",
  example: "0x52764bbc320189511E826A0a9b4763F104FfC3B0"
});
var zAddressString = import_zod4.z.string().refine((address) => {
  return import_address2.Address.is.validAddressInAnyForm(address);
}).openapi({
  description: "Any Address: Ethereum address or Substrate address or Substrate public key",
  example: "5DvpvbetLdgBfbb4S5sZ1CCGDWeLDhLmX5WXHd73LjsB2E2v",
  minLength: 42,
  maxLength: 66
});
var zWeiString = import_zod4.z.string().openapi({
  description: "The amount in wei",
  example: "1500000000000000000"
});
var zCoinsString = import_zod4.z.string().openapi({
  description: "The amount in coins",
  example: "1.5"
});
var zExtrinsicEraEncoded = import_zod4.z.string().openapi({
  description: "The era for this transaction, in hex",
  example: "0x9503"
});
var zExtrinsicMethodEncoded = import_zod4.z.string().openapi({
  description: "The method for this transaction, in hex",
  example: "0x1e03008ea22863f6d84b1f76e4377c1ba1f6c8bd75b0d3bb5d11c36c0436bdd3110867e5c0"
});
var zSignerPayloadJSON = import_zod4.z.object({
  address: zSubstrateAddress.openapi({
    description: "The address of the signer",
    example: "5DvpvbetLdgBfbb4S5sZ1CCGDWeLDhLmX5WXHd73LjsB2E2v"
  }),
  blockNumber: import_zod4.z.string().openapi({
    description: "The block number of the chain",
    example: "0x000c9c52"
  }),
  era: zExtrinsicEraEncoded,
  method: zExtrinsicMethodEncoded,
  nonce: import_zod4.z.string().openapi({
    description: "The nonce for this transaction, in hex",
    example: "0x00000000"
  }),
  version: import_zod4.z.number(),
  blockHash: import_zod4.z.string().openapi({
    description: "The block hash of the chain",
    example: "0xabb0ec38ebeaeae36dbad82cfb33a8e16b7d18a5f937543d5d80d845ef450329"
  }),
  genesisHash: import_zod4.z.string().openapi({
    description: "The genesis hash of the chain",
    example: "0x49cc5821aa055c3ee9357fe109219230e9ee98792c2e26a0f416233f80a2b5d7"
  }),
  specVersion: import_zod4.z.string().openapi({
    description: "The current spec version for the runtime",
    example: "0x00990bf6"
  }),
  tip: import_zod4.z.string().openapi({
    description: "The tip for this transaction, in hex",
    example: "0x00000000000000000000000000000000"
  }),
  transactionVersion: import_zod4.z.string().openapi({
    description: "The current transaction version for the runtime",
    example: "0x00000003"
  }),
  signedExtensions: import_zod4.z.array(import_zod4.z.string()).openapi({
    description: "The applicable signed extensions for this runtime",
    example: ["CheckSpecVersion", "CheckTxVersion", "CheckGenesis"]
  })
});
var zSignerPayloadRaw = import_zod4.z.object({
  address: zSubstrateAddress.openapi({
    description: "The address of the signer"
  }),
  data: import_zod4.z.string().openapi({
    description: "The raw data of the signer payload, in hex"
  }),
  type: import_zod4.z.string()
});
var zSignerPayloadHex = import_zod4.z.string().openapi({
  description: "The signer payload, in hex"
});
var zUniqueBuildExtrinsicOptions2 = import_zod4.z.object({
  signerAddress: zSubstrateAddress,
  nonce: import_zod4.z.number().optional(),
  mortalLength: import_zod4.z.number().optional()
});

// ../validation-schemas/extrinsics.ts
var zQueryBoolean = import_zod5.z.union([import_zod5.z.string(), import_zod5.z.boolean(), import_zod5.z.number()]).transform((val) => {
  if (typeof val === "string")
    return val.toLowerCase() === "true";
  if (typeof val === "boolean")
    return val;
  return val !== 0;
}).openapi({ description: "Boolean query parameter", type: "boolean" });
var zArgsArray = import_zod5.z.array(import_zod5.z.any()).openapi({
  description: "The arguments to pass to the method",
  example: ["5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL", 777]
});
var zArgsObject = import_zod5.z.object({}).catchall(import_zod5.z.any()).openapi({
  description: "The arguments to pass to the method",
  example: {
    to: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL",
    value: 777
  }
});
var zBuildExtrinsic = import_zod5.z.object({
  signerAddress: zSubstrateAddress,
  section: import_zod5.z.string().openapi({
    description: "The section of the method to call",
    example: "balances"
  }),
  method: import_zod5.z.string().openapi({
    description: "The method to call",
    example: "transferKeepAlive"
  }),
  args: import_zod5.z.union([zArgsArray, zArgsObject]),
  mortalLength: import_zod5.z.number().optional(),
  nonce: import_zod5.z.number().optional()
});
var zEncodeExtrinsic = zBuildExtrinsic.omit({
  signerAddress: true,
  mortalLength: true,
  nonce: true
});
var zCompactExtrinsic = import_zod5.z.object({
  compactExtrinsic: import_zod5.z.string().openapi({
    description: "The encoded compact extrinsic, same as call, but with version and length",
    example: "0x1e03008ea22863f6d84b1f76e4377c1ba1f6c8bd75b0d3bb5d11c36c0436bdd3110867e5c0"
  })
});
var zSignerPayload = import_zod5.z.object({
  signerPayloadJSON: zSignerPayloadJSON,
  signerPayloadRaw: zSignerPayloadRaw,
  signerPayloadHex: zSignerPayloadHex
});
var zSignerPayloadWithCompactExtrinsic = zSignerPayload.extend({
  compactExtrinsic: import_zod5.z.string().openapi({
    description: "The encoded compact extrinsic, same as call, but with version and length",
    example: "0x1e03008ea22863f6d84b1f76e4377c1ba1f6c8bd75b0d3bb5d11c36c0436bdd3110867e5c0"
  })
});
var zSubmitExtrinsic = import_zod5.z.object({
  signerPayloadJSON: zSignerPayloadJSON,
  signature: import_zod5.z.string()
});
var zSubmittedExtrinsic = import_zod5.z.object({
  hash: import_zod5.z.string()
});
var zExtrinsicStatus = import_zod5.z.object({
  hash: import_zod5.z.string(),
  signer: zSubstrateAddress,
  section: import_zod5.z.string(),
  method: import_zod5.z.string(),
  args: import_zod5.z.object({}).catchall(import_zod5.z.any()),
  events: import_zod5.z.array(
    import_zod5.z.object({
      section: import_zod5.z.string(),
      method: import_zod5.z.string(),
      data: import_zod5.z.object({}).catchall(import_zod5.z.any())
    })
  ),
  groupedEvents: import_zod5.z.object({}).catchall(import_zod5.z.object({}).catchall(import_zod5.z.array(import_zod5.z.object({}).catchall(import_zod5.z.any())))),
  blockHash: import_zod5.z.string(),
  blockNumber: import_zod5.z.coerce.string()
}).openapi({
  description: "The status of the extrinsic",
  example: {
    hash: "0xe888db18399714543558de271b1e67c68caad3f2778a9cb45cf03cd72a62735c",
    blockHash: "0xef7d8c3d68fb2f4e551b6d4dac534bf80f78b9137729e4442cc9d72d9798469e",
    blockNumber: "1111969",
    signer: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY",
    section: "balances",
    method: "transferKeepAlive",
    args: {
      to: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY",
      amount: "1500000000000000000"
    },
    events: [
      {
        section: "balances",
        method: "Withdraw",
        data: {
          who: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY",
          amount: "59280745607318347"
        }
      },
      "..."
    ],
    groupedEvents: {
      balances: {
        Withdraw: [
          {
            who: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY",
            amount: "59280745607318347"
          },
          "..."
        ]
      }
    }
  }
});
var getExtrinsicStatus = {
  input: import_zod5.z.object({
    hash: import_zod5.z.string(),
    isFinalized: zQueryBoolean.optional()
  }),
  output: {
    ok: zExtrinsicStatus,
    notFound: import_zod5.z.object({
      error: import_zod5.z.string()
    })
  }
};
var zExtrinsicFee = zBuildExtrinsic;
var zExtrinsicFeeOutput = import_zod5.z.object({
  baseFee: import_zod5.z.coerce.string(),
  lenFee: import_zod5.z.coerce.string(),
  adjustedWeightFee: import_zod5.z.coerce.string(),
  totalFee: import_zod5.z.coerce.string(),
  xcmFee: import_zod5.z.coerce.string()
});
var zErrors = {
  notFound: import_zod5.z.object({ error: import_zod5.z.string() }),
  generic: import_zod5.z.object({
    error: import_zod5.z.string(),
    details: import_zod5.z.any().optional(),
    httpPart: import_zod5.z.string().optional()
  })
};
var zExtrinsicApi = {
  buildInput: zBuildExtrinsic,
  buildOutput: zSignerPayloadWithCompactExtrinsic,
  encodeInput: zEncodeExtrinsic,
  encodeOutput: zCompactExtrinsic,
  extrinsicFeeInput: zExtrinsicFee,
  extrinsicFeeOutput: zExtrinsicFeeOutput,
  submitInput: zSubmitExtrinsic,
  submitOutput: import_zod5.z.object({ hash: import_zod5.z.string() }),
  getStatusInput: import_zod5.z.object({ hash: import_zod5.z.string() }),
  // todo - duplicate with getExtrinsicStatus.input
  getStatusOutput: zExtrinsicStatus
};
var zExtrinsicHash = import_zod5.z.string().trim().toLowerCase().regex(/^0x[0-9a-f]{64}$/).openapi({
  description: "The hash of the extrinsic",
  example: "0x96affcbd6740d3d94b90996aee65b8a3075512c0e8bbedb92e79df0f5d2cad5f"
});

// ../validation-schemas/xcmUtils.ts
var MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);

// ../substrate-http-proxy/src/routes/_types.ts
var ExtrinsicEndpointsConfig = class {
  route;
  tags;
  description;
  extrinsicSection;
  extrinsicMethod;
  schemaIn;
  encodeSchemaIn;
  buildArgsFormatter;
  encodeArgsFormatter;
  schemaOut;
  resultFormatter;
  routeType = "unknown";
  constructor(config) {
    this.route = config.route;
    this.tags = config.tags;
    this.description = config.description;
    this.extrinsicSection = config.extrinsicSection;
    this.extrinsicMethod = config.extrinsicMethod;
    this.schemaIn = config.schemaIn;
    this.buildArgsFormatter = config.buildArgsFormatter;
    this.encodeSchemaIn = config.encodeSchemaIn ?? config.schemaIn;
    this.encodeArgsFormatter = config.encodeArgsFormatter ?? async function(args, client) {
      return config.buildArgsFormatter(args, { signerAddress: "" }, client);
    };
    this.schemaOut = config.schemaOut;
    this.resultFormatter = config.resultFormatter;
    this.routeType = config.routeType || this.routeType;
  }
};
var QueryEndpointConfig = class {
  route;
  method;
  tags;
  description;
  schemaIn;
  schemaOut;
  queryHandler;
  constructor(config) {
    this.route = config.route;
    this.tags = config.tags;
    this.description = config.description;
    this.schemaIn = config.schemaIn;
    this.schemaOut = config.schemaOut;
    this.queryHandler = config.queryHandler;
    this.method = config.method || "GET";
  }
};

// ../substrate-http-proxy/src/schemas/events.ts
var import_zod6 = require("zod");
var import_address3 = require("@unique-nft/utils/address");

// ../../node_modules/coin-format/index.mjs
var DEFAULT_DECIMALS = 18;
var validateDecimals = (decimals) => {
  if (typeof decimals !== "number")
    throw new Error("Invalid decimals, must be a number");
  if (decimals < 1 || decimals > 18)
    throw new Error("Invalid decimals, must be between 0 and 18");
  return true;
};
var weiToCoin = (weiValue, decimals = DEFAULT_DECIMALS) => {
  validateDecimals(decimals);
  const weiBigInt = BigInt(weiValue);
  const divisor = 10n ** BigInt(decimals);
  const ethAmountBigInt = weiBigInt / divisor;
  const remainder = weiBigInt % divisor;
  const remainderStr = remainder.toString().padStart(decimals, "0");
  const formattedRemainder = remainderStr.replace(/0+$/, "");
  const formattedEthAmount = `${ethAmountBigInt}${formattedRemainder.length > 0 ? "." + formattedRemainder : ""}`;
  return formattedEthAmount;
};

// ../substrate-http-proxy/src/schemas/errors.ts
var ApiError2 = class extends Error {
  constructor(message, statusCode = 500, details) {
    super(message);
    this.statusCode = statusCode;
    this.details = details;
  }
};
var NotFoundError = class extends ApiError2 {
  statusCode = 404;
  constructor(message) {
    super(message);
  }
};
var EventNotFoundInExtrinsicError = class extends Error {
  statusCode = 503;
  constructor(extrinsic, event) {
    super(`The extrinsic (hash ${extrinsic.hash}, block ${extrinsic.blockNumber} / ${extrinsic.blockHash}) has no ${event} event`);
  }
};
var ExtrinsicFailedError = class extends Error {
  statusCode = 400;
  constructor(extrinsic, reason) {
    super(`The extrinsic failed for reason ${reason}, (hash ${extrinsic.hash}, block ${extrinsic.blockNumber} / ${extrinsic.blockHash})`);
  }
};

// ../substrate-http-proxy/src/schemas/events.ts
var tryParseDispatchError = (extrinsic, dispatchError, substrateClient) => {
  try {
    const { module: module2 } = JSON.parse(dispatchError);
    if (!module2)
      return null;
    const dispatchErrorModule = substrateClient.registry.createType("DispatchErrorModuleU8a", module2);
    const registryError = substrateClient.registry.findMetaError(dispatchErrorModule);
    const { args, docs, name, section } = registryError;
    const message = docs.join(" ") || "Extrinsic failed with unknown error";
    const details = {
      section,
      name,
      args,
      docs,
      extrinsicHash: extrinsic.hash,
      blockNumber: extrinsic.blockNumber.toString(),
      blockHash: extrinsic.blockHash,
      extrinsicIndex: extrinsic.indexInBlock
    };
    return new ApiError2(message, 400, details);
  } catch (e) {
    console.error(e);
    return null;
  }
};
var genericExtrinsicSuccessProcessor = (extrinsic, substrateClient) => {
  if (extrinsic.groupedEvents.system?.ExtrinsicSuccess)
    return;
  const failedEvent = extrinsic.groupedEvents.system?.ExtrinsicFailed;
  if (failedEvent) {
    const dispatchError = failedEvent?.[0]?.dispatch_error || "Extrinsic failed with unknown error";
    if (substrateClient) {
      const parsedError = tryParseDispatchError(extrinsic, dispatchError, substrateClient);
      if (parsedError)
        throw parsedError;
    }
    throw new ExtrinsicFailedError(extrinsic, dispatchError);
  } else {
    throw new EventNotFoundInExtrinsicError(extrinsic, "system.ExtrinsicSuccess or system.ExtrinsicFailed");
  }
};
var zEventBalancesTransfer = import_zod6.z.object({
  from: zSubstrateAddress,
  to: zSubstrateAddress,
  amountInCoin: import_zod6.z.string().openapi({
    description: "The amount of the transfer in coins",
    example: "1.5"
  }),
  amount: import_zod6.z.string().openapi({
    description: "The amount of the transfer in wei",
    example: "1500000000000000000"
  })
});
var zTransferApprovedEvent = import_zod6.z.object({
  collectionId: import_zod6.z.number().openapi({ description: "The ID of the collection" }),
  tokenId: import_zod6.z.number().openapi({ description: "The ID of the token" }),
  spender: import_zod6.z.string().openapi({ description: "The spender of the token" }),
  amount: import_zod6.z.number().openapi({ description: "The approved amount of the token" })
});
var BalancesEvents = {
  Transfer: {
    schema: zEventBalancesTransfer,
    parseExtrinsic: async (extrinsic, fastify) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const transferEvent = extrinsic.groupedEvents.balances?.Transfer?.[0];
      if (!transferEvent)
        throw new EventNotFoundInExtrinsicError(extrinsic, "balances.Transfer");
      const { tokenDecimals } = fastify.substrateClient.systemProperties;
      const { from, to, amount } = zEventBalancesTransfer.omit({ amountInCoin: true }).parse(transferEvent);
      return {
        from: import_address3.Address.extract.addressNormalized(from),
        to: import_address3.Address.extract.addressNormalized(to),
        amountInCoin: weiToCoin(amount, tokenDecimals),
        amount
      };
    }
  }
};
var zCollectionEventParsed = import_zod6.z.object({
  collectionId: import_zod6.z.number().openapi({ description: "The ID of the created collection" })
});
var factoryParseCollectionEventArg0CollectionId = (eventName) => async (extrinsic) => {
  genericExtrinsicSuccessProcessor(extrinsic);
  const event = extrinsic.groupedEvents?.common?.[eventName];
  if (!event)
    throw new EventNotFoundInExtrinsicError(extrinsic, `common.${eventName}`);
  const collectionIdStr = event[0]?.["0"];
  if (!collectionIdStr)
    throw new EventNotFoundInExtrinsicError(extrinsic, `common.${eventName}[0].0 - cant parse event`);
  const collectionId = parseInt(collectionIdStr, 10);
  if (isNaN(collectionId))
    throw new EventNotFoundInExtrinsicError(extrinsic, `common.${eventName}[0].0 - cant parse event`);
  return {
    collectionId
  };
};
var CollectionEvents = {
  CollectionCreated: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionCreated")
  },
  CollectionPropertySet: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionPropertySet")
  },
  CollectionPropertyDeleted: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionPropertyDeleted")
  },
  CollectionLimitsSet: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionLimitSet")
  },
  CollectionSponsorSet: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionSponsorSet")
  },
  SponsorshipConfirmed: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("SponsorshipConfirmed")
  },
  CollectionOwnerChanged: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionOwnerChanged")
  },
  CollectionAdminAdded: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionAdminAdded")
  },
  CollectionAdminRemoved: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionAdminRemoved")
  },
  CollectionDestroyed: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("CollectionDestroyed")
  },
  PropertyPermissionSet: {
    schema: zCollectionEventParsed,
    parseExtrinsic: factoryParseCollectionEventArg0CollectionId("PropertyPermissionSet")
  }
};
var zItemCreatedEvent = import_zod6.z.object({
  collectionId: import_zod6.z.number().openapi({ description: "The ID of the created collection" }),
  tokens: import_zod6.z.array(
    import_zod6.z.object({
      tokenId: import_zod6.z.number().openapi({ description: "The ID of the created token" }),
      amount: import_zod6.z.number().openapi({ description: `The amount of the created token (for NFTs it's always 1)` }),
      owner: import_zod6.z.string().openapi({ description: "The owner of the token" })
    })
  )
});
var zFungibleItemCreatedEvent = import_zod6.z.object({
  collectionId: import_zod6.z.number().openapi({ description: "The ID of the created collection" }),
  recipient: import_zod6.z.string().openapi({ description: "The owner of the token" }),
  amount: import_zod6.z.number().openapi({ description: `The amount of the created token (for NFTs it's always 1)` })
});
var zItemTransferredEvent = import_zod6.z.object({
  collectionId: import_zod6.z.number().openapi({ description: "The ID of the collection" }),
  tokens: import_zod6.z.array(
    import_zod6.z.object({
      tokenId: import_zod6.z.number().openapi({ description: "The ID of the token" }),
      amount: import_zod6.z.number().openapi({ description: `The amount of the token (for NFTs it's always 1)` }),
      from: import_zod6.z.string().openapi({ description: "The previous owner of the token" }),
      to: import_zod6.z.string().openapi({ description: "The new owner of the token" })
    })
  )
});
var zFungibleItemsTransferredEvent = import_zod6.z.object({
  collectionId: import_zod6.z.number().openapi({ description: "The ID of the collection" }),
  from: import_zod6.z.string().openapi({ description: "The previous owner of the token" }),
  to: import_zod6.z.string().openapi({ description: "The new owner of the token" }),
  amount: import_zod6.z.number().openapi({ description: `The amount of the token (for NFTs it's always 1)` })
});
var zItemDestroyedEvent = zItemCreatedEvent;
var zItemPropertiesSetEvent = import_zod6.z.object({
  collectionId: import_zod6.z.number().openapi({ description: "The ID of the collection" }),
  tokenId: import_zod6.z.number().openapi({ description: "The ID of the token" }),
  keys: import_zod6.z.array(import_zod6.z.string()).openapi({ description: "The keys of the properties" })
});
var zFungibleItemsDestroyedEvent = import_zod6.z.object({
  collectionId: import_zod6.z.number().openapi({ description: "The ID of the collection" }),
  amount: import_zod6.z.coerce.string().openapi({ description: `The amount of the token (for NFTs it's always 1)` }),
  from: import_zod6.z.string().openapi({ description: "The previous owner of the token" })
});
var TokenEvents = {
  ItemCreated: {
    schema: zItemCreatedEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.ItemCreated;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.ItemCreated");
      }
      const collectionId = parseInt(events[0]["0"], 10);
      const tokens = events.map((event) => {
        const tokenId = parseInt(event["1"], 10);
        const owner = import_address3.Address.extract.address(JSON.parse(event["2"]));
        const amount = parseInt(event["3"], 10);
        return { tokenId, owner, amount };
      });
      return {
        collectionId,
        tokens
      };
    }
  },
  FungibleItemsCreated: {
    schema: zItemCreatedEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.ItemCreated;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.ItemCreated");
      }
      const { ["0"]: collectionId, ["2"]: owner, ["3"]: amount } = events[0];
      return {
        collectionId: parseInt(collectionId, 10),
        recipient: import_address3.Address.extract.address(JSON.parse(owner)),
        amount: parseInt(amount, 10)
      };
    }
  },
  ItemTransferred: {
    schema: zItemTransferredEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.Transfer;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.Transfer");
      }
      const collectionId = parseInt(events[0]["0"], 10);
      const tokens = events.map((event) => {
        const tokenId = parseInt(event["1"], 10);
        const from = import_address3.Address.extract.address(JSON.parse(event["2"]));
        const to = import_address3.Address.extract.address(JSON.parse(event["3"]));
        const amount = parseInt(event["4"], 10);
        return { tokenId, from, to, amount };
      });
      return {
        collectionId,
        tokens
      };
    }
  },
  FungibleItemsTransferred: {
    schema: zItemTransferredEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.Transfer;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.Transfer");
      }
      const { ["0"]: collectionId, ["2"]: from, ["3"]: to, ["4"]: amount } = events[0];
      return {
        collectionId: parseInt(collectionId, 10),
        from: import_address3.Address.extract.address(JSON.parse(from)),
        to: import_address3.Address.extract.address(JSON.parse(to)),
        amount: parseInt(amount, 10)
      };
    }
  },
  ItemDestroyed: {
    schema: zItemDestroyedEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.ItemDestroyed;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.ItemDestroyed");
      }
      const collectionId = parseInt(events[0]["0"], 10);
      const tokens = events.map((event) => {
        const tokenId = parseInt(event["1"], 10);
        const owner = import_address3.Address.extract.address(JSON.parse(event["2"]));
        const amount = parseInt(event["3"], 10);
        return { tokenId, owner, amount };
      });
      return {
        collectionId,
        tokens
      };
    }
  },
  FungibleItemsDestroyed: {
    schema: zItemDestroyedEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.ItemDestroyed;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.ItemDestroyed");
      }
      const { ["0"]: collectionId, ["2"]: owner, ["3"]: amount } = events[0];
      return {
        collectionId: parseInt(collectionId, 10),
        from: import_address3.Address.extract.address(JSON.parse(owner)),
        amount: amount.toString()
      };
    }
  },
  ItemPropertiesSet: {
    schema: zItemPropertiesSetEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.TokenPropertySet;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.TokenPropertySet");
      }
      const collectionId = parseInt(events[0]["0"], 10);
      const tokenId = parseInt(events[0]["1"], 10);
      const keys = events.map((event) => event["2"]);
      return {
        collectionId,
        tokenId,
        keys
      };
    }
  },
  TokenPropertiesDeleted: {
    schema: zItemPropertiesSetEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.TokenPropertyDeleted;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.TokenPropertyDeleted");
      }
      const collectionId = parseInt(events[0]["0"], 10);
      const tokenId = parseInt(events[0]["1"], 10);
      const keys = events.map((event) => event["2"]);
      return {
        collectionId,
        tokenId,
        keys
      };
    }
  },
  TransferApproved: {
    schema: zTransferApprovedEvent,
    parseExtrinsic: async (extrinsic) => {
      genericExtrinsicSuccessProcessor(extrinsic);
      const events = extrinsic.groupedEvents?.common?.Approved;
      if (!Array.isArray(events) || !events.length) {
        throw new EventNotFoundInExtrinsicError(extrinsic, "common.Approved");
      }
      const collectionId = parseInt(events[0]["0"], 10);
      const tokenId = parseInt(events[0]["1"], 10);
      const spender = import_address3.Address.extract.address(JSON.parse(events[0]["3"]));
      const amount = parseInt(events[0]["4"], 10);
      return { collectionId, tokenId, spender, amount };
    }
  }
};

// ../substrate-http-proxy/src/schemas/common.ts
var import_zod7 = __toESM(require("zod"));
var zAtBlockHash = import_zod7.default.object({
  atBlockHash: import_zod7.default.string().optional().openapi({ description: "Block hash" })
});
var zHashOrNumber = import_zod7.default.string().transform((value) => {
  if (value.startsWith("0x") && value.length === 66)
    return { hash: value };
  return { number: BigInt(value) };
});
var zAtBlockHashOrNumber = import_zod7.default.object({
  atBlockHashOrNumber: zHashOrNumber.optional()
});
var zVestedItem = import_zod7.default.object({
  start: import_zod7.default.string().openapi({ description: "Number of the block when the vesting starts", example: "123456" }),
  period: import_zod7.default.string().openapi({ description: "The duration of the vesting period", example: "1" }),
  periodCount: import_zod7.default.string().openapi({ description: "The number of periods", example: "1" }),
  perPeriod: import_zod7.default.string().openapi({ description: "The amount per period in coins", example: "1.5" })
});
var zQueryBoolean2 = import_zod7.default.union([import_zod7.default.string(), import_zod7.default.boolean(), import_zod7.default.number()]).transform((val) => {
  if (typeof val === "string")
    return val.toLowerCase() === "true";
  if (typeof val === "boolean")
    return val;
  return val !== 0;
}).openapi({ description: "Boolean query parameter", type: "boolean" });
var zPagination = import_zod7.default.object({
  limit: import_zod7.default.coerce.number().int().min(1).max(1e3).optional().openapi({ description: "Number of items to return, min 1, max 1000", example: 10 }),
  skip: import_zod7.default.coerce.number().int().min(0).optional().openapi({ description: "Number of items to skip, min 0", example: 0 })
});
var zParsedMetadata = import_zod7.default.object({
  data: import_zod7.default.string().nullable(),
  resolved: import_zod7.default.string().nullable(),
  parsed: import_zod7.default.object({
    name: import_zod7.default.string().optional(),
    description: import_zod7.default.string().optional(),
    image: import_zod7.default.string().optional()
  })
});

// ../substrate-http-proxy/src/routes/balances.ts
var transferBalances = new ExtrinsicEndpointsConfig({
  route: "/balances/transfer",
  schemaIn: import_zod8.z.object({
    to: zAddressString,
    amount: import_zod8.z.coerce.string().openapi({ description: "The amount of the transfer in coins or wei (default)", example: "150000" }),
    isAmountInCoins: import_zod8.z.boolean().optional().openapi({
      description: "If true, the value is in coins, otherwise in wei. Default is false",
      example: false
    })
  }),
  schemaOut: BalancesEvents.Transfer.schema
});
var getBalances = new QueryEndpointConfig({
  route: "/balances/get",
  schemaIn: import_zod8.z.object({
    address: zAddressString
  }).merge(zAtBlockHash),
  schemaOut: import_zod8.z.object({
    available: import_zod8.z.string().openapi({
      description: "The amount of the available balance in coins",
      example: "1.5"
    }),
    locked: import_zod8.z.string().openapi({ description: "The amount of the locked balance in wei", example: "1000000000" }),
    free: import_zod8.z.string().openapi({ description: "The amount of the free balance in wei", example: "1000000000" }),
    total: import_zod8.z.string().openapi({ description: "The amount of the total balance in wei", example: "1000000000" }),
    reserved: import_zod8.z.string().openapi({ description: "The amount of the reserved balance in wei", example: "1000000000" }),
    staked: import_zod8.z.string().openapi({ description: "The amount of the staked balance in wei", example: "1000000000" }),
    unstaked: import_zod8.z.string().openapi({ description: "The amount of the unstaked balance in wei", example: "1000000000" }),
    canstake: import_zod8.z.string().openapi({ description: "The amount of the canstake balance in wei", example: "1000000000" }),
    vested: import_zod8.z.array(zVestedItem).optional().openapi({
      description: "The list of the vested balances",
      example: [{ start: "123456", period: "1", periodCount: "1", perPeriod: "1000000000" }]
    }),
    decimals: import_zod8.z.number().openapi({ description: "The number of decimals of the token", example: 18 }),
    tokenSymbol: import_zod8.z.string().openapi({ description: "The token symbol", example: "UNQ" })
  })
});

// ../substrate-http-proxy/src/schemas/collection.ts
var import_zod11 = require("zod");
var import_pure = require("@unique-nft/schemas/pure");
var import_address4 = require("@unique-nft/utils/address");

// ../substrate-http-proxy/src/schemas/input.ts
var import_zod9 = require("zod");
var maxByteValidation = (maxSize) => {
  return (str) => {
    const byteSize = new TextEncoder().encode(str).length;
    if (byteSize > maxSize) {
      return false;
    }
    return true;
  };
};
var zMaxBytesPipe = (maxSize) => {
  return import_zod9.z.string().refine(maxByteValidation(maxSize), `String must not exceed ${maxSize} bytes`);
};

// ../validation-schemas/xcmSchemas.ts
var import_zod10 = require("zod");
var uint8ArraySchema = import_zod10.z.string().regex(/^0x[a-fA-F0-9]+$/);
var zNetworkIdLiteral = import_zod10.z.enum(["polkadot", "kusama", "bitcoinCore", "bitcoinCash", "polkadotBulletin"]);
var zNetworkIdByGenesis = import_zod10.z.object({
  byGenesis: uint8ArraySchema
}).openapi({
  description: "Network ID by genesis",
  example: { byGenesis: "0x0000000000000000000000000000000000000000000000000000000000000000" }
});
var zNetworkId = import_zod10.z.union([zNetworkIdByGenesis, zNetworkIdLiteral]);
var zGlobalConsensus = import_zod10.z.object({
  globalConsensus: zNetworkId
});
var zParachain = import_zod10.z.object({
  parachain: import_zod10.z.number().optional().openapi({ description: "Parachain ID", example: 2037 })
});
var zGeneralIndex = import_zod10.z.object({
  generalIndex: import_zod10.z.number().optional().openapi({ description: "General index", example: 1 })
});
var zPalletInstance = import_zod10.z.object({
  palletInstance: import_zod10.z.number().optional().openapi({ description: "Pallet instance", example: 51 })
});
var zUniversalLocationObject = zGlobalConsensus.merge(zParachain).merge(zGeneralIndex).merge(zPalletInstance);
var zFeeAsset = import_zod10.z.object({
  universalLocation: zUniversalLocationObject,
  decimals: import_zod10.z.number().openapi({ description: "Decimals", example: 18 })
});
var zTransferParams = import_zod10.z.object({
  senderAddress: import_zod10.z.string().openapi({
    description: "Sender address",
    example: "5HWY6cWgaqdov6f2essczduzkBc7yt6mjjbowLJKGMN82KSP"
  }),
  recipientAddress: import_zod10.z.string().optional().openapi({
    description: "Recipient address",
    example: "5HWY6cWgaqdov6f2essczduzkBc7yt6mjjbowLJKGMN82KSP"
  }),
  collectionUniversalLocation: zUniversalLocationObject,
  sourceParachainId: import_zod10.z.number().openapi({ description: "Source parachain ID", example: 1e3 }),
  destinationParachainId: import_zod10.z.number().openapi({ description: "Destination parachain ID", example: 2037 })
});
var zTransferNftParams = zTransferParams.extend({
  itemId: import_zod10.z.number().openapi({ description: "Item ID", example: 2 }),
  feeAsset: zFeeAsset
});
var zTransferFungibleParams = zTransferParams.extend({
  amount: import_zod10.z.number().openapi({ description: "Amount in coins", example: 1.1 }),
  decimals: import_zod10.z.number().openapi({ description: "Decimals", example: 18 }),
  feeAsset: zFeeAsset.optional()
});
var zPreparedTransfer = import_zod10.z.object({
  txHex: import_zod10.z.string(),
  fee: import_zod10.z.string(),
  error: import_zod10.z.string().optional()
});

// ../substrate-http-proxy/src/schemas/collection.ts
var zCollectionIdNumber = import_zod11.z.number().int().min(1).max(2 ** 32 - 1).positive().openapi({
  description: "Collection ID",
  example: 1
});
var zCollectionAddress = import_zod11.z.string().regex(/^0x[0-9a-fA-F]{40}$/).openapi({
  description: "Collection address",
  example: "0x71C7656EC7ab88b098defB751B7401B5f6d8976F"
});
var zCollectionIdString = import_zod11.z.string().regex(/^[1-9]\d*$/).openapi({
  description: "Collection ID",
  example: "1"
});
var zCollectionIdOrAddress = import_zod11.z.union([zCollectionIdNumber, zCollectionAddress, zCollectionIdString]).transform((value) => {
  if (typeof value === "number") {
    import_address4.Address.validate.collectionId(value);
    return value;
  }
  if (import_address4.Address.is.collectionAddress(value)) {
    return import_address4.Address.collection.addressToId(value);
  }
  const numberValue = parseInt(value, 10);
  import_address4.Address.validate.collectionId(numberValue);
  return numberValue;
}).openapi({
  description: "Collection ID (number) or address (in format 0x)"
});
var zCollectionIdQuery = import_zod11.z.object({
  collectionId: zCollectionIdOrAddress
}).merge(zAtBlockHash);
var zCollectionLimits = import_zod11.z.object({
  accountTokenOwnershipLimit: import_zod11.z.number().nullable().optional().openapi({
    description: "Maximum number of tokens that one address can own",
    example: 1e3
  }),
  sponsoredDataSize: import_zod11.z.number().nullable().optional().openapi({
    description: "Maximum byte size of custom token data that can be sponsored when tokens are minted in sponsored mode",
    example: 1024
  }),
  sponsoredDataRateLimit: import_zod11.z.union([import_zod11.z.number(), import_zod11.z.string()]).nullable().optional().openapi({
    description: "Defines how many blocks need to pass between setVariableMetadata transactions in order for them to be sponsored",
    example: 30
  }),
  tokenLimit: import_zod11.z.number().nullable().optional().openapi({
    description: "Total amount of tokens that can be minted in this collection",
    example: 1e6
  }),
  sponsorTransferTimeout: import_zod11.z.number().nullable().optional().openapi({
    description: "Time interval in blocks that defines once per how long a non-privileged user transfer or mint transaction can be sponsored",
    example: 6
  }),
  sponsorApproveTimeout: import_zod11.z.number().nullable().optional().openapi({
    description: "Time interval in blocks that defines once per how long a non-privileged user approve transaction can be sponsored",
    example: 6
  }),
  ownerCanTransfer: import_zod11.z.boolean().nullable().optional().openapi({
    description: "Boolean value that tells if collection owner or admins can transfer or burn tokens owned by other non-privileged users",
    example: false
  }),
  ownerCanDestroy: import_zod11.z.boolean().nullable().optional().openapi({
    description: "Boolean value that tells if collection owner can destroy it",
    example: false
  }),
  transfersEnabled: import_zod11.z.boolean().nullable().optional().openapi({
    description: "Flag that defines whether token transfers between users are currently enabled",
    example: false
  })
});
var zAllCollectionStats = import_zod11.z.object({
  created: import_zod11.z.number().openapi({ description: "Total number of collections created", example: 100 }),
  destroyed: import_zod11.z.number().openapi({ description: "Total number of collections destroyed", example: 10 }),
  alive: import_zod11.z.number().openapi({
    description: "Total number of collections that are created and not destroyed",
    example: 90
  })
});
var zCollectionDecodedSponsorship = import_zod11.z.object({
  isEnabled: import_zod11.z.boolean().openapi({
    description: "Flag that defines whether sponsorship is enabled for this collection",
    example: true
  }),
  isConfirmed: import_zod11.z.boolean().openapi({
    description: "Flag that defines whether sponsorship is confirmed for this collection",
    example: true
  }),
  sponsor: import_zod11.z.string().nullable().openapi({ description: "Address of the sponsor" })
});
var zDecodedProperty = import_zod11.z.object({
  key: import_zod11.z.string().openapi({ description: "The key of the property", example: "my_key" }),
  value: import_zod11.z.string().openapi({ description: "The value of the property", example: "my_value" }),
  valueHex: import_zod11.z.string().openapi({ description: "The value of the property in hex", example: "0x02" })
});
var zPropertiesToEncode = import_zod11.z.array(
  import_zod11.z.union([
    import_zod11.z.object({
      key: import_zod11.z.string().pipe(zMaxBytesPipe(64)),
      value: import_zod11.z.string().pipe(zMaxBytesPipe(32768)),
      valueHex: import_zod11.z.string().pipe(zMaxBytesPipe(32768)).optional()
    }),
    import_zod11.z.object({
      key: import_zod11.z.string().pipe(zMaxBytesPipe(64)),
      value: import_zod11.z.string().pipe(zMaxBytesPipe(32768)).optional(),
      valueHex: import_zod11.z.string().pipe(zMaxBytesPipe(32768))
    })
  ])
);
var zPropertyPermission = import_zod11.z.object({
  mutable: import_zod11.z.boolean().openapi({ description: "Flag that defines whether the property is mutable", example: true }),
  collectionAdmin: import_zod11.z.boolean().openapi({
    description: "Flag that defines whether the property can be changed by collection admin",
    example: true
  }),
  tokenOwner: import_zod11.z.boolean().openapi({
    description: "Flag that defines whether the property can be changed by token owner",
    example: true
  })
});
var zTokenPropertyPermission = import_zod11.z.object({
  key: import_zod11.z.string().pipe(zMaxBytesPipe(256)).openapi({ description: "The key of the property", example: "my_key" }),
  permission: zPropertyPermission
});
var zCollection = import_zod11.z.object({
  collectionId: zCollectionIdNumber,
  collectionAddress: zCollectionAddress,
  owner: import_zod11.z.string().openapi({ description: "The owner of the collection", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  mode: import_zod11.z.enum(["NFT", "Fungible", "ReFungible"]),
  decimals: import_zod11.z.number().nullable().openapi({ description: "The decimals if collection is fungible, null otherwise" }),
  name: import_zod11.z.string().openapi({ description: "The name of the collection", example: "My Collection" }),
  description: import_zod11.z.string().openapi({ description: "The description of the collection", example: "My Collection description" }),
  symbol: import_zod11.z.string().openapi({ description: "The symbol (token prefix) of the collection", example: "MC" }),
  properties: import_zod11.z.array(zDecodedProperty),
  limits: zCollectionLimits.or(import_zod11.z.null()).openapi({ description: "The collection limits" }),
  admins: import_zod11.z.array(zAddressString).or(import_zod11.z.null()).openapi({ description: "The collection admins" }),
  lastTokenId: import_zod11.z.number().or(import_zod11.z.null()).openapi({ description: "The last token ID" }),
  totalSupply: import_zod11.z.number().or(import_zod11.z.null()).openapi({ description: "The total supply (number of minted tokens)" }),
  sponsorship: zCollectionDecodedSponsorship,
  readOnly: import_zod11.z.boolean().openapi({ description: "Flag that defines whether the collection is read only", example: false }),
  tokenPropertyPermissions: import_zod11.z.array(zTokenPropertyPermission),
  permissions: import_zod11.z.object({
    access: import_zod11.z.union([import_zod11.z.literal("Normal"), import_zod11.z.literal("AllowList")]).openapi({ description: "The access mode" }),
    mintMode: import_zod11.z.boolean().openapi({ description: "Flag that defines whether the mint mode is enabled" }),
    nesting: import_zod11.z.object({
      tokenOwner: import_zod11.z.boolean().openapi({ description: "Flag that defines whether the token owner can nest tokens" }),
      collectionAdmin: import_zod11.z.boolean().openapi({ description: "Flag that defines whether the collection admin can nest tokens" }),
      restricted: import_zod11.z.array(import_zod11.z.number()).optional().openapi({ description: "The restricted collection IDs" })
    }).openapi({ description: "The nesting permissions" })
  }),
  info: import_zod11.z.object(import_pure.zCollectionSchema.shape).nullable().openapi({ description: "Collection info" }),
  infoDecodingError: import_zod11.z.string().nullable().openapi({ description: "Error message if decoding of collection info failed" }),
  universalLocation: zUniversalLocationObject.nullable().openapi({ description: "The universal location of the collection" }),
  originalUniversalLocation: zUniversalLocationObject.nullable().openapi({ description: "The universal location of the collection" }),
  isForeign: import_zod11.z.boolean().nullable().openapi({ description: "Flag that defines whether the collection is foreign" }),
  isErc721Metadata: import_zod11.z.boolean().nullable().openapi({ description: "Flag that defines whether the collection is ERC721 metadata compatible" })
});
var zCollectionAccess = import_zod11.z.enum(["Normal", "AllowList"]).openapi({ description: "The access mode", example: "Normal" });
var zCreateCollection = import_zod11.z.object({
  mode: import_zod11.z.enum(["Nft", "Fungible", "ReFungible"]).openapi({ description: "The mode of the collection", example: "Nft" }),
  tokenDecimals: import_zod11.z.coerce.number().int().positive().optional().openapi({ description: "Fungible token decimals", example: 18 }),
  name: import_zod11.z.string().pipe(zMaxBytesPipe(64)).openapi({ description: "The name of the collection", example: "My Collection" }),
  description: import_zod11.z.string().pipe(zMaxBytesPipe(256)).openapi({
    description: "The description of the collection",
    example: "My Collection description"
  }),
  symbol: import_zod11.z.string().optional().pipe(zMaxBytesPipe(16)).openapi({ description: "The symbol of the collection", example: "MC" }),
  access: zCollectionAccess.optional(),
  limits: zCollectionLimits.partial().optional().openapi({ description: "The limits of the collection" }),
  admins: import_zod11.z.array(zAddressString).openapi({ description: "The collection admins" }).optional(),
  permissions: import_zod11.z.object({
    access: zCollectionAccess.optional(),
    nesting: import_zod11.z.object({
      tokenOwner: import_zod11.z.boolean().optional().openapi({
        description: "Flag that defines whether the token owner can be changed",
        example: true
      }),
      collectionAdmin: import_zod11.z.boolean().optional().openapi({
        description: "Flag that defines whether the collection admin can be changed",
        example: true
      }),
      restricted: zCollectionIdOrAddress.array().optional().openapi({ description: "The restricted collection IDs or addresses" })
    }).optional().openapi({ description: "The nesting permissions" }),
    mintMode: import_zod11.z.boolean().optional().openapi({
      description: "Flag that defines whether the mint mode is enabled",
      example: true
    })
  }).optional(),
  pendingSponsor: zAddressString.optional().openapi({ description: "The pending sponsor" }).transform((value) => {
    return typeof value === "string" ? import_address4.Address.extract.crossAccountIdNormalized(value) : void 0;
  }),
  info: import_pure.zCollectionSchema.optional().openapi({ description: "Collection info" }),
  properties: zPropertiesToEncode.optional().openapi({ description: "The properties of the collection" }),
  tokenPropertyPermissions: import_zod11.z.array(zTokenPropertyPermission).optional().openapi({ description: "The token property permissions (collection setting)" })
});

// ../substrate-http-proxy/src/routes/collection.ts
var import_zod12 = require("zod");
var endpointPrefix = "/collection";
var getCollectionById = new QueryEndpointConfig({
  route: `${endpointPrefix}`,
  schemaIn: zCollectionIdQuery.extend({
    withAdmins: zQueryBoolean2.optional().default(true).openapi({
      description: "If true, the admins will be included in the result",
      example: true
    }),
    withLimits: zQueryBoolean2.optional().default(true).openapi({
      description: "If true, the limits will be included in the result",
      example: true
    }),
    withLastTokenId: zQueryBoolean2.optional().default(true).openapi({
      description: "If true, the last token ID will be included in the result",
      example: true
    }),
    withTotalSupply: zQueryBoolean2.optional().default(true).openapi({
      description: "If true, the total supply will be included in the result",
      example: true
    })
  }),
  schemaOut: zCollection
});
var getCollectionsPaginated = new QueryEndpointConfig({
  route: `${endpointPrefix}/list`,
  schemaIn: zPagination,
  schemaOut: import_zod12.z.object({
    collections: import_zod12.z.array(zCollection),
    isLastPage: import_zod12.z.boolean()
  })
});
var getAllCollectionsStats = new QueryEndpointConfig({
  route: `/allCollectionsStats`,
  schemaIn: zAtBlockHash,
  schemaOut: zAllCollectionStats
});
var getAccountTokens = new QueryEndpointConfig({
  route: "/collection/account/tokens",
  schemaIn: zCollectionIdQuery.extend({
    address: zAddressString
  }),
  schemaOut: import_zod12.z.array(
    import_zod12.z.object({
      collectionId: import_zod12.z.number().int().positive(),
      tokenId: import_zod12.z.number().int().positive(),
      originalTokenId: import_zod12.z.number().int().positive().optional()
    })
  )
});
var createCollection = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/create`,
  schemaIn: zCreateCollection,
  schemaOut: zCollection
});
var setCollectionProperties = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/properties/set`,
  schemaIn: import_zod12.z.object({
    collectionId: zCollectionIdOrAddress,
    properties: zPropertiesToEncode
  }),
  schemaOut: zCollection
});
var setTokenPropertyPermissions = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/token-property-permissions`,
  schemaIn: import_zod12.z.object({
    collectionId: zCollectionIdOrAddress,
    tokenPropertyPermissions: import_zod12.z.array(zTokenPropertyPermission)
  }),
  schemaOut: zCollection
});
var deleteCollectionProperties = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/properties/delete`,
  schemaIn: import_zod12.z.object({
    collectionId: zCollectionIdOrAddress,
    keys: import_zod12.z.array(import_zod12.z.string()).min(1)
  }),
  schemaOut: zCollection
});
var setCollectionSponsor = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/sponsor/set`,
  schemaIn: import_zod12.z.object({
    collectionId: zCollectionIdOrAddress,
    sponsor: zSubstrateAddress
  }),
  schemaOut: zCollection
});
var confirmCollectionSponsorship = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/sponsor/confirm`,
  schemaIn: import_zod12.z.object({
    collectionId: zCollectionIdOrAddress
  }),
  schemaOut: zCollection
});
var transferCollection = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/transferCollection`,
  schemaIn: import_zod12.z.object({
    collectionId: zCollectionIdOrAddress,
    to: zAddressString
  }),
  schemaOut: zCollection
});
var setCollectionLimits = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/limits/set`,
  schemaIn: import_zod12.z.object({
    collectionId: zCollectionIdOrAddress,
    limits: zCollectionLimits
  }),
  schemaOut: zCollection
});
var addCollectionAdmin = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/admin/add`,
  schemaIn: import_zod12.z.object({
    collectionId: zCollectionIdOrAddress,
    newAdmin: zAddressString
  }),
  schemaOut: zCollection
});
var removeCollectionAdmin = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/admin/remove`,
  schemaIn: import_zod12.z.object({
    collectionId: zCollectionIdOrAddress,
    adminToDelete: zAddressString
  }),
  schemaOut: zCollection
});
var deleteCollection = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix}/delete`,
  schemaIn: import_zod12.z.object({
    collectionId: zCollectionIdOrAddress
  }),
  schemaOut: import_zod12.z.object({
    collectionId: import_zod12.z.number()
  })
});

// ../substrate-http-proxy/src/routes/token.ts
var import_zod14 = require("zod");

// ../substrate-http-proxy/src/schemas/token.ts
var import_zod13 = require("zod");
var import_schemas = require("@unique-nft/schemas");
var { zTokenSchema } = import_schemas.SchemaTools.tools.schemas;
var zApiQueryTokenId = zAtBlockHash.extend({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  tokenId: import_zod13.z.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  withChildren: zQueryBoolean2.optional().openapi({ description: "If true, the nested tokens will be included in the result", example: false })
});
var zApiResultToken = zTokenSchema.partial().extend({
  tokenId: import_zod13.z.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  collectionId: import_zod13.z.number().int().positive().openapi({ description: "Collection ID", example: 1 }),
  collectionAddress: import_zod13.z.string().openapi({ description: "Collection address" }),
  symbol: import_zod13.z.string().openapi({ description: "Symbol (token prefix)" }),
  owner: import_zod13.z.string().openapi({ description: "Owner address" }),
  parentToken: import_zod13.z.object({
    collectionId: import_zod13.z.number().int().positive().openapi({ description: "Collection ID", example: 1 }),
    tokenId: import_zod13.z.number().int().positive().openapi({ description: "Token ID", example: 1 })
  }).optional().openapi({ description: "Parent token (if the token is nested)" }),
  topmostOwner: import_zod13.z.string().openapi({ description: "Topmost owner address (if the token is nested)" }),
  properties: import_zod13.z.array(zDecodedProperty),
  decodingError: import_zod13.z.string().nullable().openapi({ description: "Error message if decoding failed" })
});
var zTokenURI = import_zod13.z.string().optional().openapi({ description: "The URI of the token, optional param which might be used for special extended ERC721 standards compat" });
var zTokenPossibleActionsQuery = import_zod13.z.object({
  sender: zAddressString.openapi({ description: "Sender address", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  collectionId: import_zod13.z.coerce.number().int().nonnegative().openapi({ description: "Collection ID or address", example: 1 }),
  tokenId: import_zod13.z.coerce.number().int().nonnegative().openapi({ description: "Token ID", example: 1 }),
  transferTo: zAddressString.optional().openapi({ description: "Recipient address, optional" }),
  nestTo: import_zod13.z.object({
    collectionId: import_zod13.z.coerce.number().int().nonnegative(),
    tokenId: import_zod13.z.coerce.number().int().nonnegative()
  }).optional().openapi({ description: "Token nest options, optional" }),
  amount: import_zod13.z.coerce.number().int().nonnegative().optional().default(1).openapi({ description: "Amount of tokens to transfer" })
});
var zApiResultTokenWithChildren = zApiResultToken.extend({
  children: import_zod13.z.array(zApiResultToken).optional().openapi({ description: "Nested tokens" })
});
var zTokenId = import_zod13.z.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  tokenId: import_zod13.z.number().int().positive().openapi({ description: "Token ID", example: 1 })
});
var zNestToken = import_zod13.z.object({
  parent: zTokenId,
  nested: zTokenId,
  from: zAddressString.optional().openapi({ description: 'Sender address (for "transfer from" operations)' }),
  amount: import_zod13.z.number().int().positive().optional().openapi({ description: "Amount of tokens to nest", example: 1 })
});
var zApproveToken = import_zod13.z.object({
  spender: zAddressString,
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  tokenId: import_zod13.z.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  amount: import_zod13.z.number().int().nonnegative().optional().openapi({ description: "Amount of tokens to approve, default is 1", example: 1 })
});
var zUnnestToken = import_zod13.z.object({
  to: zAddressString.optional().openapi({ description: "Recipient address" }),
  nested: zTokenId,
  amount: import_zod13.z.number().int().positive().optional().openapi({ description: "Amount of tokens to transfer (for Fungible and Refungible tokens))", example: 1 })
});

// ../substrate-http-proxy/src/routes/token.ts
var endpointPrefix2 = "/token";
var getToken = new QueryEndpointConfig({
  route: `${endpointPrefix2}`,
  schemaIn: zApiQueryTokenId,
  schemaOut: zApiResultTokenWithChildren
});
var mintNftTokens = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/nfts/mint`,
  schemaIn: import_zod14.z.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokens: import_zod14.z.array(
      import_zod14.z.object({
        data: zTokenSchema.optional().openapi({ description: "Token data" }),
        owner: zAddressString.optional().openapi({ description: "The owner of the token" }),
        URI: zTokenURI,
        properties: zPropertiesToEncode.optional().openapi({ description: "The properties of the token" })
      })
    )
  }),
  schemaOut: import_zod14.z.array(zApiResultToken)
});
var updateNft = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/update`,
  schemaIn: import_zod14.z.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: import_zod14.z.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    data: zTokenSchema.pick({ attributes: true, image: true, image_details: true }).optional().openapi({ description: "Token data" })
  }),
  schemaOut: zApiResultToken
});
var transferTokenFrom = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/transfer-from`,
  schemaIn: import_zod14.z.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: import_zod14.z.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    amount: import_zod14.z.number().int().positive().optional().openapi({ description: "Amount of tokens to transfer (for Fungible and Refungible tokens))", example: 1 }),
    from: zAddressString.optional().openapi({ description: 'Sender address (for "transfer from" operations)' }),
    to: zAddressString.openapi({ description: "Recipient address" })
  }),
  schemaOut: zApiResultToken
});
var burnToken = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/burn`,
  schemaIn: import_zod14.z.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: import_zod14.z.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    amount: import_zod14.z.number().int().positive().optional().openapi({ description: "Amount of tokens to burn (for Fungible and Refungible tokens))", example: 1 })
  }),
  schemaOut: import_zod14.z.object({
    collectionId: import_zod14.z.number().int().positive().openapi({ description: "Collection ID", example: 1 }),
    tokenId: import_zod14.z.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    amount: import_zod14.z.number().int().positive().openapi({ description: "Amount of tokens burned", example: 1 })
  })
});
var burnTokenFrom = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/burn-from`,
  schemaIn: import_zod14.z.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: import_zod14.z.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    from: zAddressString.optional().openapi({ description: 'Token owner address (for "burn from" operations)' }),
    amount: import_zod14.z.number().int().positive().optional().openapi({ description: "Amount of tokens to burn (for Fungible and Refungible tokens))", example: 1 })
  }),
  schemaOut: burnToken.schemaOut
});
var setTokenProperties = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/properties/set`,
  schemaIn: import_zod14.z.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: import_zod14.z.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    properties: zPropertiesToEncode.openapi({ description: "The properties of the token" })
  }),
  schemaOut: zApiResultToken
});
var deleteTokenProperties = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/properties/delete`,
  schemaIn: import_zod14.z.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: import_zod14.z.number().int().positive().openapi({ description: "Token ID", example: 1 }),
    keys: import_zod14.z.array(import_zod14.z.string()).min(1).openapi({ description: "The keys of the properties to delete" })
  }),
  schemaOut: zApiResultToken
});
var nestToken = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/nest`,
  schemaIn: zNestToken,
  schemaOut: zApiResultToken
});
var unnestToken = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/unnest`,
  schemaIn: zUnnestToken,
  schemaOut: zApiResultToken
});
var approveTokenTransfer = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix2}/approve`,
  schemaIn: zApproveToken,
  schemaOut: TokenEvents.TransferApproved.schema
});
var getApproved = new QueryEndpointConfig({
  route: `${endpointPrefix2}/is-approved`,
  schemaIn: import_zod14.z.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: import_zod14.z.coerce.number().int().nonnegative().openapi({ description: "Token ID", example: 1 }),
    sender: zAddressString.optional().openapi({ description: "Owner address" }),
    spender: zAddressString.openapi({ description: "Spender address" })
  }),
  schemaOut: import_zod14.z.object({
    isApproved: import_zod14.z.boolean().openapi({ description: "Is token approved for transfer (or burn)", example: true }),
    amount: import_zod14.z.string().openapi({ description: "Approved amount in decimal string", example: "1" })
  })
});
var getTokenPossibleActions = new QueryEndpointConfig({
  route: `${endpointPrefix2}/possible-actions`,
  schemaIn: zTokenPossibleActionsQuery,
  schemaOut: import_zod14.z.object({
    burn: import_zod14.z.boolean().openapi({ description: "Is token burn possible", example: true }),
    nest: import_zod14.z.boolean().openapi({ description: "Is token nesting possible", example: true }),
    unnest: import_zod14.z.boolean().openapi({ description: "Is token unnesting possible", example: true }),
    transfer: import_zod14.z.boolean().openapi({ description: "Is token transfer possible", example: true }),
    changeProperties: import_zod14.z.array(import_zod14.z.string()).openapi({ description: "List of properties that can be changed", example: ["key1", "key2"] })
  })
});

// ../substrate-http-proxy/src/routes/fungible.ts
var import_zod16 = require("zod");

// ../substrate-http-proxy/src/schemas/fungible.ts
var import_zod15 = require("zod");
var zMintFungibleTokens = import_zod15.z.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  recipient: zAddressString.optional(),
  amount: import_zod15.z.coerce.string().openapi({ example: "150000", type: ["string", "number", "integer"] })
});
var zMintFungibleTokenResult = zMintFungibleTokens.extend({
  collectionId: import_zod15.z.number().int().positive().openapi({ description: "Collection ID", example: 1 })
});
var zTransferFungibleTokens = import_zod15.z.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  from: zAddressString.optional().openapi({ description: 'Sender address (for "transfer from" operations)' }),
  to: zAddressString.openapi({ description: "Recipient address", example: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY" }),
  amount: import_zod15.z.coerce.string().openapi({ example: "150000", type: ["string", "number", "integer"] })
});
var zTransferFungibleTokensResult = zTransferFungibleTokens.extend({
  collectionId: import_zod15.z.number().int().positive().openapi({ description: "Collection ID", example: 1 })
});
var zBurnFungibleTokens = import_zod15.z.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  from: zAddressString.optional().openapi({ description: 'Token owner address (for "burn from" operations)' }),
  amount: import_zod15.z.coerce.string().openapi({ example: "150000", type: ["string", "number", "integer"] })
});
var zBurnFungibleTokensResult = zBurnFungibleTokens.extend({
  collectionId: import_zod15.z.number().int().positive().openapi({ description: "Collection ID", example: 1 })
});
var zApproveFungibleTokens = import_zod15.z.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  sender: zAddressString.optional().openapi({ description: "Sender address", example: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY" }),
  spender: zAddressString.openapi({ description: "Spender address", example: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY" }),
  amount: import_zod15.z.coerce.string().openapi({ example: "150000", type: ["string", "number", "integer"] })
});
var zApproveFungibleTokensResult = zApproveFungibleTokens.omit({ sender: true }).extend({
  collectionId: import_zod15.z.number().int().positive().openapi({ description: "Collection ID", example: 1 })
});

// ../substrate-http-proxy/src/routes/fungible.ts
var endpointPrefix3 = "/fungible";
var mintTokens = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix3}/mint`,
  schemaIn: zMintFungibleTokens,
  schemaOut: zMintFungibleTokenResult
});
var transferTokensFrom = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix3}/transfer-from`,
  schemaIn: zTransferFungibleTokens,
  schemaOut: zTransferFungibleTokensResult
});
var burnTokens = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix3}/burn`,
  schemaIn: zBurnFungibleTokens.omit({ from: true }),
  schemaOut: zBurnFungibleTokensResult
});
var burnTokensFrom = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix3}/burn-from`,
  schemaIn: zBurnFungibleTokens,
  schemaOut: zBurnFungibleTokensResult
});
var approveTokens = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix3}/approve`,
  schemaIn: zApproveFungibleTokens,
  schemaOut: zApproveFungibleTokensResult
});
var getAccountBalance = new QueryEndpointConfig({
  route: `${endpointPrefix3}/balance`,
  schemaIn: import_zod16.z.object({
    address: zAddressString,
    collectionId: zCollectionIdOrAddress
  }),
  schemaOut: import_zod16.z.object({
    address: zAddressString,
    collectionId: import_zod16.z.number().int().positive().openapi({ description: "Collection ID", example: 1 }),
    balance: import_zod16.z.string().openapi({ description: "Balance of the account", example: "100" }),
    decimals: import_zod16.z.number().int().positive().openapi({ description: "Decimals of the fungible token", example: 18 }),
    symbol: import_zod16.z.string().openapi({ description: "Symbol of the fungible token", example: "DOT" })
  })
});
var getAccountAllowance = new QueryEndpointConfig({
  route: `${endpointPrefix3}/allowance`,
  schemaIn: import_zod16.z.object({
    sender: zAddressString,
    spender: zAddressString,
    collectionId: zCollectionIdOrAddress
  }),
  schemaOut: import_zod16.z.object({
    allowance: import_zod16.z.number().openapi({ description: "Allowance of the account", example: 100 }),
    address: zAddressString,
    collectionId: import_zod16.z.number().int().positive().openapi({ description: "Collection ID", example: 1 }),
    sender: zAddressString
  })
});
var getCollectionTotalSupply = new QueryEndpointConfig({
  route: `${endpointPrefix3}/total-supply`,
  schemaIn: import_zod16.z.object({
    collectionId: zCollectionIdOrAddress
  }),
  schemaOut: import_zod16.z.object({
    totalSupply: import_zod16.z.number().openapi({ description: "Total supply of the collection", example: 100 })
  })
});

// ../substrate-http-proxy/src/routes/evm/deploy.ts
var import_zod17 = require("zod");

// ../substrate-http-proxy/src/routes/evm/constants.ts
var tags = ["EVM"];
var endpointPrefix4 = "/evm";

// ../substrate-http-proxy/src/routes/evm/deploy.ts
var zEvmDeployArgs = import_zod17.z.object({
  bytecode: import_zod17.z.string().regex(/^0x[0-9a-fA-F]*$/, { message: "Bytecode of the contract, must start with 0x" }),
  value: import_zod17.z.coerce.bigint().optional().openapi({ description: "Value to send with the transaction", type: "string" }),
  gasLimit: import_zod17.z.coerce.bigint().optional().openapi({ description: "Gas limit for the transaction", type: "string" }),
  maxFeePerGas: import_zod17.z.coerce.bigint().optional().openapi({ description: "Maximum fee per gas", type: "string" }),
  maxPriorityFeePerGas: import_zod17.z.coerce.bigint().optional().openapi({ description: "Maximum priority fee per gas", type: "string" }),
  nonce: import_zod17.z.number().optional().openapi({ description: "Nonce of the transaction" }),
  accessList: import_zod17.z.array(zEthereumAddress).optional().openapi({ description: "Access list" }),
  source: import_zod17.z.string().optional().openapi({ description: "Source address" })
});
var contractExistsRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/contract/exists`,
  schemaIn: import_zod17.z.object({
    address: zEthereumAddress
  }),
  schemaOut: import_zod17.z.object({
    exists: import_zod17.z.boolean().openapi({ description: "Flag that defines whether the contract exists" })
  })
});
var contractDeployRoute = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix4}/contract/deploy`,
  schemaIn: zEvmDeployArgs,
  schemaOut: import_zod17.z.object({
    contractAddress: import_zod17.z.string().openapi({ description: "Address of the created contract" })
  })
});

// ../substrate-http-proxy/src/routes/evm/call.ts
var import_zod19 = require("zod");

// ../substrate-http-proxy/src/schemas/evm/abi.ts
var import_zod18 = __toESM(require("zod"));
var zBaseAbiInput = import_zod18.default.object({
  name: import_zod18.default.string().optional(),
  type: import_zod18.default.string(),
  internalType: import_zod18.default.string().optional(),
  indexed: import_zod18.default.boolean().optional()
});
var zAbiInput = zBaseAbiInput.extend({
  components: import_zod18.default.lazy(() => zAbiInput.array()).optional().openapi({ type: "array" })
});
var zAbiItem = import_zod18.default.object({
  name: import_zod18.default.string().optional(),
  inputs: zAbiInput.array().optional(),
  outputs: zAbiInput.array().optional(),
  stateMutability: import_zod18.default.string().optional(),
  type: import_zod18.default.string(),
  payable: import_zod18.default.boolean().optional(),
  constant: import_zod18.default.boolean().optional()
});
var zAbi = zAbiItem.array();

// ../substrate-http-proxy/src/routes/evm/call.ts
var zEvmCallBodyBase = import_zod19.z.object({
  functionName: import_zod19.z.string().openapi({ description: "Name of the function to call" }),
  functionArgs: import_zod19.z.array(import_zod19.z.any()).openapi({ description: "Arguments of the function" }),
  senderAddress: import_zod19.z.string().optional().openapi({ description: "Address of the sender" }),
  gasPrice: import_zod19.z.coerce.bigint().optional().openapi({ description: "Gas price for the transaction", type: "string" }),
  gasLimit: import_zod19.z.coerce.bigint().optional().openapi({ description: "Gas limit for the transaction", type: "string" }),
  value: import_zod19.z.coerce.bigint().optional().openapi({ description: "The amount of the transfer in wei", type: "string" }),
  blockNumber: import_zod19.z.coerce.bigint().optional().openapi({
    description: "Block number to execute the transaction",
    type: "string"
  })
});
var zEvmCallBody = zEvmCallBodyBase.extend({
  contract: import_zod19.z.object({
    address: import_zod19.z.string().openapi({ description: "Address of the contract" }),
    abi: zAbi
  })
});
var zEvmCallBodyKnownContract = zEvmCallBody.extend({
  contract: import_zod19.z.object({
    address: import_zod19.z.string().openapi({ description: "Address of the contract" })
  })
});
var unknownContractCall = new QueryEndpointConfig({
  route: `${endpointPrefix4}/contract/call`,
  schemaIn: zEvmCallBody,
  schemaOut: import_zod19.z.any(),
  method: "POST"
});
var collectionHelpersCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/collection-helpers/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyBase,
  schemaOut: unknownContractCall.schemaOut
});
var contractHelpersCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/contract-helpers/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyBase,
  schemaOut: unknownContractCall.schemaOut
});
var uniqueNftCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/unique-nft/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyKnownContract,
  schemaOut: unknownContractCall.schemaOut
});
var uniqueFungibleCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/unique-fungible/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyKnownContract,
  schemaOut: unknownContractCall.schemaOut
});
var uniqueRefungibleCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/unique-refungible/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyKnownContract,
  schemaOut: unknownContractCall.schemaOut
});
var uniqueNativeFungibleCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/unique-native-fungible/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyKnownContract,
  schemaOut: unknownContractCall.schemaOut
});
var uniqueRefungibleTokenCallRoute = new QueryEndpointConfig({
  route: `${endpointPrefix4}/unique-refungible-token/call`,
  method: unknownContractCall.method,
  schemaIn: zEvmCallBodyKnownContract,
  schemaOut: unknownContractCall.schemaOut
});

// ../substrate-http-proxy/src/routes/evm/send.ts
var import_zod20 = require("zod");
var zEvmSend = import_zod20.z.object({
  functionName: import_zod20.z.string(),
  functionArgs: import_zod20.z.array(import_zod20.z.any()),
  contract: import_zod20.z.object({
    address: import_zod20.z.string().openapi({ description: "Address of the contract" }),
    abi: zAbi
  }),
  value: import_zod20.z.coerce.bigint().optional().openapi({ description: "The amount of the transfer in wei", type: "string" }),
  gasLimit: import_zod20.z.coerce.bigint().optional().openapi({ description: "Gas limit for the transaction", type: "string" }),
  maxFeePerGas: import_zod20.z.coerce.bigint().optional().openapi({ description: "Maximum fee per gas", type: "string" }),
  maxPriorityFeePerGas: import_zod20.z.coerce.bigint().optional().openapi({
    description: "Maximum priority fee per gas",
    type: "string"
  }),
  source: import_zod20.z.string().optional().openapi({ description: "Source address" })
});
var zEvmSendKnownContractAbi = zEvmSend.extend({
  contract: import_zod20.z.object({
    address: import_zod20.z.string().openapi({ description: "Address of the contract" })
  })
});
var unknownContractSendRoute = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix4}/contract/send`,
  schemaIn: zEvmSend,
  schemaOut: import_zod20.z.object({
    isSuccessful: import_zod20.z.boolean().nullable()
  })
});
var collectionHelpersSendRoute = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix4}/collection-helpers/send`,
  schemaOut: unknownContractSendRoute.schemaOut,
  schemaIn: zEvmSend.omit({ contract: true })
});
var contractHelpersSendRoute = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix4}/contract-helpers/send`,
  schemaIn: zEvmSend.omit({ contract: true }),
  schemaOut: unknownContractSendRoute.schemaOut
});
var uniqueNftSendRoute = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix4}/unique-nft/send`,
  schemaOut: unknownContractSendRoute.schemaOut,
  schemaIn: zEvmSendKnownContractAbi
});
var uniqueFungibleSendRoute = new ExtrinsicEndpointsConfig({
  schemaOut: unknownContractSendRoute.schemaOut,
  route: `${endpointPrefix4}/unique-fungible/send`,
  schemaIn: zEvmSendKnownContractAbi
});
var uniqueRefungibleSendRoute = new ExtrinsicEndpointsConfig({
  schemaOut: unknownContractSendRoute.schemaOut,
  route: `${endpointPrefix4}/unique-refungible/send`,
  schemaIn: zEvmSendKnownContractAbi
});
var uniqueNativeFungibleSendRoute = new ExtrinsicEndpointsConfig({
  schemaOut: unknownContractSendRoute.schemaOut,
  route: `${endpointPrefix4}/unique-native-fungible/send`,
  schemaIn: zEvmSendKnownContractAbi
});
var uniqueRefungibleTokenSendRoute = new ExtrinsicEndpointsConfig({
  schemaOut: unknownContractSendRoute.schemaOut,
  route: `${endpointPrefix4}/unique-refungible-token/send`,
  schemaIn: zEvmSendKnownContractAbi
});

// ../substrate-http-proxy/src/routes/evm/parseLogs.ts
var import_zod21 = require("zod");

// ../substrate-http-proxy/src/utils/evm/evmUtils.ts
var import_address5 = require("@unique-nft/utils/address");
var fixBigint = (input) => {
  const asString = JSON.stringify(input, (_, value) => typeof value === "bigint" ? value.toString() : value);
  return JSON.parse(asString);
};

// ../substrate-http-proxy/src/routes/evm/parseLogs.ts
var zEvmParseLogs = import_zod21.z.object({
  hash: import_zod21.z.string().openapi({ description: "Hash of the extrinsic" }),
  isFinalized: import_zod21.z.boolean().optional().openapi({ description: "Is the block with the extrinsic finalized" }),
  abi: zAbi
});
var zEvmLogEventData = import_zod21.z.object({
  address: import_zod21.z.string().openapi({ description: "Address of the contract" }),
  topics: import_zod21.z.array(import_zod21.z.string()).openapi({ description: "Topics of the log" }),
  data: import_zod21.z.string().openapi({ description: "Data of the log" })
});
var getEvmLogs = (extrinsic) => {
  const rawLogs = extrinsic.groupedEvents.evm?.Log || [];
  const logs = [];
  for (const { log } of rawLogs) {
    const parsed = zEvmLogEventData.safeParse(JSON.parse(log));
    if (parsed.success)
      logs.push(parsed.data);
  }
  return logs;
};
var unknownContractParseLogsConfig = {
  tags,
  route: `${endpointPrefix4}/contract/logs`,
  schemaIn: zEvmParseLogs,
  schemaOut: import_zod21.z.object({
    logs: import_zod21.z.array(import_zod21.z.any()).openapi({ description: "Decoded logs" })
  }),
  method: "POST",
  queryHandler: async (fastify, query) => {
    const { extrinsicsStorage } = fastify;
    const { hash, abi, isFinalized } = query;
    const extrinsic = await extrinsicsStorage.getExtrinsic(hash, isFinalized);
    if (!extrinsic)
      throw new NotFoundError(`Extrinsic with hash ${hash} not found`);
    const contractInterface = new (void 0).Interface(abi);
    const rawLogs = getEvmLogs(extrinsic);
    const logs = [];
    for (const rawLog of rawLogs) {
      const log = contractInterface.parseLog(rawLog);
      if (!log)
        continue;
      const { name, signature, args } = log;
      logs.push(fixBigint({ name, signature, args }));
    }
    return { logs };
  }
};
var contractLogsRoute = new QueryEndpointConfig(unknownContractParseLogsConfig);

// ../substrate-http-proxy/src/routes/batch.ts
var import_zod22 = require("zod");
var zBatchResultParsedExtrinsic = import_zod22.z.object({
  args: import_zod22.z.object({
    calls: import_zod22.z.array(
      import_zod22.z.object({
        callIndex: import_zod22.z.string().startsWith("0x"),
        args: import_zod22.z.any()
      })
    )
  })
});
var batchAll = new ExtrinsicEndpointsConfig({
  route: "/utility/batch-all",
  schemaIn: import_zod22.z.object({
    calls: import_zod22.z.array(import_zod22.z.string()).openapi({ description: "The list of encoded calls to execute" })
  }),
  schemaOut: import_zod22.z.object({
    isSuccess: import_zod22.z.boolean(),
    calls: import_zod22.z.array(
      import_zod22.z.object({
        callIndex: import_zod22.z.string().startsWith("0x"),
        name: import_zod22.z.string(),
        args: import_zod22.z.any()
      })
    )
  })
});

// ../substrate-http-proxy/src/routes/system.ts
var import_zod23 = require("zod");
var getAccountNextIndex = new QueryEndpointConfig({
  route: "/accounts/next_index",
  schemaIn: import_zod23.z.object({ address: zAddressString }),
  schemaOut: import_zod23.z.object({
    nextIndex: import_zod23.z.number().openapi({ description: "The next index of the account" })
  })
});

// ../substrate-http-proxy/src/schemas/refungible.ts
var import_zod24 = require("zod");
var zRefungibleTokenQuery = import_zod24.z.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "The ID of the collection.", example: 1 }),
  tokenId: import_zod24.z.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 })
});
var zRefungibleToken = import_zod24.z.object({
  tokenId: import_zod24.z.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  collectionId: import_zod24.z.number().int().positive().openapi({ description: "Collection ID", example: 1 }),
  owners: import_zod24.z.array(zAddressString.openapi({ description: "The owner of the token.", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })),
  pieces: import_zod24.z.number().positive().openapi({ description: "The number of pieces in the token.", example: 1e4 }),
  properties: import_zod24.z.array(zDecodedProperty)
});
var zRefungibleAccountBalanceQuery = import_zod24.z.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "The ID of the collection.", example: 1 }),
  tokenId: import_zod24.z.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  account: zAddressString.openapi({ description: "The owner of the token.", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })
});
var zRefungibleAccountBalance = zRefungibleAccountBalanceQuery.extend({
  collectionId: import_zod24.z.number().int().positive().openapi({ description: "The ID of the collection.", example: 1 }),
  balance: import_zod24.z.number().openapi({ description: "The number of pieces in the token.", example: 1e4 })
});
var zMintRefungibleToken = import_zod24.z.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "The ID of the collection.", example: 1 }),
  owners: import_zod24.z.array(
    import_zod24.z.object({
      address: zAddressString.optional(),
      pieces: import_zod24.z.number().int().positive().openapi({ description: "The number of pieces in the token.", example: 1e4 })
    })
  ).openapi({ description: "The owners of the token.", example: [{ address: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL", pieces: 1e4 }] }),
  properties: zPropertiesToEncode.optional().openapi({ description: "The properties of the token" }),
  URI: zTokenURI,
  data: zTokenSchema.optional().openapi({ description: "Token data" })
});
var zMintMultipleRefungibleTokens = import_zod24.z.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "The ID of the collection.", example: 1 }),
  tokens: import_zod24.z.array(
    import_zod24.z.object({
      owner: zAddressString.optional().openapi({ description: "The owner of the token.", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
      data: zTokenSchema.optional().openapi({ description: "Token data" }),
      pieces: import_zod24.z.number().int().positive().openapi({ description: "The number of pieces in the token.", example: 1e4 }),
      properties: zPropertiesToEncode.optional().openapi({ description: "The properties of the token" }),
      URI: zTokenURI
    })
  )
});
var zTransferRefungibleToken = import_zod24.z.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "The ID of the collection.", example: 1 }),
  from: zAddressString.optional().openapi({ description: "The address of the sender.", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  to: zAddressString.openapi({ description: "The address of the recipient.", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  tokenId: import_zod24.z.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  pieces: import_zod24.z.number().int().positive().openapi({ description: "The number of pieces in the token.", example: 1e4 })
});
var zBurnRefungibleToken = import_zod24.z.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "The ID of the collection.", example: 1 }),
  tokenId: import_zod24.z.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  from: zAddressString.optional().openapi({ description: "The address of the sender.", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  pieces: import_zod24.z.number().int().positive().openapi({ description: "The number of pieces in the token.", example: 5e3 })
});
var zBurnRefungibleTokenResult = import_zod24.z.object({
  collectionId: import_zod24.z.number().int().positive().openapi({ description: "The ID of the collection.", example: 1 }),
  tokenId: import_zod24.z.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  pieces: import_zod24.z.number().int().positive().openapi({ description: "The number of pieces in the token.", example: 5e3 })
});
var zUpdateRefungibleToken = import_zod24.z.object({
  collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
  tokenId: import_zod24.z.number().int().positive().openapi({ description: "Token ID", example: 1 }),
  data: zTokenSchema.pick({ attributes: true, image: true, image_details: true }).optional().openapi({ description: "Token data" })
});

// ../substrate-http-proxy/src/routes/refungible.ts
var import_zod25 = require("zod");
var endpointPrefix5 = "/refungible";
var getRefungibleToken = new QueryEndpointConfig({
  route: `${endpointPrefix5}`,
  method: "GET",
  schemaIn: zRefungibleTokenQuery,
  schemaOut: zRefungibleToken
});
var getRefungibleAccountBalance = new QueryEndpointConfig({
  route: `${endpointPrefix5}/account-balance`,
  method: "GET",
  schemaIn: zRefungibleAccountBalanceQuery,
  schemaOut: zRefungibleAccountBalance
});
var mintRefungibleToken = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix5}/mint`,
  schemaIn: zMintRefungibleToken,
  schemaOut: zRefungibleToken
});
var mintRefungibleTokens = new ExtrinsicEndpointsConfig({
  route: `${endpointPrefix5}/mint-multiple`,
  schemaIn: zMintMultipleRefungibleTokens,
  schemaOut: import_zod25.z.array(zRefungibleToken)
});

// ../substrate-http-proxy/src/routes/utils.ts
var import_zod26 = require("zod");
var getTokenParsedMetadata = new QueryEndpointConfig({
  route: "/utils/parsed-metadata",
  schemaIn: import_zod26.z.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: import_zod26.z.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 })
  }),
  schemaOut: zParsedMetadata
});

// ../substrate-http-proxy/src/routes/palletNfts/collection.ts
var import_zod29 = require("zod");

// ../substrate-http-proxy/src/schemas/palletNfts/collection.ts
var import_zod28 = require("zod");

// ../substrate-http-proxy/src/schemas/palletNfts/attributes.ts
var import_zod27 = require("zod");
var AttributeNamespaceEnum = /* @__PURE__ */ ((AttributeNamespaceEnum2) => {
  AttributeNamespaceEnum2["pallet"] = "pallet";
  AttributeNamespaceEnum2["collectionOwner"] = "collectionOwner";
  AttributeNamespaceEnum2["itemOwner"] = "itemOwner";
  return AttributeNamespaceEnum2;
})(AttributeNamespaceEnum || {});
var zAttributeNamespace = import_zod27.z.union([import_zod27.z.nativeEnum(AttributeNamespaceEnum), zSubstrateAddress]).openapi({ description: "Namespace, which can be either a named namespace or an account address" });
var zAttribute = import_zod27.z.object({
  key: import_zod27.z.string().openapi({ description: "Attribute key" }),
  value: import_zod27.z.string().openapi({ description: "Attribute value" }),
  namespace: zAttributeNamespace
});
var zGetAttributesQuery = import_zod27.z.object({
  collectionId: import_zod27.z.coerce.number().nonnegative(),
  itemId: import_zod27.z.coerce.number().nonnegative().optional(),
  namespace: zAttributeNamespace
});
var zGetAttributeQuery = zGetAttributesQuery.extend({
  key: import_zod27.z.string().openapi({ description: "Attribute key" })
});

// ../substrate-http-proxy/src/schemas/palletNfts/collection.ts
var zNftsCollectionId = import_zod28.z.object({
  collectionId: import_zod28.z.coerce.number().openapi({ description: "Collection ID", example: 1 })
});
var zPalletNftsCollectionQuery = import_zod28.z.object({
  collectionId: import_zod28.z.coerce.number().int().nonnegative().openapi({ description: "Collection ID", example: 1 })
}).merge(zAtBlockHash);
var zNftsCollectionSettings = import_zod28.z.object({
  lockedTransferItems: import_zod28.z.boolean().openapi({ description: "Locked transfer items", example: false }),
  lockedMetadata: import_zod28.z.boolean().openapi({ description: "Locked metadata", example: false }),
  lockedAttributes: import_zod28.z.boolean().openapi({ description: "Locked attributes", example: false }),
  lockedMaxSupply: import_zod28.z.boolean().openapi({ description: "Locked max supply", example: false })
});
var zMintType = import_zod28.z.union([import_zod28.z.literal("Issuer"), import_zod28.z.literal("Public"), import_zod28.z.object({ holderOf: import_zod28.z.number() })]);
var zNftsItemSettings = import_zod28.z.object({
  lockedTransfers: import_zod28.z.boolean().openapi({ description: "Locked transfers", example: false }),
  lockedMetadata: import_zod28.z.boolean().openapi({ description: "Locked metadata", example: false }),
  lockedAttributes: import_zod28.z.boolean().openapi({ description: "Locked attributes", example: false })
});
var zNftsMintSettings = import_zod28.z.object({
  mintType: zMintType.openapi({ description: "Mint type", example: "Issuer" }),
  price: import_zod28.z.string().or(import_zod28.z.number()).nullable().openapi({ description: "Price", example: "1000000000000000000000" }),
  startBlock: import_zod28.z.number().nullable().openapi({ description: "Start block", example: 1 }),
  endBlock: import_zod28.z.number().nullable().openapi({ description: "End block", example: 1 }),
  defaultItemSettings: zNftsItemSettings.partial().optional().openapi({ description: "Default item settings" })
});
var zNftsCreateCollectionConfig = import_zod28.z.object({
  settings: zNftsCollectionSettings.optional().openapi({ description: "Collection settings" }),
  maxSupply: import_zod28.z.number().optional().openapi({ description: "Max supply", example: 100 }),
  mintSettings: zNftsMintSettings.partial().optional().openapi({ description: "Mint settings" })
});
var zNftsCollectionCreateArguments = import_zod28.z.object({
  admin: zAddressString.optional(),
  collectionConfig: zNftsCreateCollectionConfig.optional().openapi({ description: "Collection config" })
});
var zCollectionCreateResult = import_zod28.z.object({
  collectionId: import_zod28.z.number().openapi({ description: "Collection ID", example: 1 }),
  creator: import_zod28.z.string().openapi({ description: "Creator", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  owner: import_zod28.z.string().openapi({ description: "Owner", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })
});
var zNftsCollectionConfig = import_zod28.z.object({
  settings: zNftsCollectionSettings.optional().openapi({ description: "Collection settings" }),
  maxSupply: import_zod28.z.number().nullable().openapi({ description: "Max supply", example: 100 }),
  mintSettings: zNftsMintSettings.partial().optional().openapi({ description: "Mint settings" })
});
var zNftsCollectionRole = import_zod28.z.object({
  issuer: import_zod28.z.boolean(),
  admin: import_zod28.z.boolean(),
  freezer: import_zod28.z.boolean()
});
var zNftsCollectionLockResult = zNftsCollectionId.extend({});
var zNftsCollectionMetadata = import_zod28.z.object({
  deposit: import_zod28.z.string(),
  data: import_zod28.z.string()
});
var zNftsCollectionDetails = import_zod28.z.object({
  collectionId: import_zod28.z.number().openapi({ description: "The ID of the collection", example: 0 }),
  owner: import_zod28.z.string().openapi({ description: "The owner of the collection", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  ownerDeposit: import_zod28.z.number().openapi({ description: "The owner deposit" }),
  items: import_zod28.z.number().openapi({ description: "The number of items" }),
  itemMetadatas: import_zod28.z.number().openapi({ description: "The number of item metadatas" }),
  itemConfigs: import_zod28.z.number().openapi({ description: "The number of item configs" }),
  attributes: import_zod28.z.array(zAttribute).openapi({ description: "Attributes of the collection" }),
  metadata: zNftsCollectionMetadata.nullable().openapi({ description: "The collection metadata" }),
  config: zNftsCollectionConfig.openapi({ description: "The collection config" }),
  universalLocation: zUniversalLocationObject.nullable(),
  isForeign: import_zod28.z.boolean().optional().openapi({ description: "Is foreign collection" }),
  originalUniversalLocation: zUniversalLocationObject.nullable().openapi({ description: "Original collection universal location" })
});

// ../substrate-http-proxy/src/routes/palletNfts/collection.ts
var getCollection = new QueryEndpointConfig({
  route: "/pallet-nfts/collection/get",
  schemaIn: zPalletNftsCollectionQuery,
  schemaOut: zNftsCollectionDetails
});
var getCollectionsPaginated2 = new QueryEndpointConfig({
  route: "/pallet-nfts/collections",
  schemaIn: zPagination,
  schemaOut: import_zod29.z.object({
    collections: import_zod29.z.array(zNftsCollectionDetails),
    isLastPage: import_zod29.z.boolean()
  })
});
var getNextCollectionId = new QueryEndpointConfig({
  route: "/pallet-nfts/collection/next-id",
  schemaIn: import_zod29.z.object({}),
  schemaOut: import_zod29.z.object({
    nextCollectionId: import_zod29.z.number()
  })
});
var createCollection2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/create",
  schemaIn: zNftsCollectionCreateArguments.optional(),
  schemaOut: zNftsCollectionDetails.extend({
    creator: zAddressString
  })
});
var destroyCollection = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/destroy",
  schemaIn: import_zod29.z.object({
    collectionId: import_zod29.z.number().positive(),
    witness: import_zod29.z.object({
      itemMetadatas: import_zod29.z.number().default(0),
      itemConfigs: import_zod29.z.number().default(0),
      attributes: import_zod29.z.number().default(0)
    }).default({})
  }),
  schemaOut: import_zod29.z.object({
    collectionId: import_zod29.z.number()
  })
});
var acceptCollectionOwnership = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/accept-ownership",
  schemaIn: import_zod29.z.object({
    collectionId: import_zod29.z.number().positive().optional()
  }),
  schemaOut: import_zod29.z.object({
    who: import_zod29.z.string(),
    collectionId: import_zod29.z.number().optional()
  })
});
var transferCollectionOwnership = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/transfer",
  schemaIn: import_zod29.z.object({
    collectionId: import_zod29.z.number().positive(),
    newOwner: zAddressString
  }),
  schemaOut: zNftsCollectionDetails
});
var lockNftsCollection = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/lock",
  schemaIn: import_zod29.z.object({
    collectionId: import_zod29.z.number().positive(),
    settings: zNftsCollectionSettings.partial().refine((settings) => Object.keys(settings).length > 0, { message: "At least one setting must be changed" })
  }),
  schemaOut: zNftsCollectionDetails
});
var updateMintSettings = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/update-mint-settings",
  schemaIn: import_zod29.z.object({
    collectionId: import_zod29.z.number().positive(),
    mintSettings: zNftsMintSettings.partial().refine((settings) => Object.keys(settings).length > 0, { message: "At least one setting must be changed" }).refine((settings) => settings.defaultItemSettings ? Object.keys(settings.defaultItemSettings).length > 0 : true, {
      message: "At least one default item setting must be changed"
    })
  }),
  schemaOut: zNftsCollectionDetails
});
var setMaxSupply = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/set-max-supply",
  schemaIn: import_zod29.z.object({
    collectionId: import_zod29.z.number().positive(),
    maxSupply: import_zod29.z.number().positive()
  }),
  schemaOut: zNftsCollectionDetails
});
var setCollectionTeam = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/set-team",
  schemaIn: import_zod29.z.object({
    collectionId: import_zod29.z.number().positive(),
    issuer: zAddressString.optional(),
    admin: zAddressString.optional(),
    freezer: zAddressString.optional()
  }),
  schemaOut: zNftsCollectionDetails.extend({
    role: import_zod29.z.object({
      issuer: zAddressString.nullable(),
      admin: zAddressString.nullable(),
      freezer: zAddressString.nullable()
    })
  })
});
var setCollectionAttribute = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/set-attribute",
  schemaIn: import_zod29.z.object({
    collectionId: import_zod29.z.number().positive(),
    attribute: zAttribute
  }),
  schemaOut: zNftsCollectionDetails
});
var clearCollectionAttribute = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/clear-attribute",
  schemaIn: import_zod29.z.object({
    collectionId: import_zod29.z.number().positive(),
    attribute: zAttribute.omit({ value: true })
  }),
  schemaOut: zNftsCollectionDetails
});
var setCollectionMetadata = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/set-metadata",
  schemaIn: import_zod29.z.object({
    collectionId: import_zod29.z.number().positive(),
    data: import_zod29.z.string()
  }),
  schemaOut: zNftsCollectionDetails
});
var clearCollectionMetadata = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/collection/clear-metadata",
  schemaIn: import_zod29.z.object({
    collectionId: import_zod29.z.number().positive()
  }),
  schemaOut: zNftsCollectionDetails
});

// ../substrate-http-proxy/src/schemas/palletNfts/item.ts
var import_zod30 = require("zod");
var zNftsItemPrice = import_zod30.z.object({
  amount: import_zod30.z.string(),
  buyer: import_zod30.z.string().nullable()
});
var zNftsItemSettings2 = import_zod30.z.object({
  lockedTransfers: import_zod30.z.boolean(),
  lockedMetadata: import_zod30.z.boolean(),
  lockedAttributes: import_zod30.z.boolean()
});
var zNftsItemMetadata = import_zod30.z.object({
  data: import_zod30.z.string(),
  deposit: import_zod30.z.object({
    account: import_zod30.z.string().nullable(),
    amount: import_zod30.z.string()
  })
});
var zNftsTransferApproval = import_zod30.z.object({
  delegate: import_zod30.z.string(),
  deadlineBlock: import_zod30.z.number().optional()
});
var zNftsItemDeposit = import_zod30.z.object({
  account: import_zod30.z.string(),
  amount: import_zod30.z.string()
});
var zNftsItem = import_zod30.z.object({
  collectionId: import_zod30.z.number(),
  itemId: import_zod30.z.number(),
  owner: import_zod30.z.string(),
  deposit: zNftsItemDeposit,
  transferApprovals: import_zod30.z.array(zNftsTransferApproval),
  metadata: zNftsItemMetadata.nullable(),
  price: zNftsItemPrice.nullable(),
  attributes: import_zod30.z.array(zAttribute),
  settings: zNftsItemSettings2.nullable()
});

// ../substrate-http-proxy/src/routes/palletNfts/items.ts
var import_zod31 = require("zod");
var getItem = new QueryEndpointConfig({
  route: "/pallet-nfts/items/get",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.coerce.number().positive(),
    itemId: import_zod31.z.coerce.number().positive()
  }),
  schemaOut: zNftsItem
});
var mintItem = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/mint",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().nonnegative(),
    itemId: import_zod31.z.number().nonnegative(),
    mintTo: zAddressString,
    witnessData: import_zod31.z.object({
      ownedItemId: import_zod31.z.number().optional(),
      mintPrice: import_zod31.z.number().optional()
    }).optional()
  }),
  schemaOut: zNftsItem
});
var burnItem = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/burn",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().positive(),
    itemId: import_zod31.z.number().positive()
  }),
  schemaOut: import_zod31.z.any()
});
var approveItemAttributes = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/approve-attributes",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().positive(),
    itemId: import_zod31.z.number().positive(),
    delegate: zAddressString
  }),
  schemaOut: import_zod31.z.any()
});
var approveItemTransfer = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/approve-transfer",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().positive(),
    itemId: import_zod31.z.number().positive(),
    delegate: zAddressString,
    deadline: import_zod31.z.number().positive().optional().openapi({ description: "Transfer will be approved in next N blocks" })
  }),
  schemaOut: import_zod31.z.any()
});
var cancelItemTransferApproval = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/cancel-transfer-approval",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().positive(),
    itemId: import_zod31.z.number().positive(),
    delegate: zAddressString
  }),
  schemaOut: import_zod31.z.object({
    collectionId: import_zod31.z.number(),
    itemId: import_zod31.z.number(),
    owner: import_zod31.z.string(),
    delegate: import_zod31.z.string()
  })
});
var clearAllTransferApprovals = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/clear-all-transfer-approvals",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().positive(),
    itemId: import_zod31.z.number().positive()
  }),
  schemaOut: import_zod31.z.object({
    collectionId: import_zod31.z.number(),
    itemId: import_zod31.z.number()
  })
});
var setItemAttribute = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/set-attribute",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().positive(),
    itemId: import_zod31.z.number().positive(),
    attribute: zAttribute
  }),
  schemaOut: zNftsItem
});
var clearItemAttribute = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/clear-attribute",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().positive(),
    itemId: import_zod31.z.number().positive(),
    attribute: zAttribute
  }),
  schemaOut: zNftsItem
});
var setItemMetadata = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/set-metadata",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().positive(),
    itemId: import_zod31.z.number().positive(),
    data: import_zod31.z.string()
  }),
  schemaOut: zNftsItem
});
var clearItemMetadata = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/clear-metadata",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().positive(),
    itemId: import_zod31.z.number().positive()
  }),
  schemaOut: zNftsItem
});
var cancelItemAttributesApproval = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/cancel-attributes-approval",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().positive(),
    itemId: import_zod31.z.number().positive(),
    delegate: zAddressString
  }),
  schemaOut: import_zod31.z.object({
    collectionId: import_zod31.z.number(),
    itemId: import_zod31.z.number(),
    owner: import_zod31.z.string(),
    delegate: import_zod31.z.string()
  })
});
var lockItemTransfer = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/lock-transfer",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().positive(),
    itemId: import_zod31.z.number().positive()
  }),
  schemaOut: import_zod31.z.object({
    collectionId: import_zod31.z.number(),
    itemId: import_zod31.z.number()
  })
});
var unlockItemTransfer = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/unlock-transfer",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().positive(),
    itemId: import_zod31.z.number().positive()
  }),
  schemaOut: import_zod31.z.object({
    collectionId: import_zod31.z.number(),
    itemId: import_zod31.z.number()
  })
});
var transferItem = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/transfer",
  schemaIn: import_zod31.z.object({
    collectionId: import_zod31.z.number().positive(),
    itemId: import_zod31.z.number().positive(),
    to: zAddressString
  }),
  schemaOut: zNftsItem
});
var lockItemPropertiesIn = import_zod31.z.object({
  collectionId: import_zod31.z.number().positive(),
  itemId: import_zod31.z.number().positive(),
  lockMetadata: import_zod31.z.boolean().optional().openapi({ description: "Lock metadata, default: false" }),
  lockAttributes: import_zod31.z.boolean().optional().openapi({ description: "Lock attributes, default: false" })
});
var lockItemProperties = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/lock-properties",
  schemaIn: lockItemPropertiesIn,
  schemaOut: lockItemPropertiesIn
});

// ../substrate-http-proxy/src/routes/palletNfts/attributes.ts
var import_zod32 = require("zod");
var getAttribute = new QueryEndpointConfig({
  route: "/pallet-nfts/attribute",
  schemaIn: import_zod32.z.object({
    collectionId: import_zod32.z.coerce.number().positive(),
    itemId: import_zod32.z.coerce.number().positive().optional(),
    namespace: zAttributeNamespace,
    key: import_zod32.z.string()
  }),
  schemaOut: import_zod32.z.object({
    collectionId: import_zod32.z.number().positive(),
    itemId: import_zod32.z.number().positive().optional(),
    attribute: zAttribute.nullable()
  })
});
var getAttributes = new QueryEndpointConfig({
  route: "/pallet-nfts/attributes",
  schemaIn: import_zod32.z.object({
    collectionId: import_zod32.z.coerce.number().positive(),
    itemId: import_zod32.z.coerce.number().positive().optional(),
    namespace: zAttributeNamespace.optional()
  }),
  schemaOut: import_zod32.z.any()
});
var zSetAttributeIn = import_zod32.z.object({
  collectionId: import_zod32.z.number().positive(),
  itemId: import_zod32.z.number().positive().optional(),
  attribute: zAttribute
});
var setAttribute = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/set-attribute",
  schemaIn: zSetAttributeIn,
  schemaOut: zSetAttributeIn
});
var zClearAttributeIn = import_zod32.z.object({
  collectionId: import_zod32.z.number().positive(),
  itemId: import_zod32.z.number().positive().optional(),
  attribute: zAttribute.omit({ value: true })
});
var clearAttribute = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/clear-attribute",
  schemaIn: zClearAttributeIn,
  schemaOut: zClearAttributeIn
});

// ../substrate-http-proxy/src/routes/palletNfts/account.ts
var import_zod33 = require("zod");
var getAccountCollections = new QueryEndpointConfig({
  route: "/pallet-nfts/account/collections",
  schemaIn: import_zod33.z.object({
    account: zAddressString
  }),
  schemaOut: import_zod33.z.object({
    account: zAddressString,
    collections: import_zod33.z.number().array()
  })
});
var getCollectionOwnershipAcceptance = new QueryEndpointConfig({
  route: "/pallet-nfts/account/ownership-acceptance",
  schemaIn: import_zod33.z.object({
    account: zAddressString
  }),
  schemaOut: import_zod33.z.object({
    collectionId: import_zod33.z.number().nullable()
  })
});
var getCollectionRole = new QueryEndpointConfig({
  route: "/pallet-nfts/account/collection-role",
  schemaIn: import_zod33.z.object({
    collectionId: import_zod33.z.coerce.number(),
    account: zAddressString
  }),
  schemaOut: zNftsCollectionRole.extend({
    owner: import_zod33.z.boolean()
  })
});
var getAccountItems = new QueryEndpointConfig({
  route: "/pallet-nfts/account/items",
  schemaIn: import_zod33.z.object({
    account: zAddressString,
    collectionId: import_zod33.z.coerce.number().int().nonnegative().openapi({ description: "Collection ID", example: 1 })
  }),
  schemaOut: import_zod33.z.array(import_zod33.z.object({
    collectionId: import_zod33.z.number(),
    tokenId: import_zod33.z.number(),
    original: import_zod33.z.object({
      collectionId: import_zod33.z.number(),
      tokenId: import_zod33.z.number()
    }).optional()
  }))
});

// ../substrate-http-proxy/src/routes/palletNfts/common.ts
var import_zod34 = require("zod");
var getPalletVersion = new QueryEndpointConfig({
  route: "/pallet-nfts/common/pallet-version",
  schemaIn: import_zod34.z.object({}),
  schemaOut: import_zod34.z.object({
    version: import_zod34.z.number().openapi({ description: "The version of the NFTs pallet" })
  })
});
var getNextCollectionId2 = new QueryEndpointConfig({
  route: "/pallet-nfts/common/next-collection-id",
  schemaIn: import_zod34.z.object({}),
  schemaOut: import_zod34.z.object({
    nextCollectionId: import_zod34.z.number().openapi({ description: "The next collection id that is going to be used" })
  })
});

// ../substrate-http-proxy/src/routes/palletNfts/trades.ts
var import_zod35 = require("zod");
var setPrice = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/set-price",
  schemaIn: import_zod35.z.object({
    collectionId: import_zod35.z.number().positive(),
    itemId: import_zod35.z.number().positive(),
    price: import_zod35.z.union([import_zod35.z.number().positive(), import_zod35.z.string()]).nullable().optional(),
    buyer: zAddressString.optional()
  }),
  schemaOut: import_zod35.z.any()
});
var buyItem = new ExtrinsicEndpointsConfig({
  route: "/pallet-nfts/items/buy",
  schemaIn: import_zod35.z.object({
    collectionId: import_zod35.z.number().positive(),
    itemId: import_zod35.z.number().positive(),
    bidPrice: import_zod35.z.union([import_zod35.z.number().positive(), import_zod35.z.string().regex(/^\d+$/)])
  }),
  schemaOut: import_zod35.z.object({
    collectionId: import_zod35.z.number(),
    itemId: import_zod35.z.number(),
    price: import_zod35.z.string(),
    seller: import_zod35.z.string(),
    buyer: import_zod35.z.string()
  })
});

// ../substrate-http-proxy/src/routes/palletNfts/utils.ts
var import_zod36 = require("zod");
var getTokenParsedMetadata2 = new QueryEndpointConfig({
  route: "/pallet-nfts/utils/parsed-metadata",
  schemaIn: import_zod36.z.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: import_zod36.z.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 })
  }),
  schemaOut: import_zod36.z.any()
});

// ../substrate-http-proxy/src/schemas/palletUniques/item.ts
var import_zod38 = require("zod");

// ../substrate-http-proxy/src/schemas/palletUniques/attributes.ts
var import_zod37 = require("zod");
var zUniquesGetCollectionAttributesIn = import_zod37.z.object({
  collectionId: import_zod37.z.coerce.number().openapi({ description: "The ID of the collection." })
});
var zUniquesItemAttributesIn = import_zod37.z.object({
  collectionId: import_zod37.z.coerce.number().openapi({ description: "The ID of the collection." }),
  itemId: import_zod37.z.coerce.number().openapi({ description: "The ID of the asset." })
});
var zAttributesIn = import_zod37.z.object({
  collectionId: import_zod37.z.coerce.number().openapi({ description: "The ID of the collection." }),
  itemId: import_zod37.z.coerce.number().optional().openapi({ description: "The ID of the item." })
});
var zUniquesAttribute = import_zod37.z.object({
  key: import_zod37.z.string().openapi({ description: "Attribute key" }),
  value: import_zod37.z.string().nullable().openapi({ description: "Attribute value" })
});
var zUniquesGetAttribute = import_zod37.z.object({
  collectionId: import_zod37.z.coerce.number().openapi({ description: "The ID of the collection." }),
  itemId: import_zod37.z.coerce.number().optional().openapi({ description: "The ID of the item." }),
  attributeKey: import_zod37.z.string().openapi({ description: "The key of the attribute." })
});
var zUniquesSetAttributeIn = import_zod37.z.object({
  collectionId: import_zod37.z.coerce.number().openapi({ description: "The ID of the collection." }),
  itemId: import_zod37.z.coerce.number().optional().openapi({ description: "The ID of the item." }),
  attribute: import_zod37.z.object({
    key: import_zod37.z.string().openapi({ description: "The key of the attribute." }),
    value: import_zod37.z.string().openapi({ description: "The value of the attribute." })
  })
});
var zUniquesClearAttributeIn = import_zod37.z.object({
  collectionId: import_zod37.z.coerce.number().openapi({ description: "The ID of the collection." }),
  itemId: import_zod37.z.coerce.number().optional().openapi({ description: "The ID of the item." }),
  attributeKey: import_zod37.z.string().openapi({ description: "The key of the attribute." })
});
var zUniquesSetCollectionMetadataIn = import_zod37.z.object({
  collectionId: import_zod37.z.coerce.number().openapi({ description: "The ID of the collection." }),
  data: import_zod37.z.string().openapi({ description: "The metadata of the collection." }),
  isFrozen: import_zod37.z.boolean().optional().default(false).openapi({ description: "Whether the collection is frozen." })
});
var zUniquesMetadata = import_zod37.z.object({
  data: import_zod37.z.string().openapi({ description: "The metadata of the collection." }),
  isFrozen: import_zod37.z.boolean().optional().default(false).openapi({ description: "Whether the collection is frozen." }),
  deposit: import_zod37.z.string().openapi({ description: "The deposit of the collection." })
});
var zUniquesSetItemMetadataIn = zUniquesSetCollectionMetadataIn.extend({
  itemId: import_zod37.z.coerce.number().openapi({ description: "The ID of the item." })
});
var zUniquesClearCollectionMetadataIn = import_zod37.z.object({
  collectionId: import_zod37.z.coerce.number().openapi({ description: "The ID of the collection." })
});
var zUniquesClearItemMetadataIn = zUniquesClearCollectionMetadataIn.extend({
  itemId: import_zod37.z.coerce.number().openapi({ description: "The ID of the item." })
});

// ../substrate-http-proxy/src/schemas/palletUniques/item.ts
var zUniquesItem = import_zod38.z.object({
  itemId: import_zod38.z.coerce.number().int().openapi({ description: "Item ID", example: 0 }),
  collectionId: import_zod38.z.coerce.number().int().openapi({ description: "Collection ID", example: 0 }),
  owner: import_zod38.z.string().openapi({ description: "The owner of the item" }),
  approved: import_zod38.z.string().nullable().openapi({ description: "Approved address" }),
  isFrozen: import_zod38.z.boolean().openapi({ description: "Whether the item is frozen" }),
  deposit: import_zod38.z.number().openapi({ description: "The deposit of the item" })
});
var zUniquesItemDetails = zUniquesItem.extend({
  metadata: zUniquesMetadata.nullable().openapi({ description: "The metadata of the item" }),
  attributes: import_zod38.z.array(zUniquesAttribute)
});
var zUniquesItemsQuery = import_zod38.z.object({
  collectionId: import_zod38.z.coerce.number().int().openapi({ description: "Collection ID", example: 0 }),
  itemId: import_zod38.z.coerce.number().int().openapi({ description: "Item ID", example: 0 })
});
var zUniquesCollectionItemsQuery = zUniquesItemsQuery.omit({ itemId: true });
var zUniquesMintItem = zUniquesItemsQuery.extend({
  owner: zAddressString.openapi({ description: "The owner of the item", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })
});
var zUniquesCollectionMetadataQuery = zUniquesItemsQuery.omit({ itemId: true });
var zUniquesTransferItem = zUniquesItemsQuery.extend({
  newOwner: zAddressString.openapi({ description: "The new owner of the item", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  oldOwner: zAddressString.optional().openapi({ description: "The old owner of the item", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })
});
var zUniquesBurnItemQuery = zUniquesItemsQuery.extend({
  checkOwner: zAddressString.optional().openapi({ description: "The owner of the item", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })
});

// ../substrate-http-proxy/src/schemas/palletUniques/collection.ts
var import_zod39 = require("zod");
var zUniquesCollectionQuery = import_zod39.z.object({
  collectionId: import_zod39.z.coerce.number().int().openapi({ description: "Collection ID", example: 0 })
});
var zUniquesCreateCollectionQuery = zUniquesCollectionQuery.extend({
  collectionId: import_zod39.z.coerce.number().int().optional().openapi({ description: "Collection ID", example: 0 }),
  admin: zAddressString
});
var zUniquesTransferCollectionQuery = zUniquesCollectionQuery.extend({
  newOwner: zAddressString
});
var zUniquesCollectionDetails = import_zod39.z.object({
  collectionId: import_zod39.z.coerce.number().int().openapi({ description: "Collection ID", example: 0 }),
  owner: import_zod39.z.string().openapi({ description: "The owner of the collection." }),
  issuer: import_zod39.z.string().openapi({ description: "The issuer of the collection." }),
  admin: import_zod39.z.string().openapi({ description: "The admin of the collection." }),
  freezer: import_zod39.z.string().openapi({ description: "The freezer of the collection." }),
  totalDeposit: import_zod39.z.number().openapi({ description: "The total deposit of the collection." }),
  freeHolding: import_zod39.z.boolean().openapi({ description: "Whether the collection is free-holding." }),
  items: import_zod39.z.number().openapi({ description: "The number of items in the collection." }),
  itemMetadatas: import_zod39.z.number().openapi({ description: "The number of item metadatas in the collection." }),
  isFrozen: import_zod39.z.boolean().openapi({ description: "Whether the collection is frozen." }),
  maxSupply: import_zod39.z.coerce.number().int().openapi({ description: "Max supply", example: 0 }),
  attributes: import_zod39.z.array(zUniquesAttribute),
  metadata: zUniquesMetadata.nullable().openapi({ description: "The metadata of the collection." }),
  universalLocation: zUniversalLocationObject.nullable().openapi({ description: "The universal location of the collection" })
});

// ../substrate-http-proxy/src/routes/palletUniques/collection.ts
var import_zod40 = require("zod");
var getFreeCollectionId = new QueryEndpointConfig({
  route: "/pallet-uniques/collection/free-id",
  schemaIn: import_zod40.z.object({}),
  schemaOut: import_zod40.z.object({
    freeCollectionId: import_zod40.z.number()
  })
});
var createCollection3 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/create",
  schemaIn: zUniquesCreateCollectionQuery,
  schemaOut: zUniquesCollectionDetails.extend({
    creator: zAddressString
  })
});
var destroyCollection2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/destroy",
  schemaIn: zUniquesCollectionQuery.extend({
    witness: import_zod40.z.object({
      itemMetadatas: import_zod40.z.number().default(0),
      itemConfigs: import_zod40.z.number().default(0),
      attributes: import_zod40.z.number().default(0)
    }).default({})
  }),
  schemaOut: zUniquesCollectionQuery
});
var freezeCollection = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/freeze",
  schemaIn: zUniquesCollectionQuery,
  schemaOut: zUniquesCollectionDetails
});
var thawCollection = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/thaw",
  schemaIn: zUniquesCollectionQuery,
  schemaOut: zUniquesCollectionDetails
});
var setCollectionAttribute2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/set-attribute",
  schemaIn: zUniquesSetAttributeIn.omit({ itemId: true }),
  schemaOut: zUniquesCollectionDetails
});
var clearCollectionAttribute2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/clear-attribute",
  schemaIn: zUniquesClearAttributeIn.omit({ itemId: true }),
  schemaOut: zUniquesCollectionDetails
});
var setCollectionMetadata2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/set-metadata",
  schemaIn: zUniquesSetCollectionMetadataIn,
  schemaOut: zUniquesCollectionDetails
});
var clearCollectionMetadata2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/clear-metadata",
  schemaIn: zUniquesClearCollectionMetadataIn,
  schemaOut: zUniquesCollectionDetails
});
var transferCollection2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/collection/transfer",
  schemaIn: zUniquesTransferCollectionQuery,
  schemaOut: zUniquesCollectionDetails
});
var getCollection2 = new QueryEndpointConfig({
  route: "/pallet-uniques/collection/get",
  schemaIn: zUniquesCollectionQuery,
  schemaOut: zUniquesCollectionDetails
});
var getCollectionsPaginated3 = new QueryEndpointConfig({
  route: "/pallet-uniques/collections",
  schemaIn: zPagination,
  schemaOut: import_zod40.z.object({
    collections: import_zod40.z.array(zUniquesCollectionDetails),
    isLastPage: import_zod40.z.boolean()
  })
});
var getCollectionAttributes = new QueryEndpointConfig({
  route: "/pallet-uniques/collection/attributes",
  schemaIn: zUniquesGetCollectionAttributesIn,
  schemaOut: import_zod40.z.object({
    collectionId: import_zod40.z.number(),
    attributes: import_zod40.z.array(zUniquesAttribute)
  })
});
var getCollectionItems = new QueryEndpointConfig({
  route: "/pallet-uniques/collection/items",
  schemaIn: zUniquesCollectionItemsQuery,
  schemaOut: import_zod40.z.object({
    collectionId: import_zod40.z.number(),
    items: import_zod40.z.array(
      import_zod40.z.object({
        itemId: import_zod40.z.number(),
        details: zUniquesItem
      })
    )
  })
});
var PalletUniquesCollectionRoutesConfig = {
  extrinsics: {
    createCollection: createCollection3,
    setCollectionAttribute: setCollectionAttribute2,
    clearCollectionAttribute: clearCollectionAttribute2,
    setCollectionMetadata: setCollectionMetadata2,
    clearCollectionMetadata: clearCollectionMetadata2,
    transferCollection: transferCollection2,
    destroyCollection: destroyCollection2,
    freezeCollection,
    thawCollection
  },
  queries: {
    getFreeCollectionId,
    getCollection: getCollection2,
    getCollectionsPaginated: getCollectionsPaginated3,
    getCollectionAttributes,
    getCollectionItems
  }
};

// ../substrate-http-proxy/src/routes/palletUniques/item.ts
var import_zod41 = require("zod");
var mintItem2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/mint",
  schemaIn: zUniquesMintItem,
  schemaOut: zUniquesItemDetails
});
var transferItem2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/transfer",
  schemaIn: zUniquesTransferItem,
  schemaOut: zUniquesItemDetails
});
var freezeItem = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/freeze",
  schemaIn: zUniquesBurnItemQuery,
  schemaOut: zUniquesItemDetails
});
var thawItem = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/thaw",
  schemaIn: zUniquesBurnItemQuery,
  schemaOut: zUniquesItemDetails
});
var burnItem2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/burn",
  schemaIn: zUniquesBurnItemQuery,
  schemaOut: import_zod41.z.object({
    collectionId: import_zod41.z.number(),
    itemId: import_zod41.z.number()
  })
});
var setItemAttribute2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/set-attribute",
  schemaIn: zUniquesSetAttributeIn.extend({
    itemId: import_zod41.z.coerce.number().openapi({ description: "The ID of the item." })
  }),
  schemaOut: zUniquesItemDetails
});
var setItemMetadata2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/set-metadata",
  schemaIn: zUniquesSetItemMetadataIn,
  schemaOut: zUniquesItemDetails
});
var clearItemAttribute2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/clear-attribute",
  schemaIn: zUniquesClearAttributeIn.required({ itemId: true }),
  schemaOut: zUniquesItemDetails
});
var clearItemMetadata2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/item/clear-metadata",
  schemaIn: zUniquesClearItemMetadataIn,
  schemaOut: zUniquesItemDetails
});
var getItem2 = new QueryEndpointConfig({
  route: "/pallet-uniques/item/get",
  schemaIn: zUniquesItemsQuery,
  schemaOut: zUniquesItemDetails
});
var getItemAttributes = new QueryEndpointConfig({
  route: "/pallet-uniques/item/attributes",
  schemaIn: zUniquesItemAttributesIn,
  schemaOut: import_zod41.z.object({
    itemId: import_zod41.z.number(),
    attributes: import_zod41.z.array(zUniquesAttribute)
  })
});
var PalletUniquesItemRoutesConfig = {
  extrinsics: {
    mintItem: mintItem2,
    burnItem: burnItem2,
    transferItem: transferItem2,
    freezeItem,
    thawItem,
    setItemAttribute: setItemAttribute2,
    clearItemAttribute: clearItemAttribute2,
    setItemMetadata: setItemMetadata2,
    clearItemMetadata: clearItemMetadata2
  },
  queries: {
    getItem: getItem2,
    getItemAttributes
  }
};

// ../substrate-http-proxy/src/schemas/palletUniques/account.ts
var import_zod42 = require("zod");
var zUniquesAccountCollections = import_zod42.z.object({
  account: zAddressString.openapi({ description: "The ID of the account", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  collections: import_zod42.z.array(import_zod42.z.number().openapi({ description: "The ID of the collection" }))
});
var zUniquesAccountCollectionsQuery = import_zod42.z.object({
  address: import_zod42.z.string().openapi({ description: "The ID of the account", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" })
});
var zUniquesAccountItems = import_zod42.z.object({
  account: zAddressString.openapi({ description: "The ID of the account", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  items: import_zod42.z.array(import_zod42.z.number().openapi({ description: "The ID of the asset" }))
});
var zUniquesAccountItemsQuery = import_zod42.z.object({
  address: import_zod42.z.string().openapi({ description: "The ID of the account", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" }),
  collectionId: import_zod42.z.coerce.number().int().openapi({ description: "Collection ID", example: 0 })
});
var zUniquesAccountAcceptOwnerQuery = import_zod42.z.object({
  collectionId: import_zod42.z.coerce.number().int().optional().openapi({ description: "Collection ID", example: 0 })
});

// ../substrate-http-proxy/src/routes/palletUniques/account.ts
var import_zod43 = require("zod");
var acceptCollectionOwnership2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/account/accept-collection-ownership",
  schemaIn: zUniquesAccountAcceptOwnerQuery,
  schemaOut: import_zod43.z.object({
    collectionId: import_zod43.z.number().nullable(),
    account: zAddressString
  })
});
var getAccountCollectionIds = new QueryEndpointConfig({
  route: "/pallet-uniques/account/collections",
  schemaIn: zUniquesAccountCollectionsQuery,
  schemaOut: zUniquesAccountCollections
});
var getAccountItemIds = new QueryEndpointConfig({
  route: "/pallet-uniques/account/items",
  schemaIn: zUniquesAccountItemsQuery,
  schemaOut: zUniquesAccountItems
});
var PalletUniquesAccountRoutesConfig = {
  extrinsics: {
    acceptCollectionOwnership: acceptCollectionOwnership2
  },
  queries: {
    getAccountCollectionIds,
    getAccountItemIds
  }
};

// ../substrate-http-proxy/src/routes/palletUniques/attributes.ts
var setAttribute2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/set-attribute",
  schemaIn: zUniquesSetAttributeIn,
  schemaOut: zUniquesSetAttributeIn
});
var clearAttribute2 = new ExtrinsicEndpointsConfig({
  route: "/pallet-uniques/clear-attribute",
  schemaIn: zUniquesClearAttributeIn,
  schemaOut: zUniquesClearAttributeIn
});
var getAttribute2 = new QueryEndpointConfig({
  route: "/pallet-uniques/attribute",
  schemaIn: zUniquesGetAttribute,
  schemaOut: zUniquesAttribute
});
var PalletUniquesAttributesRoutesConfig = {
  extrinsics: {
    setAttribute: setAttribute2,
    clearAttribute: clearAttribute2
  },
  queries: {
    getAttribute: getAttribute2
  }
};

// ../substrate-http-proxy/src/routes/palletUniques/utils.ts
var import_zod44 = require("zod");
var getTokenParsedMetadata3 = new QueryEndpointConfig({
  route: "/pallet-uniques/utils/parsed-metadata",
  schemaIn: import_zod44.z.object({
    collectionId: zCollectionIdOrAddress.openapi({ description: "Collection ID or address", example: 1 }),
    tokenId: import_zod44.z.coerce.number().int().positive().openapi({ description: "Token ID", example: 1 })
  }),
  schemaOut: import_zod44.z.any()
});
var PalletUniquesUtilsRoutesConfig = {
  queries: {
    getTokenParsedMetadata: getTokenParsedMetadata3
  },
  extrinsics: {}
};

// ../substrate-http-proxy/src/schemas/palletAssets/index.ts
var import_zod45 = require("zod");
var zAssetsAddress = import_zod45.z.string().openapi({ description: "The owner of the collection", example: "5GEuzsNk8HkjSDJi1EK91omheS476JAW2PhqrZJSiBrEVeLL" });
var zAsset = import_zod45.z.object({
  id: import_zod45.z.number().openapi({ description: "Asset ID", example: 1 }),
  owner: zAssetsAddress,
  issuer: zAssetsAddress,
  admin: zAssetsAddress,
  freezer: zAssetsAddress,
  supply: import_zod45.z.string().openapi({ description: "Supply", example: "1000000000000000000000" }),
  deposit: import_zod45.z.string().openapi({ description: "Deposit", example: "1000000000000000000000" }),
  minBalance: import_zod45.z.string().openapi({ description: "Min balance", example: "1000000000000000000000" }),
  isSufficient: import_zod45.z.boolean().openapi({ description: "Is sufficient", example: true }),
  accounts: import_zod45.z.number().openapi({ description: "Accounts", example: 23 }),
  sufficients: import_zod45.z.number().openapi({ description: "Sufficients", example: 23 }),
  approvals: import_zod45.z.number().openapi({ description: "Approvals", example: 23 }),
  status: import_zod45.z.string().openapi({ description: "Status", example: "Live" }),
  name: import_zod45.z.string().openapi({ description: "Name", example: "USD Stablecoin" }),
  symbol: import_zod45.z.string().openapi({ description: "Symbol", example: "USD" }),
  decimals: import_zod45.z.number().openapi({ description: "Decimals", example: 18 }),
  isFrozen: import_zod45.z.boolean().openapi({ description: "Is frozen", example: false }),
  universalLocation: zUniversalLocationObject.nullable().openapi({ description: "The universal location of the collection" })
});
var zAssetQuery = import_zod45.z.object({
  id: import_zod45.z.coerce.number().int().positive().openapi({ description: "Collection ID", example: 1 })
});

// ../substrate-http-proxy/src/routes/palletAssets/asset.ts
var import_zod46 = require("zod");
var getAsset = new QueryEndpointConfig({
  route: "/pallet-assets/asset",
  schemaIn: zAssetQuery,
  schemaOut: zAsset
});
var getAssetsPaginated = new QueryEndpointConfig({
  route: "/pallet-assets/assets",
  schemaIn: zPagination,
  schemaOut: import_zod46.z.object({
    assets: import_zod46.z.array(zAsset),
    isLastPage: import_zod46.z.boolean()
  })
});
var getBalance = new QueryEndpointConfig({
  route: "/pallet-assets/balance",
  schemaIn: import_zod46.z.object({
    address: import_zod46.z.string(),
    id: import_zod46.z.coerce.number().int().positive().openapi({ description: "Collection ID", example: 1 })
  }),
  schemaOut: import_zod46.z.object({
    balance: import_zod46.z.string(),
    symbol: import_zod46.z.string(),
    decimals: import_zod46.z.number()
  })
});

// ../substrate-http-proxy/src/routes/palletForeignUniques/foreignUniquesAssetHub.ts
var import_zod47 = require("zod");
var getDerivativeRegistered = new QueryEndpointConfig({
  route: "/pallet-foreign-uniques-asset-hub/registered",
  method: "POST",
  schemaIn: import_zod47.z.object({
    universalLocation: zUniversalLocationObject
  }),
  schemaOut: import_zod47.z.object({
    registered: import_zod47.z.boolean()
  })
});
var listDerivatives = new QueryEndpointConfig({
  route: "/pallet-foreign-uniques-asset-hub/list",
  method: "GET",
  schemaIn: zPagination,
  schemaOut: import_zod47.z.array(
    import_zod47.z.object({
      itemsCount: import_zod47.z.number(),
      universalLocation: zUniversalLocationObject
    })
  )
});
var registerDerivative = new ExtrinsicEndpointsConfig({
  route: "/pallet-foreign-uniques-asset-hub/register",
  schemaIn: import_zod47.z.object({
    universalLocation: zUniversalLocationObject
  }),
  schemaOut: import_zod47.z.object({
    registered: import_zod47.z.boolean()
  })
});
var getAccountItems2 = new QueryEndpointConfig({
  route: "/pallet-foreign-uniques-asset-hub/account-items",
  method: "POST",
  schemaIn: import_zod47.z.object({
    universalLocation: zUniversalLocationObject,
    account: zAddressString
  }),
  schemaOut: import_zod47.z.object({
    items: import_zod47.z.array(import_zod47.z.number())
  })
});

// ../substrate-http-proxy/src/routes/palletForeignUniques/derivativeCollections.ts
var import_zod48 = require("zod");
var getDerivativeRegistered2 = new QueryEndpointConfig({
  route: "/derivative-collections/registered",
  method: "POST",
  schemaIn: import_zod48.z.object({
    universalLocation: zUniversalLocationObject
  }),
  schemaOut: import_zod48.z.object({
    registered: import_zod48.z.boolean()
  })
});
var registerDerivativeUnique = new ExtrinsicEndpointsConfig({
  route: "/derivative-collections/register",
  schemaIn: import_zod48.z.object({
    universalLocation: zUniversalLocationObject,
    mode: import_zod48.z.enum(["Nft", "Fungible"]).openapi({ description: "The mode of the collection", example: "Nft" }),
    name: import_zod48.z.string().pipe(zMaxBytesPipe(64)).openapi({ description: "The name of the collection", example: "My Collection" }),
    tokenDecimals: import_zod48.z.coerce.number().int().positive().optional().openapi({ description: "Fungible token decimals", example: 18 }),
    symbol: import_zod48.z.string().optional().pipe(zMaxBytesPipe(16)).openapi({ description: "The symbol of the collection", example: "MC" })
  }),
  schemaOut: import_zod48.z.object({
    registered: import_zod48.z.boolean()
  })
});
var registerDerivativeAssetHub = new ExtrinsicEndpointsConfig({
  route: "/derivative-collections/register",
  schemaIn: import_zod48.z.object({
    universalLocation: zUniversalLocationObject
  }),
  schemaOut: import_zod48.z.object({
    registered: import_zod48.z.boolean()
  })
});

// ../substrate-http-proxy/src/routes/palletForeignUniques/foreignAssetsAssetHub.ts
var import_zod49 = require("zod");

// ../substrate-client/registry/registry.ts
var import_string = require("@unique-nft/utils/string");

// ../substrate-http-proxy/src/routes/palletAssets/_queries.ts
var import_address6 = require("@unique-nft/utils/address");

// ../substrate-http-proxy/src/routes/palletForeignUniques/foreignAssetsAssetHub.ts
var getDerivativeRegistered3 = new QueryEndpointConfig({
  route: "/pallet-foreign-assets-asset-hub/registered",
  method: "POST",
  schemaIn: import_zod49.z.object({
    universalLocation: zUniversalLocationObject
  }),
  schemaOut: import_zod49.z.object({
    registered: import_zod49.z.boolean()
  })
});
var listDerivatives2 = new QueryEndpointConfig({
  route: "/pallet-foreign-assets-asset-hub/list",
  method: "GET",
  schemaIn: zPagination,
  schemaOut: import_zod49.z.array(
    zAsset.omit({ id: true })
  )
});
var getAccountBalance2 = new QueryEndpointConfig({
  route: "/pallet-foreign-assets-asset-hub/account-items",
  method: "POST",
  schemaIn: import_zod49.z.object({
    universalLocation: zUniversalLocationObject,
    account: zAddressString
  }),
  schemaOut: import_zod49.z.object({
    balance: import_zod49.z.string(),
    symbol: import_zod49.z.string(),
    decimals: import_zod49.z.number()
  })
});

// src/uniquesPallet.ts
var UniquesPalletRoutes = (options) => {
  const { makeExtrinsicFn, makeQueryFn } = prepareBase(options);
  return {
    collection: {
      getFreeId: makeQueryFn(PalletUniquesCollectionRoutesConfig.queries.getFreeCollectionId),
      get: makeQueryFn(PalletUniquesCollectionRoutesConfig.queries.getCollection),
      list: makeQueryFn(PalletUniquesCollectionRoutesConfig.queries.getCollectionsPaginated),
      getAttributes: makeQueryFn(PalletUniquesCollectionRoutesConfig.queries.getCollectionAttributes),
      getItems: makeQueryFn(PalletUniquesCollectionRoutesConfig.queries.getCollectionItems),
      create: makeExtrinsicFn(PalletUniquesCollectionRoutesConfig.extrinsics.createCollection),
      destroy: makeExtrinsicFn(PalletUniquesCollectionRoutesConfig.extrinsics.destroyCollection),
      transfer: makeExtrinsicFn(PalletUniquesCollectionRoutesConfig.extrinsics.transferCollection),
      setAttribute: makeExtrinsicFn(PalletUniquesCollectionRoutesConfig.extrinsics.setCollectionAttribute),
      clearAttribute: makeExtrinsicFn(PalletUniquesCollectionRoutesConfig.extrinsics.clearCollectionAttribute),
      setMetadata: makeExtrinsicFn(PalletUniquesCollectionRoutesConfig.extrinsics.setCollectionMetadata),
      clearMetadata: makeExtrinsicFn(PalletUniquesCollectionRoutesConfig.extrinsics.clearCollectionMetadata)
    },
    item: {
      get: makeQueryFn(PalletUniquesItemRoutesConfig.queries.getItem),
      getAttributes: makeQueryFn(PalletUniquesItemRoutesConfig.queries.getItemAttributes),
      mint: makeExtrinsicFn(PalletUniquesItemRoutesConfig.extrinsics.mintItem),
      burn: makeExtrinsicFn(PalletUniquesItemRoutesConfig.extrinsics.burnItem),
      transfer: makeExtrinsicFn(PalletUniquesItemRoutesConfig.extrinsics.transferItem),
      setAttribute: makeExtrinsicFn(PalletUniquesItemRoutesConfig.extrinsics.setItemAttribute),
      clearAttribute: makeExtrinsicFn(PalletUniquesItemRoutesConfig.extrinsics.clearItemAttribute),
      setMetadata: makeExtrinsicFn(PalletUniquesItemRoutesConfig.extrinsics.setItemMetadata),
      clearMetadata: makeExtrinsicFn(PalletUniquesItemRoutesConfig.extrinsics.clearItemMetadata)
    },
    account: {
      getCollections: makeQueryFn(PalletUniquesAccountRoutesConfig.queries.getAccountCollectionIds),
      getItems: makeQueryFn(PalletUniquesAccountRoutesConfig.queries.getAccountItemIds),
      acceptCollectionOwnership: makeExtrinsicFn(PalletUniquesAccountRoutesConfig.extrinsics.acceptCollectionOwnership)
    },
    attributes: {
      get: makeQueryFn(PalletUniquesAttributesRoutesConfig.queries.getAttribute),
      setAttribute: makeExtrinsicFn(PalletUniquesAttributesRoutesConfig.extrinsics.setAttribute),
      clearAttribute: makeExtrinsicFn(PalletUniquesAttributesRoutesConfig.extrinsics.clearAttribute)
    },
    utils: {
      getParsedTokenMetadata: makeQueryFn(PalletUniquesUtilsRoutesConfig.queries.getTokenParsedMetadata)
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  UniquesPalletRoutes
});
//# sourceMappingURL=uniquesPallet.cjs.map