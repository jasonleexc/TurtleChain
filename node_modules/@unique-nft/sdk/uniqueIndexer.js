// src/indexer/index.ts
import Axios from "axios";
import qs from "qs";

// src/indexer/api.ts
import { z } from "zod";
var accounts = {
  zSingleAccountParams: z.object({
    address: z.string()
  }),
  zAccountRowSelect: z.object({
    address: z.string(),
    prototype: z.string().nullable(),
    mirror: z.string(),
    isEthereum: z.boolean(),
    isSigner: z.boolean().nullable(),
    isSmartContract: z.boolean().nullable(),
    createdAtBlockNumber: z.number(),
    updatedAtBlockNumber: z.number(),
    createdAt: z.coerce.date(),
    updatedAt: z.coerce.date()
  }),
  zAccountsFilter: z.object({
    addressIn: z.array(z.string()).optional(),
    mirrorIn: z.array(z.string()).optional(),
    isEthereum: z.boolean().optional(),
    isSigner: z.boolean().optional(),
    isSmartContract: z.boolean().optional(),
    createdTimestampFrom: z.coerce.date().optional(),
    createdTimestampTo: z.coerce.date().optional(),
    offset: z.number().default(0).optional(),
    limit: z.number().default(100).optional(),
    orderByAddress: z.enum(["asc", "desc"]).optional(),
    orderByCreatedTimestamp: z.enum(["asc", "desc"]).optional(),
    orderByCreatedAtBlockNumber: z.enum(["asc", "desc"]).optional()
  }),
  zAccountsWithCount: z.object({
    items: z.array(
      z.object({
        address: z.string(),
        prototype: z.string().nullable(),
        mirror: z.string(),
        isEthereum: z.boolean(),
        isSigner: z.boolean().nullable(),
        isSmartContract: z.boolean().nullable(),
        createdAtBlockNumber: z.number(),
        updatedAtBlockNumber: z.number(),
        createdAt: z.coerce.date(),
        updatedAt: z.coerce.date()
      })
    ),
    count: z.number()
  })
};
var blocks = {
  zSingleBlockParam: z.object({
    hashOrNumber: z.string()
  }),
  zBlockRowSelect: z.object({
    number: z.number(),
    hash: z.string(),
    parentHash: z.string(),
    specVersion: z.number(),
    timestamp: z.coerce.date(),
    relayParentNumber: z.number(),
    relayParentStorageRoot: z.string(),
    createdAt: z.coerce.date(),
    extrinsics: z.array(
      z.object({
        hash: z.string(),
        blockHash: z.string(),
        blockNumber: z.number(),
        indexInBlock: z.number(),
        signer: z.string(),
        section: z.string(),
        method: z.string(),
        args: z.record(z.any()),
        asHex: z.string(),
        createdAt: z.coerce.date(),
        events: z.array(
          z.object({
            extrinsicHash: z.string(),
            blockNumber: z.number(),
            section: z.string(),
            method: z.string(),
            data: z.record(z.any()),
            asHex: z.string(),
            createdAt: z.coerce.date()
          })
        ).default([]).optional()
      })
    ).default([]).optional()
  }),
  zBlocksFilter: z.object({
    numberFrom: z.number().optional(),
    numberTo: z.number().optional(),
    relayParentNumberFrom: z.number().optional(),
    relayParentNumberTo: z.number().optional(),
    timestampFrom: z.coerce.date().optional(),
    timestampTo: z.coerce.date().optional(),
    limit: z.number().default(100).optional(),
    offset: z.number().default(0).optional(),
    orderByNumber: z.enum(["asc", "desc"]).optional()
  }),
  zBlocksWithCount: z.object({
    items: z.array(
      z.object({
        number: z.number(),
        hash: z.string(),
        parentHash: z.string(),
        specVersion: z.number(),
        timestamp: z.coerce.date(),
        relayParentNumber: z.number(),
        relayParentStorageRoot: z.string(),
        createdAt: z.coerce.date(),
        extrinsics: z.array(
          z.object({
            hash: z.string(),
            blockHash: z.string(),
            blockNumber: z.number(),
            indexInBlock: z.number(),
            signer: z.string(),
            section: z.string(),
            method: z.string(),
            args: z.record(z.any()),
            asHex: z.string(),
            createdAt: z.coerce.date(),
            events: z.array(
              z.object({
                extrinsicHash: z.string(),
                blockNumber: z.number(),
                section: z.string(),
                method: z.string(),
                data: z.record(z.any()),
                asHex: z.string(),
                createdAt: z.coerce.date()
              })
            ).default([]).optional()
          })
        ).default([]).optional()
      })
    ),
    count: z.number()
  })
};
var coinBalances = {
  zSingleCoinBalanceParam: z.object({
    address: z.string()
  }),
  zCoinBalanceRowSelect: z.object({
    address: z.string(),
    available: z.string(),
    locked: z.string(),
    free: z.string(),
    total: z.string(),
    reserved: z.string(),
    staked: z.string(),
    unstaked: z.string(),
    canstake: z.string(),
    createdAtBlockNumber: z.number(),
    updatedAtBlockNumber: z.number(),
    fetchedAtBlockNumber: z.number(),
    createdAt: z.coerce.date(),
    updatedAt: z.coerce.date()
  }),
  zCoinBalancesFilter: z.object({
    addressIn: z.array(z.string()).optional(),
    offset: z.number().default(0).optional(),
    limit: z.number().default(100).optional(),
    availableFrom: z.bigint().optional(),
    availableTo: z.bigint().optional(),
    lockedFrom: z.bigint().optional(),
    lockedTo: z.bigint().optional(),
    freeFrom: z.bigint().optional(),
    freeTo: z.bigint().optional(),
    totalFrom: z.bigint().optional(),
    totalTo: z.bigint().optional(),
    reservedFrom: z.bigint().optional(),
    reservedTo: z.bigint().optional(),
    stakedFrom: z.bigint().optional(),
    stakedTo: z.bigint().optional(),
    unstakedFrom: z.bigint().optional(),
    unstakedTo: z.bigint().optional(),
    canstakeFrom: z.bigint().optional(),
    canstakeTo: z.bigint().optional(),
    orderByAddress: z.enum(["asc", "desc"]).optional(),
    orderByAvailable: z.enum(["asc", "desc"]).optional(),
    orderByLocked: z.enum(["asc", "desc"]).optional(),
    orderByFree: z.enum(["asc", "desc"]).optional(),
    orderByTotal: z.enum(["asc", "desc"]).optional(),
    orderByReserved: z.enum(["asc", "desc"]).optional(),
    orderByStaked: z.enum(["asc", "desc"]).optional(),
    orderByUnstaked: z.enum(["asc", "desc"]).optional(),
    orderByCanstake: z.enum(["asc", "desc"]).optional()
  }),
  zCoinBalancesWithCount: z.object({
    items: z.array(
      z.object({
        address: z.string(),
        available: z.string(),
        locked: z.string(),
        free: z.string(),
        total: z.string(),
        reserved: z.string(),
        staked: z.string(),
        unstaked: z.string(),
        canstake: z.string(),
        createdAtBlockNumber: z.number(),
        updatedAtBlockNumber: z.number(),
        fetchedAtBlockNumber: z.number(),
        createdAt: z.coerce.date(),
        updatedAt: z.coerce.date()
      })
    ),
    count: z.number()
  })
};
var coinTransfers = {
  zCoinBalancesTransfersFilter: z.object({
    fromIn: z.array(z.string()).optional(),
    toIn: z.array(z.string()).optional(),
    amountFrom: z.bigint().optional(),
    amountTo: z.bigint().optional(),
    orderByFrom: z.enum(["asc", "desc"]).optional(),
    orderByTo: z.enum(["asc", "desc"]).optional(),
    orderByAmount: z.enum(["asc", "desc"]).optional(),
    offset: z.number().default(0).optional(),
    limit: z.number().default(100).optional()
  }),
  zCoinBalancesTransfersWithCount: z.object({
    items: z.array(
      z.object({
        id: z.number(),
        from: z.string(),
        to: z.string(),
        amount: z.string(),
        eventId: z.number(),
        event: z.object({
          blockNumber: z.number(),
          extrinsicHash: z.string(),
          extrinsic: z.object({
            indexInBlock: z.number(),
            section: z.string().optional(),
            method: z.string().optional(),
            signer: z.string().optional()
          })
        }).nullable()
      })
    ),
    count: z.number()
  })
};
var collections = {
  zCollectionsFilter: z.object({
    mode: z.enum(["NFT", "Fungible", "RFT"]).optional(),
    collectionIdIn: z.array(z.string()).optional(),
    nameLike: z.string().optional(),
    descriptionLike: z.string().optional(),
    ownerIn: z.array(z.string()).optional(),
    adminIn: z.array(z.string()).optional(),
    sponsorIn: z.array(z.string()).optional(),
    isBurned: z.boolean().default(false).optional(),
    createdTimestampFrom: z.coerce.date().optional(),
    createdTimestampTo: z.coerce.date().optional(),
    updatedTimestampFrom: z.coerce.date().optional(),
    updatedTimestampTo: z.coerce.date().optional(),
    offset: z.number().default(0).optional(),
    limit: z.number().default(10).optional(),
    orderByCollectionId: z.enum(["asc", "desc"]).optional(),
    orderByName: z.enum(["asc", "desc"]).optional(),
    orderByDescription: z.enum(["asc", "desc"]).optional(),
    orderByOwner: z.enum(["asc", "desc"]).optional(),
    orderByUpdatedAtBlockNumber: z.enum(["asc", "desc"]).optional(),
    orderByCreatedAtBlockNumber: z.enum(["asc", "desc"]).optional(),
    orderByLastTokenId: z.enum(["asc", "desc"]).optional()
  }),
  zCollectionsWithCount: z.object({
    items: z.array(
      z.object({
        collectionId: z.number(),
        collectionAddress: z.string(),
        owner: z.string(),
        adminList: z.array(z.string()),
        mode: z.string(),
        fungiblePieces: z.number().nullable(),
        name: z.string(),
        description: z.string(),
        tokenPrefix: z.string(),
        sponsor: z.string().nullable(),
        isSponsorshipConfirmed: z.boolean().nullable(),
        lastTokenId: z.number(),
        limits: z.object({
          account_token_ownership_limit: z.number().nullable(),
          owner_can_destroy: z.boolean().nullable(),
          owner_can_transfer: z.boolean().nullable(),
          sponsor_approve_timeout: z.number().nullable(),
          sponsor_transfer_timeout: z.number().nullable(),
          sponsored_data_rate_limit: z.union([
            z.literal("SponsoringDisabled"),
            z.object({
              Blocks: z.number()
            })
          ]).nullable(),
          sponsored_data_size: z.number().nullable(),
          token_limit: z.number().nullable(),
          transfers_enabled: z.boolean().nullable()
        }),
        decodedLimits: z.record(
          z.object({
            key: z.string(),
            value: z.union([
              z.number(),
              z.boolean(),
              z.string(),
              z.object({
                Blocks: z.number()
              })
            ]),
            isDefaultValue: z.boolean()
          })
        ),
        permissions: z.object({
          access: z.union([z.literal("Normal"), z.literal("AllowList")]),
          mint_mode: z.boolean(),
          nesting: z.object({
            token_owner: z.boolean(),
            collection_admin: z.boolean(),
            restricted: z.union([z.null(), z.array(z.number())])
          })
        }),
        tokenPropertyPermissions: z.array(
          z.object({
            key: z.string(),
            keyHex: z.string(),
            permission: z.object({
              mutable: z.boolean(),
              collection_admin: z.boolean(),
              token_owner: z.boolean()
            })
          })
        ),
        properties: z.array(
          z.object({
            key: z.string(),
            keyHex: z.string(),
            value: z.string(),
            valueHex: z.string().optional()
          })
        ),
        propertiesMap: z.record(
          z.object({
            key: z.string(),
            keyHex: z.string(),
            value: z.string(),
            valueHex: z.string().optional()
          })
        ),
        readOnly: z.boolean(),
        foreign: z.boolean().nullable(),
        erc721metadata: z.boolean().nullable(),
        schemaName: z.string().nullable(),
        schemaVersion: z.string().nullable(),
        originalSchemaVersion: z.string().nullable(),
        coverImage: z.object({
          url: z.string(),
          details: z.object({
            name: z.string().optional(),
            type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
            bytes: z.number().optional(),
            format: z.string().optional(),
            sha256: z.string().optional(),
            width: z.number().optional(),
            height: z.number().optional(),
            order: z.number().optional()
          }).optional(),
          thumbnail: z.object({
            url: z.string(),
            details: z.object({
              name: z.string().optional(),
              type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
              bytes: z.number().optional(),
              format: z.string().optional(),
              sha256: z.string().optional(),
              width: z.number().optional(),
              height: z.number().optional(),
              order: z.number().optional()
            }).optional()
          }).optional()
        }).optional().nullable(),
        defaultTokenImage: z.object({
          url: z.string(),
          details: z.object({
            name: z.string().optional(),
            type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
            bytes: z.number().optional(),
            format: z.string().optional(),
            sha256: z.string().optional(),
            width: z.number().optional(),
            height: z.number().optional(),
            order: z.number().optional()
          }).optional(),
          thumbnail: z.object({
            url: z.string(),
            details: z.object({
              name: z.string().optional(),
              type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
              bytes: z.number().optional(),
              format: z.string().optional(),
              sha256: z.string().optional(),
              width: z.number().optional(),
              height: z.number().optional(),
              order: z.number().optional()
            }).optional()
          }).optional()
        }).optional().nullable(),
        potentialAttributes: z.array(
          z.object({
            trait_type: z.string(),
            display_type: z.string().optional(),
            values: z.array(z.union([z.string(), z.number()])).optional()
          })
        ).optional().nullable(),
        customizingSlots: z.record(
          z.object({
            type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]),
            collections: z.array(z.union([z.number(), z.string()])).optional(),
            name: z.string().optional(),
            image_overlay_specs: z.object({
              layer: z.number().optional(),
              order_in_layer: z.number().optional(),
              offset: z.object({
                x: z.number().optional(),
                y: z.number().optional()
              }).optional(),
              opacity: z.number().optional(),
              rotation: z.number().optional(),
              scale: z.object({
                x: z.number().optional(),
                y: z.number().optional(),
                unit: z.enum(["px", "%"]).default("%").optional().optional()
              }).optional(),
              anchor_point: z.object({
                x: z.number(),
                y: z.number()
              }).optional(),
              parent_anchor_point: z.object({
                x: z.number(),
                y: z.number()
              }).optional()
            }).optional()
          })
        ).optional().nullable(),
        customizes: z.array(z.union([z.number(), z.string()])).optional().nullable(),
        royalties: z.array(
          z.object({
            address: z.string(),
            percent: z.number(),
            isPrimaryOnly: z.boolean().optional()
          })
        ).optional().nullable(),
        collectionInfoError: z.string().nullable(),
        isBurned: z.boolean(),
        fetchedAtBlockNumber: z.number(),
        updatedAtBlockNumber: z.number(),
        updatedAt: z.coerce.date(),
        createdAt: z.coerce.date(),
        createdAtBlockNumber: z.number()
      })
    ),
    count: z.number()
  }),
  zParsedCollectionRowSelect: z.object({
    collectionId: z.number(),
    collectionAddress: z.string(),
    owner: z.string(),
    adminList: z.array(z.string()),
    mode: z.string(),
    fungiblePieces: z.number().nullable(),
    name: z.string(),
    description: z.string(),
    tokenPrefix: z.string(),
    sponsor: z.string().nullable(),
    isSponsorshipConfirmed: z.boolean().nullable(),
    lastTokenId: z.number(),
    limits: z.object({
      account_token_ownership_limit: z.number().nullable(),
      owner_can_destroy: z.boolean().nullable(),
      owner_can_transfer: z.boolean().nullable(),
      sponsor_approve_timeout: z.number().nullable(),
      sponsor_transfer_timeout: z.number().nullable(),
      sponsored_data_rate_limit: z.union([
        z.literal("SponsoringDisabled"),
        z.object({
          Blocks: z.number()
        })
      ]).nullable(),
      sponsored_data_size: z.number().nullable(),
      token_limit: z.number().nullable(),
      transfers_enabled: z.boolean().nullable()
    }),
    decodedLimits: z.record(
      z.object({
        key: z.string(),
        value: z.union([
          z.number(),
          z.boolean(),
          z.string(),
          z.object({
            Blocks: z.number()
          })
        ]),
        isDefaultValue: z.boolean()
      })
    ),
    permissions: z.object({
      access: z.union([z.literal("Normal"), z.literal("AllowList")]),
      mint_mode: z.boolean(),
      nesting: z.object({
        token_owner: z.boolean(),
        collection_admin: z.boolean(),
        restricted: z.union([z.null(), z.array(z.number())])
      })
    }),
    tokenPropertyPermissions: z.array(
      z.object({
        key: z.string(),
        keyHex: z.string(),
        permission: z.object({
          mutable: z.boolean(),
          collection_admin: z.boolean(),
          token_owner: z.boolean()
        })
      })
    ),
    properties: z.array(
      z.object({
        key: z.string(),
        keyHex: z.string(),
        value: z.string(),
        valueHex: z.string().optional()
      })
    ),
    propertiesMap: z.record(
      z.object({
        key: z.string(),
        keyHex: z.string(),
        value: z.string(),
        valueHex: z.string().optional()
      })
    ),
    readOnly: z.boolean(),
    foreign: z.boolean().nullable(),
    erc721metadata: z.boolean().nullable(),
    schemaName: z.string().nullable(),
    schemaVersion: z.string().nullable(),
    originalSchemaVersion: z.string().nullable(),
    coverImage: z.object({
      url: z.string(),
      details: z.object({
        name: z.string().optional(),
        type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
        bytes: z.number().optional(),
        format: z.string().optional(),
        sha256: z.string().optional(),
        width: z.number().optional(),
        height: z.number().optional(),
        order: z.number().optional()
      }).optional(),
      thumbnail: z.object({
        url: z.string(),
        details: z.object({
          name: z.string().optional(),
          type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
          bytes: z.number().optional(),
          format: z.string().optional(),
          sha256: z.string().optional(),
          width: z.number().optional(),
          height: z.number().optional(),
          order: z.number().optional()
        }).optional()
      }).optional()
    }).optional().nullable(),
    defaultTokenImage: z.object({
      url: z.string(),
      details: z.object({
        name: z.string().optional(),
        type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
        bytes: z.number().optional(),
        format: z.string().optional(),
        sha256: z.string().optional(),
        width: z.number().optional(),
        height: z.number().optional(),
        order: z.number().optional()
      }).optional(),
      thumbnail: z.object({
        url: z.string(),
        details: z.object({
          name: z.string().optional(),
          type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
          bytes: z.number().optional(),
          format: z.string().optional(),
          sha256: z.string().optional(),
          width: z.number().optional(),
          height: z.number().optional(),
          order: z.number().optional()
        }).optional()
      }).optional()
    }).optional().nullable(),
    potentialAttributes: z.array(
      z.object({
        trait_type: z.string(),
        display_type: z.string().optional(),
        values: z.array(z.union([z.string(), z.number()])).optional()
      })
    ).optional().nullable(),
    customizingSlots: z.record(
      z.object({
        type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]),
        collections: z.array(z.union([z.number(), z.string()])).optional(),
        name: z.string().optional(),
        image_overlay_specs: z.object({
          layer: z.number().optional(),
          order_in_layer: z.number().optional(),
          offset: z.object({
            x: z.number().optional(),
            y: z.number().optional()
          }).optional(),
          opacity: z.number().optional(),
          rotation: z.number().optional(),
          scale: z.object({
            x: z.number().optional(),
            y: z.number().optional(),
            unit: z.enum(["px", "%"]).default("%").optional().optional()
          }).optional(),
          anchor_point: z.object({
            x: z.number(),
            y: z.number()
          }).optional(),
          parent_anchor_point: z.object({
            x: z.number(),
            y: z.number()
          }).optional()
        }).optional()
      })
    ).optional().nullable(),
    customizes: z.array(z.union([z.number(), z.string()])).optional().nullable(),
    royalties: z.array(
      z.object({
        address: z.string(),
        percent: z.number(),
        isPrimaryOnly: z.boolean().optional()
      })
    ).optional().nullable(),
    collectionInfoError: z.string().nullable(),
    isBurned: z.boolean(),
    fetchedAtBlockNumber: z.number(),
    updatedAtBlockNumber: z.number(),
    updatedAt: z.coerce.date(),
    createdAt: z.coerce.date(),
    createdAtBlockNumber: z.number()
  }),
  zSingleCollectionParam: z.object({
    collectionId: z.string()
  })
};
var events = {
  zEventsFilter: z.object({
    sectionIn: z.array(z.string()).optional(),
    methodIn: z.array(z.string()).optional(),
    address: z.string().optional(),
    blockNumberFrom: z.number().optional(),
    blockNumberTo: z.number().optional(),
    limit: z.number().default(100).optional(),
    offset: z.number().default(0).optional(),
    orderByBlockNumber: z.enum(["asc", "desc"]).optional()
  }),
  zEventWithCount: z.object({
    items: z.array(
      z.object({
        extrinsicHash: z.string(),
        blockNumber: z.number(),
        blockTimestamp: z.number(),
        section: z.string(),
        method: z.string(),
        data: z.record(z.any()),
        asHex: z.string(),
        createdAt: z.coerce.date()
      })
    ),
    count: z.number()
  }),
  zSectionMethodArray: z.array(
    z.object({
      section: z.string(),
      method: z.string()
    })
  )
};
var extrinsics = {
  zSingleExtrinsicParam: z.object({
    hash: z.string()
  }),
  zExtrinsicsFilter: z.object({
    sectionIn: z.array(z.string()).optional(),
    methodIn: z.array(z.string()).optional(),
    signerIn: z.array(z.string()).optional(),
    blockNumberFrom: z.number().optional(),
    blockNumberTo: z.number().optional(),
    limit: z.number().default(100).optional(),
    offset: z.number().default(0).optional(),
    orderByBlockNumber: z.enum(["asc", "desc"]).optional(),
    orderByIndex: z.enum(["asc", "desc"]).optional()
  }),
  zExtrinsicRowSelect: z.object({
    hash: z.string(),
    blockHash: z.string(),
    blockNumber: z.number(),
    blockTimestamp: z.number(),
    indexInBlock: z.number(),
    signer: z.string(),
    section: z.string(),
    method: z.string(),
    args: z.record(z.any()),
    asHex: z.string(),
    createdAt: z.coerce.date(),
    events: z.array(
      z.object({
        section: z.string(),
        method: z.string(),
        data: z.record(z.any())
      })
    ).default([]).optional()
  }),
  zExtrinsicsWithCount: z.object({
    items: z.array(
      z.object({
        hash: z.string(),
        blockHash: z.string(),
        blockNumber: z.number(),
        blockTimestamp: z.number(),
        indexInBlock: z.number(),
        signer: z.string(),
        section: z.string(),
        method: z.string(),
        args: z.record(z.any()),
        asHex: z.string(),
        createdAt: z.coerce.date(),
        events: z.array(
          z.object({
            section: z.string(),
            method: z.string(),
            data: z.record(z.any())
          })
        ).default([]).optional()
      })
    ),
    count: z.number()
  })
};
var health = {
  zHealth: z.object({
    status: z.enum(["ok", "error"]),
    message: z.string().optional()
  })
};
var parsedNfts = {
  zParsedNftRowSelect: z.object({
    key: z.string(),
    collectionId: z.number(),
    tokenId: z.number(),
    collectionAddress: z.string(),
    tokenAddress: z.string(),
    owner: z.string(),
    topmostOwner: z.string().nullable(),
    isBundle: z.boolean(),
    properties: z.array(
      z.object({
        key: z.string(),
        keyHex: z.string(),
        value: z.string(),
        valueHex: z.string().optional()
      })
    ).nullable(),
    propertiesMap: z.record(
      z.object({
        key: z.string(),
        keyHex: z.string(),
        value: z.string(),
        valueHex: z.string().optional()
      })
    ).nullable(),
    schemaName: z.string().nullable(),
    schemaVersion: z.string().nullable(),
    originalSchemaVersion: z.string().nullable(),
    name: z.string().nullable(),
    description: z.string().nullable(),
    image: z.string().nullable(),
    imageDetails: z.object({
      name: z.string().optional(),
      type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
      bytes: z.number().optional(),
      format: z.string().optional(),
      sha256: z.string().optional(),
      width: z.number().optional(),
      height: z.number().optional(),
      order: z.number().optional()
    }).optional().nullable(),
    attributes: z.array(
      z.object({
        trait_type: z.string(),
        value: z.union([z.string(), z.number()]),
        display_type: z.string().optional()
      })
    ).optional().nullable(),
    media: z.record(
      z.object({
        type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]),
        url: z.string(),
        name: z.string().optional(),
        details: z.object({
          name: z.string().optional(),
          type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
          bytes: z.number().optional(),
          format: z.string().optional(),
          sha256: z.string().optional(),
          width: z.number().optional(),
          height: z.number().optional(),
          order: z.number().optional(),
          duration: z.number().optional(),
          codecs: z.array(z.string()).optional(),
          loop: z.boolean().optional()
        }).optional(),
        thumbnail: z.object({
          url: z.string(),
          details: z.object({
            name: z.string().optional(),
            type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
            bytes: z.number().optional(),
            format: z.string().optional(),
            sha256: z.string().optional(),
            width: z.number().optional(),
            height: z.number().optional(),
            order: z.number().optional()
          }).optional()
        }).optional(),
        poster: z.object({
          url: z.string(),
          details: z.object({
            name: z.string().optional(),
            type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
            bytes: z.number().optional(),
            format: z.string().optional(),
            sha256: z.string().optional(),
            width: z.number().optional(),
            height: z.number().optional(),
            order: z.number().optional()
          }).optional()
        }).optional()
      })
    ).optional().nullable(),
    royalties: z.array(
      z.object({
        address: z.string(),
        percent: z.number(),
        isPrimaryOnly: z.boolean().optional()
      })
    ).optional().nullable(),
    customizing: z.object({
      self: z.object({
        type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]),
        url: z.string(),
        name: z.string().optional(),
        details: z.object({
          name: z.string().optional(),
          type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
          bytes: z.number().optional(),
          format: z.string().optional(),
          sha256: z.string().optional(),
          width: z.number().optional(),
          height: z.number().optional(),
          order: z.number().optional(),
          duration: z.number().optional(),
          codecs: z.array(z.string()).optional(),
          loop: z.boolean().optional()
        }).optional(),
        image_overlay_specs: z.object({
          layer: z.number().optional(),
          order_in_layer: z.number().optional(),
          offset: z.object({
            x: z.number().optional(),
            y: z.number().optional()
          }).optional(),
          opacity: z.number().optional(),
          rotation: z.number().optional(),
          scale: z.object({
            x: z.number().optional(),
            y: z.number().optional(),
            unit: z.enum(["px", "%"]).default("%").optional().optional()
          }).optional(),
          anchor_point: z.object({
            x: z.number(),
            y: z.number()
          }).optional(),
          parent_anchor_point: z.object({
            x: z.number(),
            y: z.number()
          }).optional()
        }).optional(),
        placeholder: z.object({
          url: z.string(),
          details: z.object({
            name: z.string().optional(),
            type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
            bytes: z.number().optional(),
            format: z.string().optional(),
            sha256: z.string().optional(),
            width: z.number().optional(),
            height: z.number().optional(),
            order: z.number().optional()
          }).optional()
        }).optional(),
        tag: z.string()
      }),
      slots: z.record(
        z.object({
          type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]),
          collections: z.array(z.union([z.number(), z.string()])).optional(),
          name: z.string().optional(),
          image_overlay_specs: z.object({
            layer: z.number().optional(),
            order_in_layer: z.number().optional(),
            offset: z.object({
              x: z.number().optional(),
              y: z.number().optional()
            }).optional(),
            opacity: z.number().optional(),
            rotation: z.number().optional(),
            scale: z.object({
              x: z.number().optional(),
              y: z.number().optional(),
              unit: z.enum(["px", "%"]).default("%").optional().optional()
            }).optional(),
            anchor_point: z.object({
              x: z.number(),
              y: z.number()
            }).optional(),
            parent_anchor_point: z.object({
              x: z.number(),
              y: z.number()
            }).optional()
          }).optional()
        })
      ).optional(),
      mutator_reactions: z.record(
        z.object({
          layer: z.number().optional().optional(),
          order_in_layer: z.number().optional().optional(),
          offset: z.object({
            x: z.number().optional(),
            y: z.number().optional()
          }).optional().optional(),
          opacity: z.number().optional().optional(),
          rotation: z.number().optional().optional(),
          scale: z.object({
            x: z.number().optional(),
            y: z.number().optional(),
            unit: z.enum(["px", "%"]).default("%").optional().optional()
          }).optional().optional(),
          anchor_point: z.object({
            x: z.number(),
            y: z.number()
          }).optional().optional(),
          parent_anchor_point: z.object({
            x: z.number(),
            y: z.number()
          }).optional().optional(),
          url: z.string().optional(),
          details: z.object({
            name: z.string().optional(),
            type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
            bytes: z.number().optional(),
            format: z.string().optional(),
            sha256: z.string().optional(),
            width: z.number().optional(),
            height: z.number().optional(),
            order: z.number().optional()
          }).optional()
        })
      ).optional(),
      mutators: z.array(z.string()).optional()
    }).optional().nullable(),
    customizingOverrides: z.object({
      self: z.object({
        type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
        url: z.string().optional(),
        name: z.string().optional().optional(),
        details: z.object({
          name: z.string().optional(),
          type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
          bytes: z.number().optional(),
          format: z.string().optional(),
          sha256: z.string().optional(),
          width: z.number().optional(),
          height: z.number().optional(),
          order: z.number().optional(),
          duration: z.number().optional(),
          codecs: z.array(z.string()).optional(),
          loop: z.boolean().optional()
        }).optional().optional(),
        image_overlay_specs: z.object({
          layer: z.number().optional(),
          order_in_layer: z.number().optional(),
          offset: z.object({
            x: z.number().optional(),
            y: z.number().optional()
          }).optional(),
          opacity: z.number().optional(),
          rotation: z.number().optional(),
          scale: z.object({
            x: z.number().optional(),
            y: z.number().optional(),
            unit: z.enum(["px", "%"]).default("%").optional().optional()
          }).optional(),
          anchor_point: z.object({
            x: z.number(),
            y: z.number()
          }).optional(),
          parent_anchor_point: z.object({
            x: z.number(),
            y: z.number()
          }).optional()
        }).optional().optional(),
        placeholder: z.object({
          url: z.string(),
          details: z.object({
            name: z.string().optional(),
            type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
            bytes: z.number().optional(),
            format: z.string().optional(),
            sha256: z.string().optional(),
            width: z.number().optional(),
            height: z.number().optional(),
            order: z.number().optional()
          }).optional()
        }).optional().optional(),
        tag: z.string().optional()
      }).optional(),
      slots: z.record(
        z.object({
          type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
          collections: z.array(z.union([z.number(), z.string()])).optional().optional(),
          name: z.string().optional().optional(),
          image_overlay_specs: z.object({
            layer: z.number().optional(),
            order_in_layer: z.number().optional(),
            offset: z.object({
              x: z.number().optional(),
              y: z.number().optional()
            }).optional(),
            opacity: z.number().optional(),
            rotation: z.number().optional(),
            scale: z.object({
              x: z.number().optional(),
              y: z.number().optional(),
              unit: z.enum(["px", "%"]).default("%").optional().optional()
            }).optional(),
            anchor_point: z.object({
              x: z.number(),
              y: z.number()
            }).optional(),
            parent_anchor_point: z.object({
              x: z.number(),
              y: z.number()
            }).optional()
          }).optional().optional()
        })
      ).optional(),
      mutator_reactions: z.record(
        z.object({
          layer: z.number().optional().optional().optional(),
          order_in_layer: z.number().optional().optional().optional(),
          offset: z.object({
            x: z.number().optional(),
            y: z.number().optional()
          }).optional().optional().optional(),
          opacity: z.number().optional().optional().optional(),
          rotation: z.number().optional().optional().optional(),
          scale: z.object({
            x: z.number().optional(),
            y: z.number().optional(),
            unit: z.enum(["px", "%"]).default("%").optional().optional()
          }).optional().optional().optional(),
          anchor_point: z.object({
            x: z.number(),
            y: z.number()
          }).optional().optional().optional(),
          parent_anchor_point: z.object({
            x: z.number(),
            y: z.number()
          }).optional().optional().optional(),
          url: z.string().optional().optional(),
          details: z.object({
            name: z.string().optional(),
            type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
            bytes: z.number().optional(),
            format: z.string().optional(),
            sha256: z.string().optional(),
            width: z.number().optional(),
            height: z.number().optional(),
            order: z.number().optional()
          }).optional().optional()
        })
      ).optional(),
      mutators: z.array(z.string()).optional()
    }).optional().nullable(),
    animationUrl: z.string().nullable(),
    animationDetails: z.object({
      name: z.string().optional(),
      type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
      bytes: z.number().optional(),
      format: z.string().optional(),
      sha256: z.string().optional(),
      width: z.number().optional(),
      height: z.number().optional(),
      order: z.number().optional()
    }).optional().nullable(),
    youtubeUrl: z.string().nullable(),
    createdBy: z.string().nullable(),
    backgroundColor: z.string().nullable(),
    externalUrl: z.string().nullable(),
    locale: z.string().nullable(),
    tokenInfoError: z.string().nullable(),
    isBurned: z.boolean(),
    fetchedAtBlockNumber: z.number(),
    updatedAtBlockNumber: z.number(),
    updatedAt: z.coerce.date(),
    createdAtBlockNumber: z.number(),
    createdAt: z.coerce.date()
  }),
  zParsedNftsFilter: z.object({
    collectionIdIn: z.array(z.string()).optional(),
    tokenIdIn: z.array(z.number()).optional(),
    ownerIn: z.array(z.string()).optional(),
    topmostOwnerIn: z.array(z.string()).optional(),
    royaltyRecipientIn: z.array(z.string()).optional(),
    isBurned: z.boolean().optional(),
    isBundle: z.boolean().optional(),
    attributeValueIn: z.array(z.string()).optional(),
    attributeTraitTypeIn: z.array(z.string()).optional(),
    createdTimestampFrom: z.coerce.date().optional(),
    createdTimestampTo: z.coerce.date().optional(),
    updatedTimestampFrom: z.coerce.date().optional(),
    updatedTimestampTo: z.coerce.date().optional(),
    offset: z.number().default(0).optional(),
    limit: z.number().default(10).optional(),
    orderByCollectionId: z.enum(["asc", "desc"]).optional(),
    orderByTokenId: z.enum(["asc", "desc"]).optional(),
    orderByCreatedAtBlockNumber: z.enum(["asc", "desc"]).optional(),
    orderByOwner: z.enum(["asc", "desc"]).optional()
  }),
  zParsedNftsWithCount: z.object({
    items: z.array(
      z.object({
        key: z.string(),
        collectionId: z.number(),
        tokenId: z.number(),
        collectionAddress: z.string(),
        tokenAddress: z.string(),
        owner: z.string(),
        topmostOwner: z.string().nullable(),
        isBundle: z.boolean(),
        properties: z.array(
          z.object({
            key: z.string(),
            keyHex: z.string(),
            value: z.string(),
            valueHex: z.string().optional()
          })
        ).nullable(),
        propertiesMap: z.record(
          z.object({
            key: z.string(),
            keyHex: z.string(),
            value: z.string(),
            valueHex: z.string().optional()
          })
        ).nullable(),
        schemaName: z.string().nullable(),
        schemaVersion: z.string().nullable(),
        originalSchemaVersion: z.string().nullable(),
        name: z.string().nullable(),
        description: z.string().nullable(),
        image: z.string().nullable(),
        imageDetails: z.object({
          name: z.string().optional(),
          type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
          bytes: z.number().optional(),
          format: z.string().optional(),
          sha256: z.string().optional(),
          width: z.number().optional(),
          height: z.number().optional(),
          order: z.number().optional()
        }).optional().nullable(),
        attributes: z.array(
          z.object({
            trait_type: z.string(),
            value: z.union([z.string(), z.number()]),
            display_type: z.string().optional()
          })
        ).optional().nullable(),
        media: z.record(
          z.object({
            type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]),
            url: z.string(),
            name: z.string().optional(),
            details: z.object({
              name: z.string().optional(),
              type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
              bytes: z.number().optional(),
              format: z.string().optional(),
              sha256: z.string().optional(),
              width: z.number().optional(),
              height: z.number().optional(),
              order: z.number().optional(),
              duration: z.number().optional(),
              codecs: z.array(z.string()).optional(),
              loop: z.boolean().optional()
            }).optional(),
            thumbnail: z.object({
              url: z.string(),
              details: z.object({
                name: z.string().optional(),
                type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
                bytes: z.number().optional(),
                format: z.string().optional(),
                sha256: z.string().optional(),
                width: z.number().optional(),
                height: z.number().optional(),
                order: z.number().optional()
              }).optional()
            }).optional(),
            poster: z.object({
              url: z.string(),
              details: z.object({
                name: z.string().optional(),
                type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
                bytes: z.number().optional(),
                format: z.string().optional(),
                sha256: z.string().optional(),
                width: z.number().optional(),
                height: z.number().optional(),
                order: z.number().optional()
              }).optional()
            }).optional()
          })
        ).optional().nullable(),
        royalties: z.array(
          z.object({
            address: z.string(),
            percent: z.number(),
            isPrimaryOnly: z.boolean().optional()
          })
        ).optional().nullable(),
        customizing: z.object({
          self: z.object({
            type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]),
            url: z.string(),
            name: z.string().optional(),
            details: z.object({
              name: z.string().optional(),
              type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
              bytes: z.number().optional(),
              format: z.string().optional(),
              sha256: z.string().optional(),
              width: z.number().optional(),
              height: z.number().optional(),
              order: z.number().optional(),
              duration: z.number().optional(),
              codecs: z.array(z.string()).optional(),
              loop: z.boolean().optional()
            }).optional(),
            image_overlay_specs: z.object({
              layer: z.number().optional(),
              order_in_layer: z.number().optional(),
              offset: z.object({
                x: z.number().optional(),
                y: z.number().optional()
              }).optional(),
              opacity: z.number().optional(),
              rotation: z.number().optional(),
              scale: z.object({
                x: z.number().optional(),
                y: z.number().optional(),
                unit: z.enum(["px", "%"]).default("%").optional().optional()
              }).optional(),
              anchor_point: z.object({
                x: z.number(),
                y: z.number()
              }).optional(),
              parent_anchor_point: z.object({
                x: z.number(),
                y: z.number()
              }).optional()
            }).optional(),
            placeholder: z.object({
              url: z.string(),
              details: z.object({
                name: z.string().optional(),
                type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
                bytes: z.number().optional(),
                format: z.string().optional(),
                sha256: z.string().optional(),
                width: z.number().optional(),
                height: z.number().optional(),
                order: z.number().optional()
              }).optional()
            }).optional(),
            tag: z.string()
          }),
          slots: z.record(
            z.object({
              type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]),
              collections: z.array(z.union([z.number(), z.string()])).optional(),
              name: z.string().optional(),
              image_overlay_specs: z.object({
                layer: z.number().optional(),
                order_in_layer: z.number().optional(),
                offset: z.object({
                  x: z.number().optional(),
                  y: z.number().optional()
                }).optional(),
                opacity: z.number().optional(),
                rotation: z.number().optional(),
                scale: z.object({
                  x: z.number().optional(),
                  y: z.number().optional(),
                  unit: z.enum(["px", "%"]).default("%").optional().optional()
                }).optional(),
                anchor_point: z.object({
                  x: z.number(),
                  y: z.number()
                }).optional(),
                parent_anchor_point: z.object({
                  x: z.number(),
                  y: z.number()
                }).optional()
              }).optional()
            })
          ).optional(),
          mutator_reactions: z.record(
            z.object({
              layer: z.number().optional().optional(),
              order_in_layer: z.number().optional().optional(),
              offset: z.object({
                x: z.number().optional(),
                y: z.number().optional()
              }).optional().optional(),
              opacity: z.number().optional().optional(),
              rotation: z.number().optional().optional(),
              scale: z.object({
                x: z.number().optional(),
                y: z.number().optional(),
                unit: z.enum(["px", "%"]).default("%").optional().optional()
              }).optional().optional(),
              anchor_point: z.object({
                x: z.number(),
                y: z.number()
              }).optional().optional(),
              parent_anchor_point: z.object({
                x: z.number(),
                y: z.number()
              }).optional().optional(),
              url: z.string().optional(),
              details: z.object({
                name: z.string().optional(),
                type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
                bytes: z.number().optional(),
                format: z.string().optional(),
                sha256: z.string().optional(),
                width: z.number().optional(),
                height: z.number().optional(),
                order: z.number().optional()
              }).optional()
            })
          ).optional(),
          mutators: z.array(z.string()).optional()
        }).optional().nullable(),
        customizingOverrides: z.object({
          self: z.object({
            type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
            url: z.string().optional(),
            name: z.string().optional().optional(),
            details: z.object({
              name: z.string().optional(),
              type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
              bytes: z.number().optional(),
              format: z.string().optional(),
              sha256: z.string().optional(),
              width: z.number().optional(),
              height: z.number().optional(),
              order: z.number().optional(),
              duration: z.number().optional(),
              codecs: z.array(z.string()).optional(),
              loop: z.boolean().optional()
            }).optional().optional(),
            image_overlay_specs: z.object({
              layer: z.number().optional(),
              order_in_layer: z.number().optional(),
              offset: z.object({
                x: z.number().optional(),
                y: z.number().optional()
              }).optional(),
              opacity: z.number().optional(),
              rotation: z.number().optional(),
              scale: z.object({
                x: z.number().optional(),
                y: z.number().optional(),
                unit: z.enum(["px", "%"]).default("%").optional().optional()
              }).optional(),
              anchor_point: z.object({
                x: z.number(),
                y: z.number()
              }).optional(),
              parent_anchor_point: z.object({
                x: z.number(),
                y: z.number()
              }).optional()
            }).optional().optional(),
            placeholder: z.object({
              url: z.string(),
              details: z.object({
                name: z.string().optional(),
                type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
                bytes: z.number().optional(),
                format: z.string().optional(),
                sha256: z.string().optional(),
                width: z.number().optional(),
                height: z.number().optional(),
                order: z.number().optional()
              }).optional()
            }).optional().optional(),
            tag: z.string().optional()
          }).optional(),
          slots: z.record(
            z.object({
              type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
              collections: z.array(z.union([z.number(), z.string()])).optional().optional(),
              name: z.string().optional().optional(),
              image_overlay_specs: z.object({
                layer: z.number().optional(),
                order_in_layer: z.number().optional(),
                offset: z.object({
                  x: z.number().optional(),
                  y: z.number().optional()
                }).optional(),
                opacity: z.number().optional(),
                rotation: z.number().optional(),
                scale: z.object({
                  x: z.number().optional(),
                  y: z.number().optional(),
                  unit: z.enum(["px", "%"]).default("%").optional().optional()
                }).optional(),
                anchor_point: z.object({
                  x: z.number(),
                  y: z.number()
                }).optional(),
                parent_anchor_point: z.object({
                  x: z.number(),
                  y: z.number()
                }).optional()
              }).optional().optional()
            })
          ).optional(),
          mutator_reactions: z.record(
            z.object({
              layer: z.number().optional().optional().optional(),
              order_in_layer: z.number().optional().optional().optional(),
              offset: z.object({
                x: z.number().optional(),
                y: z.number().optional()
              }).optional().optional().optional(),
              opacity: z.number().optional().optional().optional(),
              rotation: z.number().optional().optional().optional(),
              scale: z.object({
                x: z.number().optional(),
                y: z.number().optional(),
                unit: z.enum(["px", "%"]).default("%").optional().optional()
              }).optional().optional().optional(),
              anchor_point: z.object({
                x: z.number(),
                y: z.number()
              }).optional().optional().optional(),
              parent_anchor_point: z.object({
                x: z.number(),
                y: z.number()
              }).optional().optional().optional(),
              url: z.string().optional().optional(),
              details: z.object({
                name: z.string().optional(),
                type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
                bytes: z.number().optional(),
                format: z.string().optional(),
                sha256: z.string().optional(),
                width: z.number().optional(),
                height: z.number().optional(),
                order: z.number().optional()
              }).optional().optional()
            })
          ).optional(),
          mutators: z.array(z.string()).optional()
        }).optional().nullable(),
        animationUrl: z.string().nullable(),
        animationDetails: z.object({
          name: z.string().optional(),
          type: z.enum(["image", "animation", "video", "audio", "spatial", "pdf", "document", "other"]).optional(),
          bytes: z.number().optional(),
          format: z.string().optional(),
          sha256: z.string().optional(),
          width: z.number().optional(),
          height: z.number().optional(),
          order: z.number().optional()
        }).optional().nullable(),
        youtubeUrl: z.string().nullable(),
        createdBy: z.string().nullable(),
        backgroundColor: z.string().nullable(),
        externalUrl: z.string().nullable(),
        locale: z.string().nullable(),
        tokenInfoError: z.string().nullable(),
        isBurned: z.boolean(),
        fetchedAtBlockNumber: z.number(),
        updatedAtBlockNumber: z.number(),
        updatedAt: z.coerce.date(),
        createdAtBlockNumber: z.number(),
        createdAt: z.coerce.date()
      })
    ),
    count: z.number()
  }),
  zSingleParsedNftParam: z.object({
    collectionId: z.string(),
    tokenId: z.number()
  })
};
var tokenBalances = {
  zTokenBalancesFilter: z.object({
    addressIn: z.array(z.string()).optional(),
    mode: z.enum(["NFT", "Fungible", "RFT"]).optional(),
    collectionIdIn: z.array(z.string()).optional(),
    tokenIdIn: z.array(z.string()).optional(),
    amountFrom: z.bigint().optional(),
    amountTo: z.bigint().optional(),
    offset: z.number().default(0).optional(),
    limit: z.number().default(100).optional(),
    orderByAddress: z.enum(["asc", "desc"]).optional(),
    orderByCollectionId: z.enum(["asc", "desc"]).optional(),
    orderByTokenId: z.enum(["asc", "desc"]).optional(),
    orderByAmount: z.enum(["asc", "desc"]).optional()
  }),
  zTokenBalancesWithCount: z.object({
    items: z.array(
      z.object({
        key: z.string(),
        address: z.string(),
        collectionId: z.number(),
        tokenId: z.number(),
        amount: z.string(),
        createdAtBlockNumber: z.number(),
        updatedAtBlockNumber: z.number(),
        fetchedAtBlockNumber: z.number(),
        createdAt: z.coerce.date(),
        updatedAt: z.coerce.date()
      })
    ),
    count: z.number()
  })
};
var tokensTransfers = {
  zTokenBalancesTransfersFilter: z.object({
    fromIn: z.array(z.string()).optional(),
    toIn: z.array(z.string()).optional(),
    mode: z.enum(["NFT", "Fungible", "RFT"]).optional(),
    collectionIdIn: z.array(z.string()).optional(),
    tokenIdIn: z.array(z.number()).optional(),
    amountFrom: z.bigint().optional(),
    amountTo: z.bigint().optional(),
    orderByFrom: z.enum(["asc", "desc"]).optional(),
    orderByTo: z.enum(["asc", "desc"]).optional(),
    orderByAmount: z.enum(["asc", "desc"]).optional(),
    orderByCollectionId: z.enum(["asc", "desc"]).optional(),
    orderByTokenId: z.enum(["asc", "desc"]).optional(),
    offset: z.number().default(0).optional(),
    limit: z.number().default(100).optional()
  }),
  zTokenBalancesTransfersWithCount: z.object({
    items: z.array(
      z.object({
        id: z.number(),
        from: z.string(),
        to: z.string(),
        collectionId: z.number(),
        tokenId: z.number(),
        amount: z.string(),
        eventId: z.number(),
        event: z.object({
          blockNumber: z.number(),
          blockTimestamp: z.number(),
          extrinsicHash: z.string(),
          extrinsic: z.object({
            indexInBlock: z.number(),
            section: z.string().optional(),
            method: z.string().optional(),
            signer: z.string().optional()
          })
        })
      })
    ),
    count: z.number()
  })
};

// src/indexer/routes.ts
import { z as z2 } from "zod";
var ROUTES = {
  accounts: {
    single: {
      route: "/accounts/:address",
      schemaIn: accounts.zSingleAccountParams,
      schemaOut: accounts.zAccountRowSelect
    },
    multiple: { route: "/accounts", schemaIn: accounts.zAccountsFilter, schemaOut: accounts.zAccountsWithCount }
  },
  blocks: {
    single: { route: "/blocks/:hashOrNumber", schemaIn: z2.object({ hashOrNumber: z2.union([z2.string(), z2.number().int()]) }), schemaOut: blocks.zBlockRowSelect },
    multiple: { route: "/blocks", schemaIn: blocks.zBlocksFilter, schemaOut: blocks.zBlocksWithCount }
  },
  coinBalances: {
    single: {
      route: "/balance/:address",
      schemaIn: coinBalances.zSingleCoinBalanceParam,
      schemaOut: coinBalances.zCoinBalanceRowSelect
    },
    multiple: { route: "/balance", schemaIn: coinBalances.zCoinBalancesFilter, schemaOut: coinBalances.zCoinBalancesWithCount }
  },
  balanceTransfers: {
    multiple: { route: "/balance/transfers", schemaIn: coinTransfers.zCoinBalancesTransfersFilter, schemaOut: coinTransfers.zCoinBalancesTransfersWithCount }
  },
  collections: {
    single: {
      route: "/collections/:collectionId",
      schemaIn: collections.zSingleCollectionParam,
      schemaOut: collections.zParsedCollectionRowSelect
    },
    multiple: { route: "/collections", schemaIn: collections.zCollectionsFilter, schemaOut: collections.zCollectionsWithCount }
  },
  events: {
    multiple: {
      route: "/events",
      schemaIn: events.zEventsFilter,
      schemaOut: events.zEventWithCount
    },
    sections: { route: "/events/sections", schemaIn: z2.never(), schemaOut: events.zSectionMethodArray }
  },
  extrinsics: {
    single: {
      route: "/extrinsics/:hash",
      schemaIn: extrinsics.zSingleExtrinsicParam,
      schemaOut: extrinsics.zExtrinsicRowSelect
    },
    multiple: { route: "/extrinsics", schemaIn: extrinsics.zExtrinsicsFilter, schemaOut: extrinsics.zExtrinsicsWithCount },
    sections: { route: "/extrinsics/sections", schemaIn: z2.never(), schemaOut: events.zSectionMethodArray }
  },
  parsedNfts: {
    single: {
      route: "/nfts/:collectionId/:tokenId",
      schemaIn: parsedNfts.zSingleParsedNftParam,
      schemaOut: parsedNfts.zParsedNftRowSelect
    },
    multiple: { route: "/nfts", schemaIn: parsedNfts.zParsedNftsFilter, schemaOut: parsedNfts.zParsedNftsWithCount }
  },
  tokenBalances: {
    multiple: {
      route: "/tokens",
      schemaIn: tokenBalances.zTokenBalancesFilter,
      schemaOut: tokenBalances.zTokenBalancesWithCount
    }
  },
  tokensTransfers: {
    multiple: {
      route: "/tokens/transfers",
      schemaIn: tokensTransfers.zTokenBalancesTransfersFilter,
      schemaOut: tokensTransfers.zTokenBalancesTransfersWithCount
    }
  }
};

// src/indexer/index.ts
var buildUrlWithParams = (url, params) => {
  let result = url;
  for (const key in params) {
    result = result.replace(`:${key}`, encodeURIComponent(params[key]));
  }
  return result;
};
var UniqueIndexer = (options) => {
  const client = Axios.create({
    ...options.axiosConfig,
    baseURL: options.baseUrl,
    paramsSerializer: (params) => qs.stringify(params, { arrayFormat: "repeat" })
  });
  const requestViaPathParams = (routeConfig) => {
    const { route, schemaIn, schemaOut } = routeConfig;
    return async (input) => {
      const parseInputResult = schemaIn.safeParse(input);
      if (!parseInputResult.success)
        throw parseInputResult.error.format();
      const url = buildUrlWithParams(route, parseInputResult.data);
      const { data } = await client.get(url);
      return schemaOut.parse(data);
    };
  };
  const requestViaQueryString = (routeConfig) => {
    const { route, schemaOut } = routeConfig;
    const schemaIn = routeConfig.schemaIn.optional();
    return async (input) => {
      const params = schemaIn.parse(input);
      const { data } = await client.get(route, { params });
      return schemaOut.parse(data);
    };
  };
  return {
    options,
    block: requestViaPathParams(ROUTES.blocks.single),
    blocks: requestViaQueryString(ROUTES.blocks.multiple),
    account: requestViaPathParams(ROUTES.accounts.single),
    accounts: requestViaQueryString(ROUTES.accounts.multiple),
    coinBalance: requestViaPathParams(ROUTES.coinBalances.single),
    coinBalances: requestViaQueryString(ROUTES.coinBalances.multiple),
    balanceTransfers: requestViaQueryString(ROUTES.balanceTransfers.multiple),
    collection: requestViaPathParams(ROUTES.collections.single),
    collections: requestViaQueryString(ROUTES.collections.multiple),
    nft: requestViaPathParams(ROUTES.parsedNfts.single),
    nfts: requestViaQueryString(ROUTES.parsedNfts.multiple),
    events: requestViaQueryString(ROUTES.events.multiple),
    eventSections: requestViaQueryString(ROUTES.events.sections),
    extrinsic: requestViaPathParams(ROUTES.extrinsics.single),
    extrinsics: requestViaQueryString(ROUTES.extrinsics.multiple),
    extrinsicSections: requestViaQueryString(ROUTES.extrinsics.sections),
    tokenBalances: requestViaQueryString(ROUTES.tokenBalances.multiple),
    tokenTransfers: requestViaQueryString(ROUTES.tokensTransfers.multiple)
  };
};
export {
  UniqueIndexer
};
//# sourceMappingURL=uniqueIndexer.js.map